diff --git a/docker-compose.build.yml b/docker-compose.build.yml
index 26aa853..cd00d0c 100644
--- a/docker-compose.build.yml
+++ b/docker-compose.build.yml
@@ -22,7 +22,7 @@ services:
       SALT: mysalt
       ENCRYPTION_KEY: "0000000000000000000000000000000000000000000000000000000000000000" # generate via `openssl rand -hex 32`
       NEXTAUTH_URL: http://localhost:3000
-      TELEMETRY_ENABLED: ${TELEMETRY_ENABLED:-true}
+      TELEMETRY_ENABLED: ${TELEMETRY_ENABLED:-false}
       LANGFUSE_ENABLE_EXPERIMENTAL_FEATURES: ${LANGFUSE_ENABLE_EXPERIMENTAL_FEATURES:-false}
       LANGFUSE_INIT_ORG_ID: ${LANGFUSE_INIT_ORG_ID:-}
       LANGFUSE_INIT_ORG_NAME: ${LANGFUSE_INIT_ORG_NAME:-}
diff --git a/docker-compose.yml b/docker-compose.yml
index 7491ab4..d29e70e 100644
--- a/docker-compose.yml
+++ b/docker-compose.yml
@@ -22,7 +22,7 @@ services:
       DATABASE_URL: postgresql://postgres:postgres@postgres:5432/postgres # CHANGEME
       SALT: "mysalt" # CHANGEME
       ENCRYPTION_KEY: "0000000000000000000000000000000000000000000000000000000000000000" # CHANGEME: generate via `openssl rand -hex 32`
-      TELEMETRY_ENABLED: ${TELEMETRY_ENABLED:-true}
+      TELEMETRY_ENABLED: ${TELEMETRY_ENABLED:-false}
       LANGFUSE_ENABLE_EXPERIMENTAL_FEATURES: ${LANGFUSE_ENABLE_EXPERIMENTAL_FEATURES:-true}
       CLICKHOUSE_MIGRATION_URL: ${CLICKHOUSE_MIGRATION_URL:-clickhouse://clickhouse:9000}
       CLICKHOUSE_URL: ${CLICKHOUSE_URL:-http://clickhouse:8123}
diff --git a/ee/.eslintrc.js b/ee/.eslintrc.js
deleted file mode 100644
index 15ec24a..0000000
--- a/ee/.eslintrc.js
+++ /dev/null
@@ -1,8 +0,0 @@
-/** @type {import("eslint").Linter.Config} */
-module.exports = {
-  extends: ["@repo/eslint-config/library.js"],
-  parser: "@typescript-eslint/parser",
-  parserOptions: {
-    project: true,
-  },
-};
diff --git a/ee/LICENSE b/ee/LICENSE
deleted file mode 100644
index d0a150c..0000000
--- a/ee/LICENSE
+++ /dev/null
@@ -1,51 +0,0 @@
-START NOTE
-Langfuse is an open core project. Langfuse's core
-is permissively licensed (MIT license).
-Certain parts of the periphery of Langfuse are commercially
-licensed and governed by this Enterprise License.
-For the avoidance of doubt, this license does not apply 
-to the core of Langfuse as it is defined in its license in 
-the directory "/LICENSE" (as opposed to this file  "ee/LICENSE")
-which can be used and run without infringing the below license
-and its licensed materials.
-END NOTE
-
-START OF LICENSE
-Langfuse Enterprise license (the “Enterprise License” or "EE license")
-
-Copyright (c) 2023-2025 Langfuse GmbH
-
-With regard to the Langfuse Enterprise Software:
-This software and associated documentation files (the "Software") may only be
-used, if you (and any entity that you represent) have agreed to,
-and are in compliance with, the applicable Langfuse Terms of Service, available
-at https://langfuse.com/terms (the “Enterprise Terms”), or other
-agreement governing the use of the Software, as agreed by you and Langfuse,
-and otherwise have a valid Langfuse Enterprise License.
-
-Subject to the foregoing sentence, you are free to
-modify this Software and publish patches to the Software. You agree that Langfuse
-and/or its licensors (as applicable) retain all right, title and interest in and
-to all such modifications and/or patches, and all such modifications and/or
-patches may only be used, copied, modified, displayed, distributed, or otherwise
-exploited with a valid Langfuse Enterprise License. Notwithstanding the foregoing, you may copy and modify
-the Software for development and testing purposes, without requiring a
-subscription. You agree that Langfuse GmbH and/or its licensors (as applicable) retain
-all right, title and interest in and to all such modifications. You are not
-granted any other rights beyond what is expressly stated herein. Subject to the
-foregoing, it is forbidden to copy, merge, publish, distribute, sublicense,
-and/or sell the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-SOFTWARE.
-
-For all third party components incorporated into the Langfuse Software, those
-components are licensed under the original license provided by the owner of the
-applicable component.
-
-END OF LICENSE
diff --git a/ee/README.md b/ee/README.md
deleted file mode 100644
index fdc23d6..0000000
--- a/ee/README.md
+++ /dev/null
@@ -1,5 +0,0 @@
-# Enterprise Edition
-
-This folder includes features that are only available in the Enterprise Edition of Langfuse and on Langfuse Cloud.
-
-See [LICENSE](../LICENSE) and [docs](https://langfuse.com/docs/open-source) for more details.
diff --git a/ee/package.json b/ee/package.json
deleted file mode 100644
index fba183c..0000000
--- a/ee/package.json
+++ /dev/null
@@ -1,54 +0,0 @@
-{
-  "name": "@langfuse/ee",
-  "version": "1.0.0",
-  "private": true,
-  "main": "./dist/src/index.js",
-  "types": "./dist/src/index.d.ts",
-  "exports": {
-    ".": {
-      "import": "./dist/src/index.js",
-      "require": "./dist/src/index.js"
-    },
-    "./sso": {
-      "import": "./dist/src/sso/index.js",
-      "require": "./dist/src/sso/index.js"
-    }
-  },
-  "engines": {
-    "node": "20"
-  },
-  "scripts": {
-    "build": "tsc",
-    "dev": "tsc --watch",
-    "lint": "eslint . --ext .js,.jsx,.ts,.tsx --max-warnings 0",
-    "lint:fix": "eslint . --ext .js,.jsx,.ts,.tsx --fix"
-  },
-  "dependencies": {
-    "@langfuse/shared": "workspace:*",
-    "@opentelemetry/api": ">=1.0.0 <1.10.0",
-    "axios": "^1.8.2",
-    "https-proxy-agent": "^7.0.6",
-    "next": "^14.2.26",
-    "next-auth": "^4.24.11",
-    "zod": "^3.23.8"
-  },
-  "devDependencies": {
-    "@repo/eslint-config": "workspace:*",
-    "@repo/typescript-config": "workspace:*",
-    "@types/node": "^20.11.29",
-    "@typescript-eslint/parser": "^7.12.0",
-    "eslint": "^8.57.0",
-    "eslint-config-prettier": "^9.1.0",
-    "eslint-config-standard": "^17.1.0",
-    "eslint-plugin-prettier": "^5.1.3",
-    "prettier": "^3.3.3",
-    "ts-node": "^10.9.2",
-    "tsc-watch": "^6.2.0",
-    "typescript": "^5.4.5"
-  },
-  "pnpm": {
-    "overrides": {
-      "nanoid": "^3.3.8"
-    }
-  }
-}
diff --git a/ee/src/ee-license-check/index.ts b/ee/src/ee-license-check/index.ts
deleted file mode 100644
index 8fdd433..0000000
--- a/ee/src/ee-license-check/index.ts
+++ /dev/null
@@ -1,5 +0,0 @@
-import { env } from "../env";
-
-export const isEeAvailable: boolean =
-  env.NEXT_PUBLIC_LANGFUSE_CLOUD_REGION !== undefined ||
-  env.LANGFUSE_EE_LICENSE_KEY !== undefined;
diff --git a/ee/src/env.ts b/ee/src/env.ts
deleted file mode 100644
index 4bb1137..0000000
--- a/ee/src/env.ts
+++ /dev/null
@@ -1,9 +0,0 @@
-import { z } from "zod";
-import { removeEmptyEnvVariables } from "@langfuse/shared";
-
-const EnvSchema = z.object({
-  NEXT_PUBLIC_LANGFUSE_CLOUD_REGION: z.string().optional(),
-  LANGFUSE_EE_LICENSE_KEY: z.string().optional(),
-});
-
-export const env = EnvSchema.parse(removeEmptyEnvVariables(process.env));
diff --git a/ee/src/index.ts b/ee/src/index.ts
deleted file mode 100644
index e69de29..0000000
diff --git a/ee/tsconfig.json b/ee/tsconfig.json
deleted file mode 100644
index af062c2..0000000
--- a/ee/tsconfig.json
+++ /dev/null
@@ -1,14 +0,0 @@
-{
-  "extends": "@repo/typescript-config/base.json",
-  "compilerOptions": {
-    "moduleResolution": "NodeNext",
-    "module": "NodeNext",
-    "lib": ["ES2020"],
-    "outDir": "./dist",
-    "types": ["node"],
-    "target": "ES2020",
-    "rootDir": "."
-  },
-  "include": ["."],
-  "exclude": ["node_modules", "dist"]
-}
diff --git a/package.json b/package.json
index b017b96..b262a4f 100644
--- a/package.json
+++ b/package.json
@@ -9,16 +9,16 @@
   },
   "scripts": {
     "preinstall": "npx only-allow pnpm",
-    "infra:dev:up": "docker compose -f ./docker-compose.dev.yml up -d --wait",
-    "infra:dev:down": "docker compose -f ./docker-compose.dev.yml down",
-    "infra:dev:prune": "docker compose -f ./docker-compose.dev.yml down -v",
+    "infra:dev:up": "docker-compose -f ./docker-compose.dev.yml up -d --wait",
+    "infra:dev:down": "docker-compose -f ./docker-compose.dev.yml down",
+    "infra:dev:prune": "docker-compose -f ./docker-compose.dev.yml down -v",
     "db:generate": "turbo run db:generate",
     "db:migrate": "turbo run db:migrate",
     "db:seed": "turbo run db:seed",
     "db:seed:examples": "turbo run db:seed:examples",
     "nuke": "bash ./scripts/nuke.sh",
-    "dx": "pnpm i && pnpm run infra:dev:prune && pnpm run infra:dev:up --pull always && pnpm --filter=shared run db:reset && pnpm --filter=shared run ch:reset && pnpm --filter=shared run db:seed:examples && pnpm run dev",
-    "dx-f": "pnpm i && pnpm run infra:dev:prune && pnpm run infra:dev:up --pull always && pnpm --filter=shared run db:reset -f && pnpm --filter=shared run ch:reset && pnpm --filter=shared run db:seed:examples && pnpm run dev",
+    "dx": "TELEMETRY_ENABLED=false pnpm i && pnpm run infra:dev:prune && pnpm run infra:dev:up --pull always && pnpm --filter=shared run db:reset && pnpm --filter=shared run ch:reset && pnpm --filter=shared run db:seed:examples && pnpm run dev",
+    "dx-f": "TELEMETRY_ENABLED=false pnpm i && pnpm run infra:dev:prune && pnpm run infra:dev:up --pull always && pnpm --filter=shared run db:reset -f && pnpm --filter=shared run ch:reset && pnpm --filter=shared run db:seed:examples && pnpm run dev",
     "dx:skip-infra": "pnpm i && pnpm --filter=shared run db:reset && pnpm --filter=shared run ch:reset && pnpm --filter=shared run db:seed:examples && pnpm run dev",
     "build": "turbo run build",
     "start": "turbo run start",
diff --git a/pnpm-lock.yaml b/pnpm-lock.yaml
index 6d9dd4e..7256e1d 100644
--- a/pnpm-lock.yaml
+++ b/pnpm-lock.yaml
@@ -39,67 +39,6 @@ importers:
         specifier: ^1.13.4
         version: 1.13.4
 
-  ee:
-    dependencies:
-      '@langfuse/shared':
-        specifier: workspace:*
-        version: link:../packages/shared
-      '@opentelemetry/api':
-        specifier: '>=1.0.0 <1.10.0'
-        version: 1.9.0
-      axios:
-        specifier: ^1.8.2
-        version: 1.8.2
-      https-proxy-agent:
-        specifier: ^7.0.6
-        version: 7.0.6
-      next:
-        specifier: ^14.2.26
-        version: 14.2.26(@babel/core@7.24.3)(@opentelemetry/api@1.9.0)(@playwright/test@1.47.2)(babel-plugin-macros@3.1.0)(react-dom@18.2.0(react@18.2.0))(react@18.2.0)
-      next-auth:
-        specifier: ^4.24.11
-        version: 4.24.11(patch_hash=cczsf6i6qe2m2htirvgxjtoclu)(next@14.2.26(@babel/core@7.24.3)(@opentelemetry/api@1.9.0)(@playwright/test@1.47.2)(babel-plugin-macros@3.1.0)(react-dom@18.2.0(react@18.2.0))(react@18.2.0))(nodemailer@6.9.15)(react-dom@18.2.0(react@18.2.0))(react@18.2.0)
-      zod:
-        specifier: ^3.23.8
-        version: 3.23.8
-    devDependencies:
-      '@repo/eslint-config':
-        specifier: workspace:*
-        version: link:../packages/config-eslint
-      '@repo/typescript-config':
-        specifier: workspace:*
-        version: link:../packages/config-typescript
-      '@types/node':
-        specifier: ^20.11.29
-        version: 20.11.29
-      '@typescript-eslint/parser':
-        specifier: ^7.12.0
-        version: 7.12.0(eslint@8.57.0)(typescript@5.4.5)
-      eslint:
-        specifier: ^8.57.0
-        version: 8.57.0
-      eslint-config-prettier:
-        specifier: ^9.1.0
-        version: 9.1.0(eslint@8.57.0)
-      eslint-config-standard:
-        specifier: ^17.1.0
-        version: 17.1.0(eslint-plugin-import@2.29.1(@typescript-eslint/parser@7.12.0(eslint@8.57.0)(typescript@5.4.5))(eslint@8.57.0))(eslint-plugin-n@16.6.2(eslint@8.57.0))(eslint-plugin-promise@6.4.0(eslint@8.57.0))(eslint@8.57.0)
-      eslint-plugin-prettier:
-        specifier: ^5.1.3
-        version: 5.1.3(@types/eslint@8.56.12)(eslint-config-prettier@9.1.0(eslint@8.57.0))(eslint@8.57.0)(prettier@3.3.3)
-      prettier:
-        specifier: ^3.3.3
-        version: 3.3.3
-      ts-node:
-        specifier: ^10.9.2
-        version: 10.9.2(@types/node@20.11.29)(typescript@5.4.5)
-      tsc-watch:
-        specifier: ^6.2.0
-        version: 6.2.0(typescript@5.4.5)
-      typescript:
-        specifier: ^5.4.5
-        version: 5.4.5
-
   packages/config-eslint:
     devDependencies:
       '@typescript-eslint/eslint-plugin':
@@ -378,9 +317,6 @@ importers:
       '@langchain/openai':
         specifier: ^0.3.14
         version: 0.3.14(@langchain/core@0.3.18(openai@4.82.0(zod@3.23.8)))
-      '@langfuse/ee':
-        specifier: workspace:*
-        version: link:../ee
       '@langfuse/shared':
         specifier: workspace:*
         version: link:../packages/shared
diff --git a/web/package.json b/web/package.json
index 78358ad..139da21 100644
--- a/web/package.json
+++ b/web/package.json
@@ -39,7 +39,6 @@
     "@langchain/anthropic": "^0.3.8",
     "@langchain/core": "^0.3.18",
     "@langchain/openai": "^0.3.14",
-    "@langfuse/ee": "workspace:*",
     "@langfuse/shared": "workspace:*",
     "@lezer/highlight": "^1.2.1",
     "@marsidev/react-turnstile": "^0.5.4",
diff --git a/web/src/app/api/billing/stripe-webhook/route.ts b/web/src/app/api/billing/stripe-webhook/route.ts
index d67829f..0c16b3e 100644
--- a/web/src/app/api/billing/stripe-webhook/route.ts
+++ b/web/src/app/api/billing/stripe-webhook/route.ts
@@ -1,5 +1,5 @@
-import { stripeWebhookApiHandler } from "@/src/ee/features/billing/server/stripeWebhookApiHandler";
+// import { stripeWebhookApiHandler } from "@/src/ee/features/billing/server/stripeWebhookApiHandler";
 
 export const dynamic = "force-dynamic";
 
-export const POST = stripeWebhookApiHandler;
+export const POST = () => {}; // stripeWebhookApiHandler;
diff --git a/web/src/app/api/chatCompletion/route.ts b/web/src/app/api/chatCompletion/route.ts
index bd71039..e36c7e4 100644
--- a/web/src/app/api/chatCompletion/route.ts
+++ b/web/src/app/api/chatCompletion/route.ts
@@ -1,6 +1,6 @@
-import chatCompletionHandler from "@/src/ee/features/playground/server/chatCompletionHandler";
+// import chatCompletionHandler from "@/src/ee/features/playground/server/chatCompletionHandler";
 
 export const dynamic = "force-dynamic";
 export const maxDuration = 120;
 
-export const POST = chatCompletionHandler;
+export const POST = () => {}; // chatCompletionHandler;
diff --git a/web/src/components/LangfuseLogo.tsx b/web/src/components/LangfuseLogo.tsx
index dd14437..1a8f64d 100644
--- a/web/src/components/LangfuseLogo.tsx
+++ b/web/src/components/LangfuseLogo.tsx
@@ -2,8 +2,8 @@ import { cn } from "@/src/utils/tailwind";
 import Link from "next/link";
 import { VersionLabel } from "./VersionLabel";
 import { env } from "@/src/env.mjs";
-import { useUiCustomization } from "@/src/ee/features/ui-customization/useUiCustomization";
-import { PlusIcon } from "lucide-react";
+// import { useUiCustomization } from "@/src/ee/features/ui-customization/useUiCustomization";
+// import { PlusIcon } from "lucide-react";
 
 export const LangfuseIcon = ({
   size = 32,
@@ -23,38 +23,38 @@ export const LangfuseIcon = ({
 );
 
 const LangfuseLogotypeOrCustomized = ({ size }: { size: "sm" | "xl" }) => {
-  const uiCustomization = useUiCustomization();
+  // const uiCustomization = useUiCustomization();
 
-  if (uiCustomization?.logoLightModeHref && uiCustomization?.logoDarkModeHref) {
-    // logo is a url, maximum aspect ratio of 1:3 needs to be supported according to docs
-    return (
-      <div className="flex items-center gap-1">
-        {/* eslint-disable-next-line @next/next/no-img-element */}
-        <img
-          src={uiCustomization.logoLightModeHref}
-          alt="Langfuse Logo"
-          className={cn(
-            "group-data-[collapsible=icon]:hidden dark:hidden",
-            size === "sm" ? "max-h-4 max-w-14" : "max-h-5 max-w-16",
-          )}
-        />
-        {/* eslint-disable-next-line @next/next/no-img-element */}
-        <img
-          src={uiCustomization.logoDarkModeHref}
-          alt="Langfuse Logo"
-          className={cn(
-            "hidden group-data-[collapsible=icon]:hidden dark:block",
-            size === "sm" ? "max-h-4 max-w-14" : "max-h-5 max-w-16",
-          )}
-        />
-        <PlusIcon
-          size={size === "sm" ? 8 : 12}
-          className="group-data-[collapsible=icon]:hidden"
-        />
-        <LangfuseIcon size={size === "sm" ? 16 : 20} />
-      </div>
-    );
-  }
+  // if (uiCustomization?.logoLightModeHref && uiCustomization?.logoDarkModeHref) {
+  //   // logo is a url, maximum aspect ratio of 1:3 needs to be supported according to docs
+  //   return (
+  //     <div className="flex items-center gap-1">
+  //       {/* eslint-disable-next-line @next/next/no-img-element */}
+  //       <img
+  //         src={uiCustomization.logoLightModeHref}
+  //         alt="Langfuse Logo"
+  //         className={cn(
+  //           "group-data-[collapsible=icon]:hidden dark:hidden",
+  //           size === "sm" ? "max-h-4 max-w-14" : "max-h-5 max-w-16",
+  //         )}
+  //       />
+  //       {/* eslint-disable-next-line @next/next/no-img-element */}
+  //       <img
+  //         src={uiCustomization.logoDarkModeHref}
+  //         alt="Langfuse Logo"
+  //         className={cn(
+  //           "hidden group-data-[collapsible=icon]:hidden dark:block",
+  //           size === "sm" ? "max-h-4 max-w-14" : "max-h-5 max-w-16",
+  //         )}
+  //       />
+  //       <PlusIcon
+  //         size={size === "sm" ? 8 : 12}
+  //         className="group-data-[collapsible=icon]:hidden"
+  //       />
+  //       <LangfuseIcon size={size === "sm" ? 16 : 20} />
+  //     </div>
+  //   );
+  // }
 
   return (
     <div className="flex items-center">
diff --git a/web/src/components/layouts/layout.tsx b/web/src/components/layouts/layout.tsx
index d775708..6794396 100644
--- a/web/src/components/layouts/layout.tsx
+++ b/web/src/components/layouts/layout.tsx
@@ -11,7 +11,7 @@ import DOMPurify from "dompurify";
 import { ThemeToggle } from "@/src/features/theming/ThemeToggle";
 import { useQueryProjectOrOrganization } from "@/src/features/projects/hooks";
 import { useEntitlements } from "@/src/features/entitlements/hooks";
-import { useUiCustomization } from "@/src/ee/features/ui-customization/useUiCustomization";
+// import { useUiCustomization } from "@/src/ee/features/ui-customization/useUiCustomization";
 import { hasOrganizationAccess } from "@/src/features/rbac/utils/checkOrganizationAccess";
 import { SidebarInset, SidebarProvider } from "@/src/components/ui/sidebar";
 import { AppSidebar } from "@/src/components/nav/app-sidebar";
@@ -106,7 +106,7 @@ export default function Layout(props: PropsWithChildren) {
 
   const entitlements = useEntitlements();
 
-  const uiCustomization = useUiCustomization();
+  // const uiCustomization = useUiCustomization();
 
   const cloudAdmin =
     env.NEXT_PUBLIC_LANGFUSE_CLOUD_REGION !== undefined &&
@@ -177,9 +177,10 @@ export default function Layout(props: PropsWithChildren) {
       route.items?.map((item) => mapNavigation(item)).filter(Boolean) ?? [];
 
     const url = (
-      route.customizableHref
-        ? (uiCustomization?.[route.customizableHref] ?? route.pathname)
-        : route.pathname
+      // route.customizableHref
+      //   ? (uiCustomization?.[route.customizableHref] ?? route.pathname)
+        // :
+      route.pathname
     )
       ?.replace("[projectId]", routerProjectId ?? "")
       .replace("[organizationId]", routerOrganizationId ?? "");
diff --git a/web/src/components/layouts/routes.tsx b/web/src/components/layouts/routes.tsx
index 292554c..c8d69de 100644
--- a/web/src/components/layouts/routes.tsx
+++ b/web/src/components/layouts/routes.tsx
@@ -18,7 +18,7 @@ import {
 } from "lucide-react";
 import { type ReactNode } from "react";
 import { type Entitlement } from "@/src/features/entitlements/constants/entitlements";
-import { type UiCustomizationOption } from "@/src/ee/features/ui-customization/useUiCustomization";
+// import { type UiCustomizationOption } from "@/src/ee/features/ui-customization/useUiCustomization";
 import { type User } from "next-auth";
 import { type OrganizationScope } from "@/src/features/rbac/constants/organizationAccessRights";
 import { SupportMenuDropdown } from "@/src/components/nav/support-menu-dropdown";
@@ -40,7 +40,7 @@ export type Route = {
   bottom?: boolean; // bottom of the sidebar, only for first level routes
   newTab?: boolean; // open in new tab
   entitlements?: Entitlement[]; // entitlements required, array treated as OR
-  customizableHref?: UiCustomizationOption; // key of useUiCustomization object to use to replace the href
+  // customizableHref?: UiCustomizationOption; // key of useUiCustomization object to use to replace the href
   show?: (p: {
     organization: User["organizations"][number] | undefined;
   }) => boolean;
diff --git a/web/src/components/nav/app-sidebar.tsx b/web/src/components/nav/app-sidebar.tsx
index 38f6cd4..af28cfd 100644
--- a/web/src/components/nav/app-sidebar.tsx
+++ b/web/src/components/nav/app-sidebar.tsx
@@ -19,7 +19,7 @@ import Link from "next/link";
 import { Alert, AlertDescription } from "@/src/components/ui/alert";
 import { LangfuseLogo } from "@/src/components/LangfuseLogo";
 import { SidebarNotifications } from "@/src/components/nav/sidebar-notifications";
-import { UsageTracker } from "@/src/ee/features/billing/components/UsageTracker";
+// import { UsageTracker } from "@/src/ee/features/billing/components/UsageTracker";
 
 type AppSidebarProps = {
   navItems: NavMainItem[];
@@ -46,7 +46,7 @@ export function AppSidebar({
         <NavMain items={navItems} />
         <div className="flex-1" />
         <div className="flex flex-col gap-2 p-2">
-          <UsageTracker />
+          {/* <UsageTracker /> */}
           <SidebarNotifications />
         </div>
         <NavMain items={secondaryNavItems} />
diff --git a/web/src/components/nav/support-menu-dropdown.tsx b/web/src/components/nav/support-menu-dropdown.tsx
index 3ab703d..6d3e8b8 100644
--- a/web/src/components/nav/support-menu-dropdown.tsx
+++ b/web/src/components/nav/support-menu-dropdown.tsx
@@ -19,10 +19,10 @@ import {
   type LucideIcon,
 } from "lucide-react";
 import { useMemo, type ReactNode } from "react";
-import {
-  type UiCustomizationOption,
-  useUiCustomization,
-} from "@/src/ee/features/ui-customization/useUiCustomization";
+// import {
+//   type UiCustomizationOption,
+//   useUiCustomization,
+// } from "@/src/ee/features/ui-customization/useUiCustomization";
 import { SidebarMenuButton, useSidebar } from "@/src/components/ui/sidebar";
 import {
   chatAvailable,
@@ -39,11 +39,11 @@ type SupportMenuItem = {
   pathname: string;
   icon: LucideIcon | React.ElementType;
   menuNode?: ReactNode;
-  customizableHref?: UiCustomizationOption;
+  // customizableHref?: UiCustomizationOption;
 };
 
 export const SupportMenuDropdown = () => {
-  const uiCustomization = useUiCustomization();
+  // const uiCustomization = useUiCustomization();
 
   const supportMenuItems: (SupportMenuItem | "separator")[] = useMemo(() => {
     const items: (SupportMenuItem | "separator")[] = [
@@ -55,12 +55,13 @@ export const SupportMenuDropdown = () => {
     ];
 
     const chatVisible = chatIsVisible();
-    if (uiCustomization?.supportHref) {
-      items.push({
-        title: "Support",
-        pathname: uiCustomization.supportHref,
-        icon: LifeBuoy,
-      });
+    // if (uiCustomization?.supportHref) {
+    if (false) {
+      // items.push({
+      //   title: "Support",
+      //   pathname: uiCustomization.supportHref,
+      //   icon: LifeBuoy,
+      // });
     } else {
       if (chatAvailable) {
         items.push({
@@ -105,7 +106,7 @@ export const SupportMenuDropdown = () => {
       title: "Docs",
       pathname: "https://langfuse.com/docs",
       icon: LibraryBig,
-      customizableHref: "documentationHref",
+      // customizableHref: "documentationHref",
     });
     if (env.NEXT_PUBLIC_LANGFUSE_CLOUD_REGION) {
       items.push({
@@ -116,31 +117,31 @@ export const SupportMenuDropdown = () => {
     }
     items.push("separator");
 
-    if (uiCustomization?.feedbackHref) {
-      items.push({
-        title: "Feedback",
-        pathname: uiCustomization.feedbackHref,
-        icon: MessageSquarePlus,
-      });
-    } else {
-      items.push(
-        ...[
-          {
-            title: "Feature Request",
-            pathname: "https://langfuse.com/ideas",
-            icon: Lightbulb,
-          },
-          {
-            title: "Report a Bug",
-            pathname: "https://langfuse.com/issues",
-            icon: Bug,
-          },
-        ],
-      );
-    }
+    // if (uiCustomization?.feedbackHref) {
+    //   items.push({
+    //     title: "Feedback",
+    //     pathname: uiCustomization.feedbackHref,
+    //     icon: MessageSquarePlus,
+    //   });
+    // } else {
+    items.push(
+      ...[
+        {
+          title: "Feature Request",
+          pathname: "https://langfuse.com/ideas",
+          icon: Lightbulb,
+        },
+        {
+          title: "Report a Bug",
+          pathname: "https://langfuse.com/issues",
+          icon: Bug,
+        },
+      ],
+    );
+    // }
 
     return items;
-  }, [uiCustomization]);
+  }, [/*uiCustomization*/]);
 
   const { isMobile } = useSidebar();
 
diff --git a/web/src/components/onboarding/AnnotationQueuesOnboarding.tsx b/web/src/components/onboarding/AnnotationQueuesOnboarding.tsx
index 4c20641..f69c47f 100644
--- a/web/src/components/onboarding/AnnotationQueuesOnboarding.tsx
+++ b/web/src/components/onboarding/AnnotationQueuesOnboarding.tsx
@@ -4,7 +4,7 @@ import {
   type ValueProposition,
 } from "@/src/components/ui/splash-screen";
 import { ClipboardCheck, Users, BarChart4, GitMerge } from "lucide-react";
-import { CreateOrEditAnnotationQueueButton } from "@/src/ee/features/annotation-queues/components/CreateOrEditAnnotationQueueButton";
+// import { CreateOrEditAnnotationQueueButton } from "@/src/ee/features/annotation-queues/components/CreateOrEditAnnotationQueueButton";
 
 export function AnnotationQueuesOnboarding({
   projectId,
@@ -46,11 +46,12 @@ export function AnnotationQueuesOnboarding({
       primaryAction={{
         label: "Create Annotation Queue",
         component: (
-          <CreateOrEditAnnotationQueueButton
-            variant="default"
-            projectId={projectId}
-            size="lg"
-          />
+          // <CreateOrEditAnnotationQueueButton
+          //   variant="default"
+          //   projectId={projectId}
+          //   size="lg"
+          // />
+          <></>
         ),
       }}
       secondaryAction={{
diff --git a/web/src/components/trace/ObservationPreview.tsx b/web/src/components/trace/ObservationPreview.tsx
index 1efaaea..d927d34 100644
--- a/web/src/components/trace/ObservationPreview.tsx
+++ b/web/src/components/trace/ObservationPreview.tsx
@@ -9,13 +9,13 @@ import Link from "next/link";
 import { usdFormatter } from "@/src/utils/numbers";
 import { withDefault, StringParam, useQueryParam } from "use-query-params";
 import ScoresTable from "@/src/components/table/use-cases/scores";
-import { JumpToPlaygroundButton } from "@/src/ee/features/playground/page/components/JumpToPlaygroundButton";
+// import { JumpToPlaygroundButton } from "@/src/ee/features/playground/page/components/JumpToPlaygroundButton";
 import { AnnotateDrawer } from "@/src/features/scores/components/AnnotateDrawer";
 import useLocalStorage from "@/src/components/useLocalStorage";
 import { CommentDrawerButton } from "@/src/features/comments/CommentDrawerButton";
 import { cn } from "@/src/utils/tailwind";
 import { NewDatasetItemFromExistingObject } from "@/src/features/datasets/components/NewDatasetItemFromExistingObject";
-import { CreateNewAnnotationQueueItem } from "@/src/ee/features/annotation-queues/components/CreateNewAnnotationQueueItem";
+// import { CreateNewAnnotationQueueItem } from "@/src/ee/features/annotation-queues/components/CreateNewAnnotationQueueItem";
 import { useHasEntitlement } from "@/src/features/entitlements/hooks";
 import { calculateDisplayTotalCost } from "@/src/components/trace/lib/helpers";
 import { Fragment, useMemo, useState } from "react";
@@ -156,22 +156,22 @@ export const ObservationPreview = ({
                     type="observation"
                     hasGroupedButton={hasEntitlement}
                   />
-                  {hasEntitlement && (
+                  {/* {hasEntitlement && (
                     <CreateNewAnnotationQueueItem
                       projectId={projectId}
                       objectId={preloadedObservation.id}
                       objectType={AnnotationQueueObjectType.OBSERVATION}
                     />
-                  )}
+                  )} */}
                 </div>
-                {observationWithInputAndOutput.data?.type === "GENERATION" && (
+                {/* {observationWithInputAndOutput.data?.type === "GENERATION" && (
                   <JumpToPlaygroundButton
                     source="generation"
                     generation={observationWithInputAndOutput.data}
                     analyticsEventName="trace_detail:test_in_playground_button_click"
                     className={cn(isTimeline ? "!hidden" : "")}
                   />
-                )}
+                )} */}
                 <CommentDrawerButton
                   projectId={preloadedObservation.projectId}
                   objectId={preloadedObservation.id}
diff --git a/web/src/components/trace/TracePreview.tsx b/web/src/components/trace/TracePreview.tsx
index 8201494..82283dc 100644
--- a/web/src/components/trace/TracePreview.tsx
+++ b/web/src/components/trace/TracePreview.tsx
@@ -2,7 +2,7 @@ import { JSONView } from "@/src/components/ui/CodeJsonViewer";
 import {
   type APIScore,
   type TraceDomain,
-  AnnotationQueueObjectType,
+  // AnnotationQueueObjectType,
 } from "@langfuse/shared";
 import { AggUsageBadge } from "@/src/components/token-usage-badge";
 import { Badge } from "@/src/components/ui/badge";
@@ -16,7 +16,7 @@ import useLocalStorage from "@/src/components/useLocalStorage";
 import { CommentDrawerButton } from "@/src/features/comments/CommentDrawerButton";
 import { api } from "@/src/utils/api";
 import { NewDatasetItemFromExistingObject } from "@/src/features/datasets/components/NewDatasetItemFromExistingObject";
-import { CreateNewAnnotationQueueItem } from "@/src/ee/features/annotation-queues/components/CreateNewAnnotationQueueItem";
+// import { CreateNewAnnotationQueueItem } from "@/src/ee/features/annotation-queues/components/CreateNewAnnotationQueueItem";
 import { useHasEntitlement } from "@/src/features/entitlements/hooks";
 import { useMemo, useState } from "react";
 import { usdFormatter } from "@/src/utils/numbers";
@@ -135,13 +135,13 @@ export const TracePreview = ({
                     setEmptySelectedConfigIds={setEmptySelectedConfigIds}
                     hasGroupedButton={hasEntitlement}
                   />
-                  {hasEntitlement && (
+                  {/* {hasEntitlement && (
                     <CreateNewAnnotationQueueItem
                       projectId={trace.projectId}
                       objectId={trace.id}
                       objectType={AnnotationQueueObjectType.TRACE}
                     />
-                  )}
+                  )} */}
                 </div>
                 <CommentDrawerButton
                   projectId={trace.projectId}
diff --git a/web/src/ee/README.md b/web/src/ee/README.md
deleted file mode 100644
index 23844a6..0000000
--- a/web/src/ee/README.md
+++ /dev/null
@@ -1,5 +0,0 @@
-# Enterprise Edition
-
-This folder includes features that are only available in the Enterprise Edition of Langfuse and on Langfuse Cloud.
-
-See [LICENSE](../../../LICENSE) and [docs](https://langfuse.com/docs/open-source) for more details.
diff --git a/web/src/ee/features/annotation-queues/components/AnnotationQueueItemPage.tsx b/web/src/ee/features/annotation-queues/components/AnnotationQueueItemPage.tsx
deleted file mode 100644
index ca1f84f..0000000
--- a/web/src/ee/features/annotation-queues/components/AnnotationQueueItemPage.tsx
+++ /dev/null
@@ -1,460 +0,0 @@
-import { Trace } from "@/src/components/trace";
-import { ObservationPreview } from "@/src/components/trace/ObservationPreview";
-import { TracePreview } from "@/src/components/trace/TracePreview";
-import {
-  Accordion,
-  AccordionContent,
-  AccordionItem,
-  AccordionTrigger,
-} from "@/src/components/ui/accordion";
-import { Button } from "@/src/components/ui/button";
-import { Card } from "@/src/components/ui/card";
-import {
-  ResizableHandle,
-  ResizablePanel,
-  ResizablePanelGroup,
-} from "@/src/components/ui/resizable";
-import { Skeleton } from "@/src/components/ui/skeleton";
-import useSessionStorage from "@/src/components/useSessionStorage";
-import { CommentList } from "@/src/features/comments/CommentList";
-import { showSuccessToast } from "@/src/features/notifications/showSuccessToast";
-import { useHasProjectAccess } from "@/src/features/rbac/utils/checkProjectAccess";
-import { AnnotateDrawerContent } from "@/src/features/scores/components/AnnotateDrawerContent";
-import { api } from "@/src/utils/api";
-import { type RouterOutput } from "@/src/utils/types";
-import {
-  type AnnotationQueueItem,
-  AnnotationQueueObjectType,
-  AnnotationQueueStatus,
-  isPresent,
-  type ValidatedScoreConfig,
-} from "@langfuse/shared";
-import {
-  ArrowLeft,
-  ArrowRight,
-  SearchXIcon,
-  TriangleAlertIcon,
-} from "lucide-react";
-import { useSession } from "next-auth/react";
-import { useRouter } from "next/router";
-import { useEffect, useMemo, useState } from "react";
-import { StringParam, useQueryParam } from "use-query-params";
-
-const AnnotateIOView = ({
-  item,
-  configs,
-  view,
-}: {
-  item: AnnotationQueueItem & {
-    parentTraceId?: string | null;
-    lockedByUser: { name: string | null | undefined } | null;
-  };
-  configs: ValidatedScoreConfig[];
-  view: "showTree" | "hideTree";
-}) => {
-  const router = useRouter();
-  const session = useSession();
-  const traceId = item.parentTraceId ?? item.objectId;
-  const projectId = router.query.projectId as string;
-  const [showSaving, setShowSaving] = useState(false);
-  const [showComments, setShowComments] = useSessionStorage(
-    `annotationQueueShowComments-${projectId}`,
-    false,
-  );
-  const [panelSize, setPanelSize] = useSessionStorage(
-    `annotationQueuePanelSize-${projectId}`,
-    65,
-  );
-
-  const [currentObservationId, setCurrentObservationId] = useQueryParam(
-    "observation",
-    StringParam,
-  );
-  useEffect(() => {
-    if (
-      view === "showTree" &&
-      item.objectType === AnnotationQueueObjectType.OBSERVATION
-    ) {
-      setCurrentObservationId(item.objectId);
-    } else setCurrentObservationId(undefined);
-  }, [view, item, setCurrentObservationId]);
-
-  const isLockedByOtherUser = item.lockedByUserId !== session.data?.user?.id;
-
-  const trace = api.traces.byIdWithObservationsAndScores.useQuery(
-    { traceId, projectId },
-    {
-      retry(failureCount, error) {
-        if (error.data?.code === "UNAUTHORIZED") return false;
-        return failureCount < 3;
-      },
-    },
-  );
-
-  const emptySelectedConfigIds = useMemo(() => {
-    return configs.map((c) => c.id);
-  }, [configs]);
-
-  if (trace.isLoading || !trace.data)
-    return <div className="p-3">Loading...</div>;
-
-  let isValidObservationId = false;
-
-  if (
-    currentObservationId &&
-    trace.data.observations.some(({ id }) => id === currentObservationId)
-  ) {
-    isValidObservationId = true;
-  }
-
-  return (
-    <ResizablePanelGroup
-      direction="horizontal"
-      className="h-full overflow-hidden"
-      onLayout={(sizes) => {
-        setPanelSize(sizes[0]);
-      }}
-    >
-      <ResizablePanel
-        className="col-span-1 h-full !overflow-y-auto rounded-md border"
-        minSize={30}
-        defaultSize={panelSize}
-      >
-        {view === "hideTree" ? (
-          <div className="max-h-full min-h-0 overflow-y-auto pl-4">
-            {item.objectType === AnnotationQueueObjectType.TRACE ? (
-              <TracePreview
-                key={trace.data.id}
-                trace={trace.data}
-                scores={trace.data.scores}
-                observations={trace.data.observations}
-                viewType="focused"
-              />
-            ) : (
-              <ObservationPreview
-                observations={trace.data.observations}
-                scores={trace.data.scores}
-                projectId={item.projectId}
-                currentObservationId={item.objectId}
-                traceId={traceId}
-                viewType="focused"
-              />
-            )}
-          </div>
-        ) : (
-          <div className="max-h-full min-h-0 overflow-y-auto">
-            <Trace
-              key={trace.data.id}
-              trace={trace.data}
-              scores={trace.data.scores}
-              projectId={trace.data.projectId}
-              observations={trace.data.observations}
-              viewType="focused"
-              isValidObservationId={isValidObservationId}
-            />
-          </div>
-        )}
-      </ResizablePanel>
-      <ResizableHandle withHandle className="ml-4 bg-transparent" />
-      <ResizablePanel
-        className="col-span-1 h-full md:flex md:flex-col md:overflow-hidden"
-        minSize={30}
-      >
-        <Card className="col-span-2 flex h-full flex-col overflow-hidden">
-          <div className="grid h-full w-full grid-cols-1 grid-rows-[minmax(auto,1fr),minmax(min-content,auto)] justify-between">
-            <div className="w-full overflow-auto">
-              <AnnotateDrawerContent
-                key={"annotation-drawer-content" + item.objectId}
-                traceId={traceId}
-                scores={trace.data?.scores ?? []}
-                observationId={item.parentTraceId ? item.objectId : undefined}
-                configs={configs}
-                emptySelectedConfigIds={emptySelectedConfigIds}
-                setEmptySelectedConfigIds={() => {}}
-                projectId={item.projectId}
-                type={item.objectType.toLowerCase() as "trace" | "observation"}
-                isSelectHidden
-                queueId={item.queueId}
-                showSaving={showSaving}
-                setShowSaving={setShowSaving}
-                actionButtons={
-                  isLockedByOtherUser && isPresent(item.lockedByUser?.name) ? (
-                    <div className="flex items-center justify-center rounded-sm border border-dark-red bg-light-red p-1">
-                      <TriangleAlertIcon className="mr-1 h-4 w-4 text-dark-red" />
-                      <span className="text-xs text-dark-red">
-                        Currently edited by {item.lockedByUser.name}
-                      </span>
-                    </div>
-                  ) : undefined
-                }
-              />
-            </div>
-            <div className="relative max-h-64 overflow-auto">
-              <Accordion
-                type="single"
-                collapsible
-                className="mx-4 mt-4"
-                value={showComments ? "item-1" : ""}
-                onValueChange={(value) => setShowComments(value === "item-1")}
-              >
-                <AccordionItem value="item-1" className="border-none">
-                  <div className="sticky top-0 z-10 border-b bg-background">
-                    <AccordionTrigger
-                      onClick={() => setShowComments(!showComments)}
-                    >
-                      Comments
-                    </AccordionTrigger>
-                  </div>
-                  <AccordionContent>
-                    <CommentList
-                      projectId={item.projectId}
-                      objectId={item.objectId}
-                      objectType={item.objectType}
-                      className="rounded-t-none border-t-transparent"
-                      cardView
-                    />
-                  </AccordionContent>
-                </AccordionItem>
-              </Accordion>
-            </div>
-          </div>
-        </Card>
-      </ResizablePanel>
-    </ResizablePanelGroup>
-  );
-};
-
-export const AnnotationQueueItemPage: React.FC<{
-  annotationQueueId: string;
-  projectId: string;
-  view: "showTree" | "hideTree";
-  queryItemId?: string;
-}> = ({ annotationQueueId, projectId, view, queryItemId }) => {
-  const router = useRouter();
-  const isSingleItem = router.query.singleItem === "true";
-  const [nextItemData, setNextItemData] = useState<
-    RouterOutput["annotationQueues"]["fetchAndLockNext"] | null
-  >(null);
-  const [seenItemIds, setSeenItemIds] = useState<string[]>([]);
-  const [progressIndex, setProgressIndex] = useState(0);
-
-  const hasAccess = useHasProjectAccess({
-    projectId,
-    scope: "annotationQueues:CUD",
-  });
-  const itemId = isSingleItem ? queryItemId : seenItemIds[progressIndex];
-
-  const seenItemData = api.annotationQueueItems.byId.useQuery(
-    { projectId, itemId: itemId as string },
-    { enabled: !!itemId, refetchOnMount: false },
-  );
-
-  const fetchAndLockNextMutation =
-    api.annotationQueues.fetchAndLockNext.useMutation();
-
-  useEffect(() => {
-    async function fetchNextItem() {
-      if (!itemId && !isSingleItem) {
-        const nextItem = await fetchAndLockNextMutation.mutateAsync({
-          queueId: annotationQueueId,
-          projectId,
-          seenItemIds,
-        });
-        setNextItemData(nextItem);
-      }
-    }
-    fetchNextItem();
-    // eslint-disable-next-line react-hooks/exhaustive-deps
-  }, []);
-
-  const queueData = api.annotationQueues.byId.useQuery(
-    {
-      queueId: annotationQueueId,
-      projectId,
-    },
-    {
-      refetchOnMount: false,
-      refetchOnWindowFocus: false,
-      refetchOnReconnect: false,
-    },
-  );
-
-  const unseenPendingItemCount =
-    api.annotationQueueItems.unseenPendingItemCountByQueueId.useQuery(
-      {
-        queueId: annotationQueueId,
-        projectId,
-        seenItemIds,
-      },
-      { refetchOnWindowFocus: false },
-    );
-
-  const utils = api.useUtils();
-  const completeMutation = api.annotationQueueItems.complete.useMutation({
-    onSuccess: async () => {
-      utils.annotationQueueItems.invalidate();
-      showSuccessToast({
-        title: "Item marked as complete",
-        description: "The item is successfully marked as complete.",
-      });
-      if (isSingleItem) {
-        return;
-      }
-
-      if (progressIndex >= seenItemIds.length - 1) {
-        const nextItem = await fetchAndLockNextMutation.mutateAsync({
-          queueId: annotationQueueId,
-          projectId,
-          seenItemIds,
-        });
-        setNextItemData(nextItem);
-      }
-
-      if (progressIndex + 1 < totalItems) {
-        setProgressIndex(Math.max(progressIndex + 1, 0));
-      }
-    },
-  });
-
-  const totalItems = useMemo(() => {
-    return seenItemIds.length + (unseenPendingItemCount.data ?? 0);
-  }, [unseenPendingItemCount.data, seenItemIds.length]);
-
-  const configs = queueData.data?.scoreConfigs ?? [];
-
-  const relevantItem = useMemo(() => {
-    if (isSingleItem) return seenItemData.data;
-    else
-      return progressIndex < seenItemIds.length
-        ? seenItemData.data
-        : nextItemData;
-  }, [
-    progressIndex,
-    seenItemIds.length,
-    seenItemData.data,
-    nextItemData,
-    isSingleItem,
-  ]);
-
-  useEffect(() => {
-    if (relevantItem && router.query.itemId !== relevantItem.id) {
-      router.push(
-        {
-          pathname: `/project/${projectId}/annotation-queues/${annotationQueueId}/items/${relevantItem.id}`,
-        },
-        undefined,
-      );
-    }
-  }, [relevantItem, router, projectId, annotationQueueId]);
-
-  useEffect(() => {
-    if (
-      relevantItem &&
-      !seenItemIds.includes(relevantItem.id) &&
-      !isSingleItem
-    ) {
-      setSeenItemIds((prev) => [...prev, relevantItem.id]);
-    }
-    // eslint-disable-next-line react-hooks/exhaustive-deps
-  }, [relevantItem]);
-
-  if (
-    (seenItemData.isLoading && itemId) ||
-    (fetchAndLockNextMutation.isLoading && !itemId) ||
-    unseenPendingItemCount.isLoading
-  ) {
-    return <Skeleton className="h-full w-full" />;
-  }
-
-  if (!relevantItem && !(itemId && seenItemIds.includes(itemId))) {
-    return <div>No more items left to annotate!</div>;
-  }
-
-  const isNextItemAvailable = totalItems > progressIndex + 1;
-
-  return (
-    <div className="grid h-full grid-rows-[1fr,auto] gap-4 overflow-hidden">
-      {relevantItem ? (
-        <AnnotateIOView item={relevantItem} configs={configs} view={view} />
-      ) : (
-        <Card className="flex h-full w-full flex-col items-center justify-center overflow-hidden">
-          <SearchXIcon className="mb-2 h-8 w-8 text-muted-foreground" />
-          <span className="max-w-96 text-wrap text-sm text-muted-foreground">
-            Item has been <strong>deleted from annotation queue</strong>.
-            Previously added scores and underlying reference trace are
-            unaffected by this action.
-          </span>
-        </Card>
-      )}
-      <div className="grid h-full w-full grid-cols-1 justify-end gap-2 sm:grid-cols-[auto,min-content]">
-        {!isSingleItem && (
-          <div className="flex max-h-10 flex-row gap-2">
-            <span className="grid h-9 min-w-16 items-center rounded-md bg-muted p-1 text-center text-sm">
-              {progressIndex + 1} / {totalItems}
-            </span>
-            <Button
-              onClick={() => {
-                setProgressIndex(progressIndex - 1);
-              }}
-              variant="outline"
-              disabled={progressIndex === 0 || !hasAccess}
-              size="lg"
-              className="px-4"
-            >
-              <ArrowLeft className="mr-1 h-4 w-4" />
-              Back
-            </Button>
-          </div>
-        )}
-        <div className="flex w-full min-w-[265px] justify-end gap-2">
-          {!isSingleItem && (
-            <Button
-              onClick={async () => {
-                if (progressIndex >= seenItemIds.length - 1) {
-                  const nextItem = await fetchAndLockNextMutation.mutateAsync({
-                    queueId: annotationQueueId,
-                    projectId,
-                    seenItemIds,
-                  });
-                  setNextItemData(nextItem);
-                }
-                setProgressIndex(Math.max(progressIndex + 1, 0));
-              }}
-              disabled={!isNextItemAvailable || !hasAccess} // Disable button during loading
-              size="lg"
-              className={`px-4 ${!relevantItem ? "w-full" : ""}`}
-              variant="outline"
-            >
-              {relevantItem?.status === AnnotationQueueStatus.PENDING
-                ? "Skip"
-                : "Next"}
-              <ArrowRight className="ml-1 h-4 w-4" />
-            </Button>
-          )}
-          {!!relevantItem &&
-            (relevantItem.status === AnnotationQueueStatus.PENDING ? (
-              <Button
-                onClick={async () => {
-                  await completeMutation.mutateAsync({
-                    itemId: relevantItem.id,
-                    projectId,
-                  });
-                }}
-                size="lg"
-                className="w-full"
-                disabled={completeMutation.isLoading || !hasAccess}
-              >
-                {isSingleItem || progressIndex + 1 === totalItems
-                  ? "Complete"
-                  : "Complete + Next"}
-              </Button>
-            ) : (
-              <div className="text-dark-gree inline-flex h-9 w-full items-center justify-center rounded-md border border-dark-green bg-light-green px-8 text-sm font-medium">
-                Completed
-              </div>
-            ))}
-        </div>
-      </div>
-    </div>
-  );
-};
diff --git a/web/src/ee/features/annotation-queues/components/AnnotationQueueItemsTable.tsx b/web/src/ee/features/annotation-queues/components/AnnotationQueueItemsTable.tsx
deleted file mode 100644
index 9783e74..0000000
--- a/web/src/ee/features/annotation-queues/components/AnnotationQueueItemsTable.tsx
+++ /dev/null
@@ -1,411 +0,0 @@
-import { DataTable } from "@/src/components/table/data-table";
-import TableLink from "@/src/components/table/table-link";
-import { type LangfuseColumnDef } from "@/src/components/table/types";
-import { api } from "@/src/utils/api";
-import { useQueryParams, withDefault, NumberParam } from "use-query-params";
-import { DataTableToolbar } from "@/src/components/table/data-table-toolbar";
-import useColumnVisibility from "@/src/features/column-visibility/hooks/useColumnVisibility";
-import { type AnnotationQueueStatus } from "@langfuse/shared";
-import { useRowHeightLocalStorage } from "@/src/components/table/data-table-row-height-switch";
-import { ChevronDown, ListTree, Trash } from "lucide-react";
-import useColumnOrder from "@/src/features/column-visibility/hooks/useColumnOrder";
-import {
-  Avatar,
-  AvatarFallback,
-  AvatarImage,
-} from "@/src/components/ui/avatar";
-import { type RouterOutput } from "@/src/utils/types";
-import { type RowSelectionState } from "@tanstack/react-table";
-import { useState } from "react";
-import {
-  DropdownMenu,
-  DropdownMenuTrigger,
-  DropdownMenuContent,
-  DropdownMenuItem,
-} from "@/src/components/ui/dropdown-menu";
-import { Button } from "@/src/components/ui/button";
-import {
-  Dialog,
-  DialogContent,
-  DialogDescription,
-  DialogFooter,
-  DialogHeader,
-  DialogTitle,
-} from "@/src/components/ui/dialog";
-import { Checkbox } from "@/src/components/ui/checkbox";
-import { useHasProjectAccess } from "@/src/features/rbac/utils/checkProjectAccess";
-import { StatusBadge } from "@/src/components/layouts/status-badge";
-
-const QueueItemTableMultiSelectAction = ({
-  selectedItemIds,
-  projectId,
-  onDeleteSuccess,
-}: {
-  selectedItemIds: string[];
-  projectId: string;
-  onDeleteSuccess: () => void;
-}) => {
-  const utils = api.useUtils();
-  const [open, setOpen] = useState(false);
-
-  const hasDeleteAccess = useHasProjectAccess({
-    projectId,
-    scope: "annotationQueues:CUD",
-  });
-  const mutDeleteItems = api.annotationQueueItems.deleteMany.useMutation({
-    onSuccess: () => {
-      onDeleteSuccess();
-      void utils.annotationQueueItems.itemsByQueueId.invalidate();
-    },
-  });
-
-  return (
-    <>
-      <DropdownMenu>
-        <DropdownMenuTrigger asChild>
-          <Button disabled={selectedItemIds.length < 1}>
-            Actions ({selectedItemIds.length} selected)
-            <ChevronDown className="h-5 w-5" />
-          </Button>
-        </DropdownMenuTrigger>
-        <DropdownMenuContent>
-          <DropdownMenuItem
-            disabled={!hasDeleteAccess}
-            onClick={() => {
-              setOpen(true);
-            }}
-          >
-            <Trash className="mr-2 h-4 w-4" />
-            <span>Delete</span>
-          </DropdownMenuItem>
-        </DropdownMenuContent>
-      </DropdownMenu>
-      <Dialog
-        open={open}
-        onOpenChange={(isOpen) => {
-          if (!isOpen) {
-            setOpen(false);
-          }
-        }}
-      >
-        <DialogContent className="sm:max-w-md">
-          <DialogHeader>
-            <DialogTitle>Delete queue items</DialogTitle>
-            <DialogDescription>
-              This action cannot be undone and removes the selected annotation
-              queue item(s), but
-              <strong> does not delete associated scores.</strong>
-            </DialogDescription>
-          </DialogHeader>
-          <DialogFooter className="sm:justify-start">
-            <Button
-              type="button"
-              variant="destructive"
-              loading={mutDeleteItems.isLoading}
-              disabled={mutDeleteItems.isLoading}
-              onClick={() => {
-                void mutDeleteItems
-                  .mutateAsync({
-                    itemIds: selectedItemIds,
-                    projectId,
-                  })
-                  .then(() => {
-                    setOpen(false);
-                  });
-              }}
-            >
-              Delete {selectedItemIds.length} item(s)
-            </Button>
-          </DialogFooter>
-        </DialogContent>
-      </Dialog>
-    </>
-  );
-};
-
-export type QueueItemRowData = {
-  id: string;
-  source: {
-    traceId: string;
-    observationId?: string;
-  };
-  status: AnnotationQueueStatus;
-  completedAt: string;
-  annotatorUser: {
-    userId?: string;
-    userName?: string;
-    image?: string;
-  };
-};
-
-export function AnnotationQueueItemsTable({
-  projectId,
-  queueId,
-}: {
-  projectId: string;
-  queueId: string;
-}) {
-  const [paginationState, setPaginationState] = useQueryParams({
-    pageIndex: withDefault(NumberParam, 0),
-    pageSize: withDefault(NumberParam, 50),
-  });
-  const [selectedRows, setSelectedRows] = useState<RowSelectionState>({});
-
-  const [rowHeight, setRowHeight] = useRowHeightLocalStorage("queueItems", "s");
-  const items = api.annotationQueueItems.itemsByQueueId.useQuery({
-    projectId,
-    queueId,
-    page: paginationState.pageIndex,
-    limit: paginationState.pageSize,
-  });
-
-  const columns: LangfuseColumnDef<QueueItemRowData>[] = [
-    {
-      id: "select",
-      accessorKey: "select",
-      size: 30,
-      isPinned: true,
-      header: ({ table }) => {
-        return (
-          <div className="flex h-full items-center">
-            <Checkbox
-              checked={
-                table.getIsAllPageRowsSelected()
-                  ? true
-                  : table.getIsSomePageRowsSelected()
-                    ? "indeterminate"
-                    : false
-              }
-              onCheckedChange={(value) => {
-                table.toggleAllPageRowsSelected(!!value);
-                if (!value) {
-                  setSelectedRows({});
-                }
-              }}
-              aria-label="Select all"
-              className="opacity-60"
-            />
-          </div>
-        );
-      },
-      cell: ({ row }) => {
-        return (
-          <Checkbox
-            checked={row.getIsSelected()}
-            onCheckedChange={(value) => row.toggleSelected(!!value)}
-            aria-label="Select row"
-            className="mt-1 opacity-60 data-[state=checked]:mt-[5px]"
-          />
-        );
-      },
-    },
-    {
-      accessorKey: "id",
-      header: "Id",
-      id: "id",
-      size: 70,
-      isPinned: true,
-      cell: ({ row }) => {
-        const id: QueueItemRowData["id"] = row.getValue("id");
-        return (
-          <TableLink
-            path={`/project/${projectId}/annotation-queues/${queueId}/items/${id}?singleItem=true`}
-            value={id}
-          />
-        );
-      },
-    },
-    {
-      accessorKey: "source",
-      header: "Source",
-      headerTooltip: {
-        description:
-          "Link to the source trace based on which this item was added",
-      },
-      id: "source",
-      size: 50,
-      cell: ({ row }) => {
-        const source: QueueItemRowData["source"] = row.getValue("source");
-        if (!source) return null;
-
-        if (!!source.observationId) {
-          return (
-            <TableLink
-              path={`/project/${projectId}/traces/${source.traceId}?observation=${source.observationId}`}
-              value={source.observationId}
-              icon={<ListTree className="h-4 w-4" />}
-            />
-          );
-        } else {
-          return (
-            <TableLink
-              path={`/project/${projectId}/traces/${source.traceId}`}
-              value={source.traceId}
-              icon={<ListTree className="h-4 w-4" />}
-            />
-          );
-        }
-      },
-    },
-    {
-      accessorKey: "status",
-      header: "Status",
-      id: "status",
-      size: 60,
-      cell: ({ row }) => {
-        const status: QueueItemRowData["status"] = row.getValue("status");
-        return (
-          <StatusBadge
-            className="capitalize"
-            type={status.toLowerCase()}
-            isLive={false}
-          />
-        );
-      },
-    },
-    {
-      accessorKey: "completedAt",
-      header: "Completed At",
-      id: "completedAt",
-      defaultHidden: true,
-      enableHiding: true,
-      size: 60,
-    },
-    {
-      accessorKey: "annotatorUser",
-      header: "Completed by",
-      id: "annotatorUser",
-      enableHiding: true,
-      size: 80,
-      cell: ({ row }) => {
-        const annotatorUser: QueueItemRowData["annotatorUser"] =
-          row.getValue("annotatorUser");
-        if (!annotatorUser || !annotatorUser.userId) return null;
-
-        const { userId, userName, image } = annotatorUser;
-        return (
-          <div className="flex items-center space-x-2">
-            <Avatar className="h-7 w-7">
-              <AvatarImage
-                src={image ?? undefined}
-                alt={userName ?? "User Avatar"}
-              />
-              <AvatarFallback>
-                {userName
-                  ? userName
-                      .split(" ")
-                      .map((word) => word[0])
-                      .slice(0, 2)
-                      .concat("")
-                  : null}
-              </AvatarFallback>
-            </Avatar>
-            <span>{userName ?? userId}</span>
-          </div>
-        );
-      },
-    },
-  ];
-
-  const convertToTableRow = (
-    item: RouterOutput["annotationQueueItems"]["itemsByQueueId"]["queueItems"][number],
-  ): QueueItemRowData => {
-    return {
-      id: item.id,
-      completedAt: item.completedAt?.toLocaleString() ?? "",
-      status: item.status,
-      source:
-        item.objectType === "OBSERVATION"
-          ? {
-              traceId: item.parentTraceId ?? "",
-              observationId: item.objectId,
-            }
-          : {
-              traceId: item.objectId,
-            },
-      annotatorUser: {
-        userId: item.annotatorUserId ?? undefined,
-        userName: item.annotatorUserName ?? undefined,
-        image: item.annotatorUserImage ?? undefined,
-      },
-    };
-  };
-
-  const [columnVisibility, setColumnVisibility] =
-    useColumnVisibility<QueueItemRowData>(
-      `queueItemsColumnVisibility-${projectId}`,
-      columns,
-    );
-
-  const [columnOrder, setColumnOrder] = useColumnOrder<QueueItemRowData>(
-    "queueItemsColumnOrder",
-    columns,
-  );
-
-  return (
-    <>
-      <DataTableToolbar
-        columns={columns}
-        columnVisibility={columnVisibility}
-        setColumnVisibility={setColumnVisibility}
-        columnOrder={columnOrder}
-        setColumnOrder={setColumnOrder}
-        rowHeight={rowHeight}
-        setRowHeight={setRowHeight}
-        actionButtons={[
-          Object.keys(selectedRows).filter((itemId) =>
-            items.data?.queueItems.map((item) => item.id).includes(itemId),
-          ).length > 0 ? (
-            <QueueItemTableMultiSelectAction
-              // Exclude items that are not in the current page
-              selectedItemIds={Object.keys(selectedRows).filter((itemId) =>
-                items.data?.queueItems.map((item) => item.id).includes(itemId),
-              )}
-              projectId={projectId}
-              onDeleteSuccess={() => {
-                setSelectedRows({});
-              }}
-            />
-          ) : null,
-        ]}
-      />
-      <DataTable
-        columns={columns}
-        data={
-          items.isLoading
-            ? { isLoading: true, isError: false }
-            : items.isError
-              ? {
-                  isLoading: false,
-                  isError: true,
-                  error: items.error.message,
-                }
-              : {
-                  isLoading: false,
-                  isError: false,
-                  data: items.data.queueItems.map((item) =>
-                    convertToTableRow(item),
-                  ),
-                }
-        }
-        help={{
-          description:
-            "Add traces and/or observations to your annotation queue to have them annotated by your team across predefined dimensions.",
-          href: "https://langfuse.com/docs/scores/model-based-evals",
-        }}
-        pagination={{
-          totalCount: items.data?.totalItems ?? null,
-          onChange: setPaginationState,
-          state: paginationState,
-        }}
-        rowSelection={selectedRows}
-        setRowSelection={setSelectedRows}
-        columnVisibility={columnVisibility}
-        onColumnVisibilityChange={setColumnVisibility}
-        columnOrder={columnOrder}
-        onColumnOrderChange={setColumnOrder}
-        rowHeight={rowHeight}
-      />
-    </>
-  );
-}
diff --git a/web/src/ee/features/annotation-queues/components/AnnotationQueuesItem.tsx b/web/src/ee/features/annotation-queues/components/AnnotationQueuesItem.tsx
deleted file mode 100644
index 8e3f1f6..0000000
--- a/web/src/ee/features/annotation-queues/components/AnnotationQueuesItem.tsx
+++ /dev/null
@@ -1,93 +0,0 @@
-import { Tabs, TabsList, TabsTrigger } from "@/src/components/ui/tabs";
-import useSessionStorage from "@/src/components/useSessionStorage";
-import { SupportOrUpgradePage } from "@/src/ee/features/billing/components/SupportOrUpgradePage";
-import { useHasEntitlement } from "@/src/features/entitlements/hooks";
-import { useHasProjectAccess } from "@/src/features/rbac/utils/checkProjectAccess";
-import { AnnotationQueueItemPage } from "@/src/ee/features/annotation-queues/components/AnnotationQueueItemPage";
-import { api } from "@/src/utils/api";
-import { Goal, Network } from "lucide-react";
-import Page from "@/src/components/layouts/page";
-
-export const AnnotationQueuesItem = ({
-  annotationQueueId,
-  projectId,
-  itemId,
-}: {
-  annotationQueueId: string;
-  projectId: string;
-  itemId?: string;
-}) => {
-  const hasAccess = useHasProjectAccess({
-    projectId,
-    scope: "annotationQueues:read",
-  });
-  const hasEntitlement = useHasEntitlement("annotation-queues");
-
-  const queue = api.annotationQueues.byId.useQuery(
-    {
-      queueId: annotationQueueId,
-      projectId,
-    },
-    {
-      trpc: {
-        context: {
-          skipBatch: true,
-        },
-      },
-      refetchOnMount: false, // prevents refetching loops
-    },
-  );
-
-  const [view, setView] = useSessionStorage<"hideTree" | "showTree">(
-    `annotationQueueView-${projectId}`,
-    "hideTree",
-  );
-
-  if (!hasAccess || !hasEntitlement) return <SupportOrUpgradePage />;
-
-  return (
-    <Page
-      withPadding
-      headerProps={{
-        title: `${queue.data?.name}: ${itemId}`,
-        itemType: "QUEUE_ITEM",
-        breadcrumb: [
-          {
-            name: "Annotation Queues",
-            href: `/project/${projectId}/annotation-queues`,
-          },
-          {
-            name: queue.data?.name ?? annotationQueueId,
-            href: `/project/${projectId}/annotation-queues/${annotationQueueId}`,
-          },
-        ],
-        actionButtonsRight: (
-          <Tabs
-            value={view}
-            onValueChange={(view: string) => {
-              setView(view as "hideTree" | "showTree");
-            }}
-          >
-            <TabsList>
-              <TabsTrigger value="hideTree">
-                <Goal className="mr-1 h-4 w-4"></Goal>
-                Focused
-              </TabsTrigger>
-              <TabsTrigger value="showTree">
-                <Network className="mr-1 h-4 w-4"></Network>
-                Detailed
-              </TabsTrigger>
-            </TabsList>
-          </Tabs>
-        ),
-      }}
-    >
-      <AnnotationQueueItemPage
-        projectId={projectId}
-        annotationQueueId={annotationQueueId}
-        view={view}
-        queryItemId={itemId}
-      />
-    </Page>
-  );
-};
diff --git a/web/src/ee/features/annotation-queues/components/AnnotationQueuesTable.tsx b/web/src/ee/features/annotation-queues/components/AnnotationQueuesTable.tsx
deleted file mode 100644
index 5e9267a..0000000
--- a/web/src/ee/features/annotation-queues/components/AnnotationQueuesTable.tsx
+++ /dev/null
@@ -1,270 +0,0 @@
-import { DataTable } from "@/src/components/table/data-table";
-import { type LangfuseColumnDef } from "@/src/components/table/types";
-import { api } from "@/src/utils/api";
-import { useQueryParams, withDefault, NumberParam } from "use-query-params";
-import { type RouterOutput } from "@/src/utils/types";
-import useColumnVisibility from "@/src/features/column-visibility/hooks/useColumnVisibility";
-import { DataTableToolbar } from "@/src/components/table/data-table-toolbar";
-import { useRowHeightLocalStorage } from "@/src/components/table/data-table-row-height-switch";
-import useColumnOrder from "@/src/features/column-visibility/hooks/useColumnOrder";
-import { CreateOrEditAnnotationQueueButton } from "@/src/ee/features/annotation-queues/components/CreateOrEditAnnotationQueueButton";
-import { type ScoreDataType } from "@langfuse/shared";
-import { getScoreDataTypeIcon } from "@/src/features/scores/components/ScoreDetailColumnHelpers";
-import {
-  DropdownMenu,
-  DropdownMenuContent,
-  DropdownMenuLabel,
-  DropdownMenuTrigger,
-} from "@/src/components/ui/dropdown-menu";
-import { ClipboardPen, Lock, MoreVertical } from "lucide-react";
-import { Button } from "@/src/components/ui/button";
-import { cn } from "@/src/utils/tailwind";
-import TableLink from "@/src/components/table/table-link";
-import Link from "next/link";
-import { useHasProjectAccess } from "@/src/features/rbac/utils/checkProjectAccess";
-import { DeleteAnnotationQueueButton } from "@/src/ee/features/annotation-queues/components/DeleteAnnotationQueueButton";
-
-type RowData = {
-  key: {
-    id: string;
-    name: string;
-  };
-  description?: string;
-  countCompletedItems: number;
-  countPendingItems: number;
-  scoreConfigs: { id: string; name: string; dataType: ScoreDataType }[];
-  createdAt: string;
-};
-
-export function AnnotationQueuesTable({ projectId }: { projectId: string }) {
-  const [rowHeight, setRowHeight] = useRowHeightLocalStorage(
-    "annotationQueues",
-    "s",
-  );
-
-  const [paginationState, setPaginationState] = useQueryParams({
-    pageIndex: withDefault(NumberParam, 0),
-    pageSize: withDefault(NumberParam, 50),
-  });
-
-  const queues = api.annotationQueues.all.useQuery({
-    projectId: projectId,
-    page: paginationState.pageIndex,
-    limit: paginationState.pageSize,
-  });
-
-  const hasAccess = useHasProjectAccess({
-    projectId: projectId,
-    scope: "annotationQueues:CUD",
-  });
-
-  const columns: LangfuseColumnDef<RowData>[] = [
-    {
-      accessorKey: "key",
-      header: "Name",
-      id: "key",
-      size: 150,
-      isPinned: true,
-      cell: ({ row }) => {
-        const key: RowData["key"] = row.getValue("key");
-        return key && "id" in key && typeof key.id === "string" ? (
-          <TableLink
-            path={`/project/${projectId}/annotation-queues/${key.id}`}
-            value={key.name}
-          />
-        ) : undefined;
-      },
-    },
-    {
-      accessorKey: "description",
-      header: "Description",
-      id: "description",
-      enableHiding: true,
-      size: 200,
-      cell: ({ row }) => {
-        const description: RowData["description"] = row.getValue("description");
-        return (
-          <span
-            className={cn(
-              "grid h-full items-center overflow-auto",
-              rowHeight === "s" && "leading-3",
-            )}
-          >
-            {description}
-          </span>
-        );
-      },
-    },
-    {
-      accessorKey: "countCompletedItems",
-      header: "Completed Items",
-      id: "countCompletedItems",
-      enableHiding: true,
-      size: 90,
-    },
-    {
-      accessorKey: "countPendingItems",
-      header: "Pending Items",
-      id: "countPendingItems",
-      enableHiding: true,
-      size: 90,
-    },
-    {
-      accessorKey: "scoreConfigs",
-      header: "Score Configs",
-      id: "scoreConfigs",
-      enableHiding: true,
-      size: 200,
-      cell: ({ row }) => {
-        const scoreConfigs: RowData["scoreConfigs"] =
-          row.getValue("scoreConfigs");
-
-        return (
-          <span
-            className={cn(
-              "grid h-full items-center overflow-auto",
-              rowHeight === "s" && "leading-3",
-            )}
-          >
-            {scoreConfigs
-              .map(
-                (config) =>
-                  `${getScoreDataTypeIcon(config.dataType)} ${config.name}`,
-              )
-              .join(", ")}
-          </span>
-        );
-      },
-    },
-    {
-      accessorKey: "createdAt",
-      header: "Created",
-      id: "createdAt",
-      enableHiding: true,
-      size: 150,
-    },
-    {
-      accessorKey: "processAction",
-      header: "Process",
-      id: "processAction",
-      isPinned: true,
-      cell: ({ row }) => {
-        const key: RowData["key"] = row.getValue("key");
-        return !hasAccess ? (
-          <Button size="sm" disabled>
-            <Lock className="mr-1 h-3 w-3" />
-            <span className="text-xs">Process queue</span>
-          </Button>
-        ) : (
-          <Button size="sm" asChild>
-            <Link
-              href={`/project/${projectId}/annotation-queues/${key.id}/items`}
-            >
-              <ClipboardPen className="mr-1 h-3 w-3" />
-              <span className="text-xs">Process queue</span>
-            </Link>
-          </Button>
-        );
-      },
-    },
-    {
-      accessorKey: "actions",
-      header: "Actions",
-      id: "actions",
-      size: 70,
-      isPinned: true,
-      cell: ({ row }) => {
-        const key: RowData["key"] = row.getValue("key");
-        return (
-          <DropdownMenu>
-            <DropdownMenuTrigger asChild>
-              <Button variant="ghost" className="h-8 w-8 p-0">
-                <span className="sr-only">Open menu</span>
-                <MoreVertical className="h-4 w-4" />
-              </Button>
-            </DropdownMenuTrigger>
-            <DropdownMenuContent align="end">
-              <DropdownMenuLabel>Actions</DropdownMenuLabel>
-              <div className="flex flex-col space-y-0.5">
-                <CreateOrEditAnnotationQueueButton
-                  projectId={projectId}
-                  queueId={key.id}
-                  variant="ghost"
-                />
-                <DeleteAnnotationQueueButton
-                  projectId={projectId}
-                  queueId={key.id}
-                />
-              </div>
-            </DropdownMenuContent>
-          </DropdownMenu>
-        );
-      },
-    },
-  ];
-
-  const convertToTableRow = (
-    item: RouterOutput["annotationQueues"]["all"]["queues"][number],
-  ): RowData => {
-    return {
-      key: { id: item.id, name: item.name },
-      description: item.description ?? undefined,
-      scoreConfigs: item.scoreConfigs,
-      createdAt: item.createdAt.toLocaleString(),
-      countCompletedItems: item.countCompletedItems,
-      countPendingItems: item.countPendingItems,
-    };
-  };
-
-  const [columnVisibility, setColumnVisibility] = useColumnVisibility<RowData>(
-    "queuesColumnVisibility",
-    columns,
-  );
-
-  const [columnOrder, setColumnOrder] = useColumnOrder<RowData>(
-    "queuesColumnOrder",
-    columns,
-  );
-
-  return (
-    <>
-      <DataTableToolbar
-        columns={columns}
-        columnVisibility={columnVisibility}
-        setColumnVisibility={setColumnVisibility}
-        columnOrder={columnOrder}
-        setColumnOrder={setColumnOrder}
-        rowHeight={rowHeight}
-        setRowHeight={setRowHeight}
-      />
-      <DataTable
-        columns={columns}
-        data={
-          queues.isLoading
-            ? { isLoading: true, isError: false }
-            : queues.isError
-              ? {
-                  isLoading: false,
-                  isError: true,
-                  error: queues.error.message,
-                }
-              : {
-                  isLoading: false,
-                  isError: false,
-                  data: queues.data.queues.map((t) => convertToTableRow(t)),
-                }
-        }
-        pagination={{
-          totalCount: queues.data?.totalCount ?? null,
-          onChange: setPaginationState,
-          state: paginationState,
-        }}
-        columnVisibility={columnVisibility}
-        onColumnVisibilityChange={setColumnVisibility}
-        columnOrder={columnOrder}
-        onColumnOrderChange={setColumnOrder}
-        rowHeight={rowHeight}
-      />
-    </>
-  );
-}
diff --git a/web/src/ee/features/annotation-queues/components/CreateNewAnnotationQueueItem.tsx b/web/src/ee/features/annotation-queues/components/CreateNewAnnotationQueueItem.tsx
deleted file mode 100644
index 78d3626..0000000
--- a/web/src/ee/features/annotation-queues/components/CreateNewAnnotationQueueItem.tsx
+++ /dev/null
@@ -1,196 +0,0 @@
-import { Badge } from "@/src/components/ui/badge";
-import { Button } from "@/src/components/ui/button";
-import {
-  DropdownMenuItem,
-  DropdownMenu,
-  DropdownMenuTrigger,
-  DropdownMenuContent,
-  DropdownMenuSeparator,
-  DropdownMenuCheckboxItem,
-  DropdownMenuLabel,
-} from "@/src/components/ui/dropdown-menu";
-import { useHasProjectAccess } from "@/src/features/rbac/utils/checkProjectAccess";
-import { api } from "@/src/utils/api";
-import { cn } from "@/src/utils/tailwind";
-import {
-  AnnotationQueueStatus,
-  type AnnotationQueueObjectType,
-} from "@langfuse/shared";
-import { ChevronDown, ExternalLink } from "lucide-react";
-import { useSession } from "next-auth/react";
-import Link from "next/link";
-import { useState, useCallback } from "react";
-
-export const CreateNewAnnotationQueueItem = ({
-  projectId,
-  objectId,
-  objectType,
-}: {
-  projectId: string;
-  objectId: string;
-  objectType: AnnotationQueueObjectType;
-}) => {
-  const [isDropdownOpen, setIsDropdownOpen] = useState(false);
-  const session = useSession();
-  const hasAccess = useHasProjectAccess({
-    projectId: projectId,
-    scope: "annotationQueues:CUD",
-  });
-  const queues = api.annotationQueues.byObjectId.useQuery(
-    {
-      projectId,
-      objectId,
-      objectType,
-    },
-    { enabled: session.status === "authenticated" },
-  );
-  const utils = api.useUtils();
-  const addToQueueMutation = api.annotationQueueItems.createMany.useMutation();
-  const removeFromQueueMutation =
-    api.annotationQueueItems.deleteMany.useMutation();
-
-  const handleQueueItemToggle = useCallback(
-    async (queueId: string, queueName: string, itemId?: string) => {
-      try {
-        if (!itemId) {
-          await addToQueueMutation.mutateAsync({
-            projectId,
-            objectIds: [objectId],
-            objectType,
-            queueId,
-          });
-        } else {
-          const confirmRemoval = confirm(
-            `Are you sure you want to remove this item from the queue "${queueName}"?`,
-          );
-          if (confirmRemoval) {
-            await removeFromQueueMutation.mutateAsync({
-              projectId,
-              itemIds: [itemId],
-            });
-          }
-        }
-        // Manually invalidate the query to refresh the data
-        await utils.annotationQueues.byObjectId.invalidate({
-          projectId,
-          objectId,
-          objectType,
-        });
-      } catch (error) {
-        console.error("Error toggling queue item:", error);
-      }
-    },
-    [
-      addToQueueMutation,
-      removeFromQueueMutation,
-      projectId,
-      objectId,
-      objectType,
-      utils.annotationQueues,
-    ],
-  );
-
-  if (session.status !== "authenticated" || queues.isLoading) {
-    return (
-      <Button
-        variant="secondary"
-        disabled={session.status !== "authenticated"}
-        className="rounded-l-none rounded-r-md border-l-2"
-      >
-        <span className="relative mr-1 text-xs">
-          <ChevronDown className="h-3 w-3" />
-        </span>
-      </Button>
-    );
-  }
-
-  return (
-    <DropdownMenu
-      key="queue"
-      open={isDropdownOpen}
-      onOpenChange={() => {
-        if (hasAccess) {
-          setIsDropdownOpen(!isDropdownOpen);
-        }
-      }}
-    >
-      <DropdownMenuTrigger asChild>
-        <Button
-          variant="secondary"
-          disabled={!hasAccess}
-          className="rounded-l-none rounded-r-md border-l-2"
-        >
-          {queues.data?.totalCount ? (
-            <span className="relative mr-1 text-xs">
-              <ChevronDown className="h-3 w-3 text-secondary-foreground" />
-              <span className="absolute -top-1.5 left-2.5 flex max-h-[0.8rem] min-w-[0.8rem] items-center justify-center rounded-full border border-muted-foreground bg-accent-light-blue px-[0.2rem] text-[8px]">
-                {queues.data?.totalCount > 99 ? "99+" : queues.data?.totalCount}
-              </span>
-            </span>
-          ) : (
-            <span className="relative mr-1 text-xs">
-              <ChevronDown className="h-3 w-3" />
-            </span>
-          )}
-        </Button>
-      </DropdownMenuTrigger>
-      <DropdownMenuContent>
-        <DropdownMenuLabel>In queue(s)</DropdownMenuLabel>
-        {queues.data?.queues.length ? (
-          queues.data?.queues.map((queue) => (
-            <DropdownMenuCheckboxItem
-              key={queue.id}
-              className="hover:bg-accent"
-              checked={!!queue.itemId}
-              onSelect={(event) => {
-                event.preventDefault();
-              }}
-              onClick={(event) => {
-                event.preventDefault();
-                event.stopPropagation();
-                handleQueueItemToggle(queue.id, queue.name, queue.itemId);
-              }}
-            >
-              {queue.name}
-              {queue.status && (
-                <Badge
-                  className={cn(
-                    "ml-2 px-1 py-0.5 text-[10px] capitalize",
-                    queue.status === AnnotationQueueStatus.COMPLETED
-                      ? "bg-light-green text-dark-green"
-                      : "bg-light-yellow text-dark-yellow",
-                  )}
-                  variant="outline"
-                >
-                  {queue.status.toLowerCase()}
-                </Badge>
-              )}
-            </DropdownMenuCheckboxItem>
-          ))
-        ) : (
-          <DropdownMenuItem
-            onClick={(event) => {
-              event.preventDefault();
-              event.stopPropagation();
-            }}
-          >
-            No queues defined
-          </DropdownMenuItem>
-        )}
-        <DropdownMenuSeparator />
-        <DropdownMenuItem
-          key="manage-queues"
-          className="hover:bg-accent"
-          asChild
-        >
-          <div>
-            <ExternalLink className="mr-2 h-4 w-4" />
-            <Link href={`/project/${projectId}/annotation-queues`}>
-              Manage queues
-            </Link>
-          </div>
-        </DropdownMenuItem>
-      </DropdownMenuContent>
-    </DropdownMenu>
-  );
-};
diff --git a/web/src/ee/features/annotation-queues/components/CreateOrEditAnnotationQueueButton.tsx b/web/src/ee/features/annotation-queues/components/CreateOrEditAnnotationQueueButton.tsx
deleted file mode 100644
index 578e384..0000000
--- a/web/src/ee/features/annotation-queues/components/CreateOrEditAnnotationQueueButton.tsx
+++ /dev/null
@@ -1,292 +0,0 @@
-import { Button, type ButtonProps } from "@/src/components/ui/button";
-import React, { useEffect, useState } from "react";
-import {
-  Dialog,
-  DialogContent,
-  DialogDescription,
-  DialogHeader,
-  DialogTitle,
-  DialogTrigger,
-} from "@/src/components/ui/dialog";
-import {
-  FormControl,
-  FormDescription,
-  FormField,
-  FormItem,
-  FormLabel,
-  FormMessage,
-} from "@/src/components/ui/form";
-import { Input } from "@/src/components/ui/input";
-import { useHasProjectAccess } from "@/src/features/rbac/utils/checkProjectAccess";
-import { zodResolver } from "@hookform/resolvers/zod";
-import { Edit, PlusIcon } from "lucide-react";
-import { useForm } from "react-hook-form";
-import { Form } from "@/src/components/ui/form";
-import { Textarea } from "@/src/components/ui/textarea";
-import {
-  type CreateQueue,
-  CreateQueueData,
-  type ValidatedScoreConfig,
-} from "@langfuse/shared";
-import { api } from "@/src/utils/api";
-import { getScoreDataTypeIcon } from "@/src/features/scores/components/ScoreDetailColumnHelpers";
-import { MultiSelectKeyValues } from "@/src/features/scores/components/multi-select-key-values";
-import { useRouter } from "next/router";
-import { usePostHogClientCapture } from "@/src/features/posthog-analytics/usePostHogClientCapture";
-import {
-  useHasEntitlement,
-  useEntitlementLimit,
-} from "@/src/features/entitlements/hooks";
-import { ActionButton } from "@/src/components/ActionButton";
-import { DropdownMenuItem } from "@/src/components/ui/dropdown-menu";
-
-export const CreateOrEditAnnotationQueueButton = ({
-  projectId,
-  queueId,
-  variant = "secondary",
-  size,
-}: {
-  projectId: string;
-  queueId?: string;
-  variant?: ButtonProps["variant"];
-  size?: ButtonProps["size"];
-}) => {
-  const [isOpen, setIsOpen] = useState(false);
-  const hasAccess = useHasProjectAccess({
-    projectId: projectId,
-    scope: "annotationQueues:CUD",
-  });
-  const hasEntitlement = useHasEntitlement("annotation-queues");
-  const queueLimit = useEntitlementLimit("annotation-queue-count");
-  const router = useRouter();
-  const capture = usePostHogClientCapture();
-
-  const queueQuery = api.annotationQueues.byId.useQuery(
-    { projectId, queueId: queueId as string },
-    { enabled: !!queueId && hasAccess },
-  );
-
-  const form = useForm<CreateQueue>({
-    resolver: zodResolver(CreateQueueData),
-  });
-
-  useEffect(() => {
-    if (queueId && queueQuery.data) {
-      form.reset({
-        name: queueQuery.data.name,
-        description: queueQuery.data.description || undefined,
-        scoreConfigIds: queueQuery.data.scoreConfigs.map(
-          (config: ValidatedScoreConfig) => config.id,
-        ),
-      });
-    } else {
-      form.reset({
-        name: "",
-        scoreConfigIds: [],
-      });
-    }
-    // eslint-disable-next-line react-hooks/exhaustive-deps
-  }, [queueId, queueQuery.data]);
-
-  const utils = api.useUtils();
-
-  const createQueueMutation = api.annotationQueues.create.useMutation({
-    onSuccess: async () => {
-      await Promise.all([utils.annotationQueues.invalidate()]);
-      form.reset();
-      setIsOpen(false);
-    },
-  });
-  const editQueueMutation = api.annotationQueues.update.useMutation({
-    onSuccess: async () => {
-      await Promise.all([utils.annotationQueues.invalidate()]);
-      form.reset();
-      setIsOpen(false);
-    },
-  });
-
-  const queueCountData = api.annotationQueues.count.useQuery(
-    { projectId },
-    { enabled: hasAccess },
-  );
-
-  const configsData = api.scoreConfigs.all.useQuery(
-    {
-      projectId,
-    },
-    {
-      enabled: hasAccess && isOpen,
-    },
-  );
-
-  const configs = configsData.data?.configs ?? [];
-
-  const onSubmit = (data: CreateQueue) => {
-    if (queueId) {
-      editQueueMutation.mutateAsync({
-        ...data,
-        projectId,
-        queueId,
-      });
-    } else {
-      createQueueMutation.mutateAsync({
-        ...data,
-        projectId,
-      });
-    }
-  };
-
-  const handleOnValueChange = (values: Record<string, string>[]) => {
-    form.setValue(
-      "scoreConfigIds",
-      values.map((value) => value.key),
-    );
-
-    if (values.length === 0) {
-      form.setError("scoreConfigIds", {
-        type: "manual",
-        message: "At least 1 score config must be selected",
-      });
-    } else {
-      form.clearErrors("scoreConfigIds");
-    }
-  };
-
-  return (
-    <Dialog open={isOpen} onOpenChange={setIsOpen}>
-      <DialogTrigger asChild>
-        <ActionButton
-          variant={variant}
-          onClick={() => setIsOpen(true)}
-          className="justify-start"
-          icon={
-            queueId ? (
-              <Edit className="h-4 w-4" aria-hidden="true" />
-            ) : (
-              <PlusIcon className="h-4 w-4" aria-hidden="true" />
-            )
-          }
-          hasAccess={hasAccess}
-          hasEntitlement={hasEntitlement}
-          limitValue={queueCountData.data}
-          limit={queueLimit}
-          size={size}
-        >
-          <span className="ml-1 text-sm font-normal">
-            {queueId ? "Edit" : "New queue"}
-          </span>
-        </ActionButton>
-      </DialogTrigger>
-      {configsData.data && (
-        <DialogContent className="max-h-[90vh] overflow-y-auto">
-          <DialogHeader>
-            <DialogTitle>
-              {queueId ? "Edit" : "New"} annotation queue
-            </DialogTitle>
-            <DialogDescription>
-              {queueId ? "Edit" : "Create a new"} queue to manage your
-              annotation workflows.
-            </DialogDescription>
-          </DialogHeader>
-          <Form {...form}>
-            <form className="space-y-6" onSubmit={form.handleSubmit(onSubmit)}>
-              <FormField
-                control={form.control}
-                name="name"
-                render={({ field }) => (
-                  <FormItem>
-                    <FormLabel>Name</FormLabel>
-                    <FormControl>
-                      <Input
-                        {...field}
-                        type="text"
-                        className="text-xs"
-                        onBlur={(e) => field.onChange(e.target.value.trimEnd())}
-                      />
-                    </FormControl>
-                    <FormMessage />
-                  </FormItem>
-                )}
-              />
-              <FormField
-                control={form.control}
-                name="description"
-                render={({ field }) => (
-                  <FormItem>
-                    <FormLabel>Description (optional)</FormLabel>
-                    <FormControl>
-                      <Textarea
-                        {...field}
-                        placeholder="Add description..."
-                        className="text-xs focus:outline-none focus:ring-0 focus-visible:ring-0 focus-visible:ring-offset-0 active:ring-0"
-                      />
-                    </FormControl>
-                    <FormMessage />
-                  </FormItem>
-                )}
-              />
-              <FormField
-                control={form.control}
-                name="scoreConfigIds"
-                render={({ field }) => (
-                  <FormItem>
-                    <FormLabel>Score Configs</FormLabel>
-                    <FormDescription>
-                      Define which dimensions annotators should score for the
-                      given queue.
-                    </FormDescription>
-                    <FormControl>
-                      <MultiSelectKeyValues
-                        placeholder="Value"
-                        align="end"
-                        className="grid grid-cols-[auto,1fr,auto,auto] gap-2"
-                        onValueChange={handleOnValueChange}
-                        options={configs
-                          .filter((config) => !config.isArchived)
-                          .map((config) => ({
-                            key: config.id,
-                            value: `${getScoreDataTypeIcon(config.dataType)} ${config.name}`,
-                            isArchived: config.isArchived,
-                          }))}
-                        values={field.value.map((configId) => {
-                          const config = configs.find(
-                            (config) => config.id === configId,
-                          );
-                          return {
-                            value: config
-                              ? `${getScoreDataTypeIcon(config.dataType)} ${config.name}`
-                              : `${configId}`,
-                            key: configId,
-                          };
-                        })}
-                        controlButtons={
-                          <DropdownMenuItem
-                            onSelect={() => {
-                              capture(
-                                "score_configs:manage_configs_item_click",
-                                { source: "AnnotationQueue" },
-                              );
-                              router.push(
-                                `/project/${projectId}/settings/scores`,
-                              );
-                            }}
-                          >
-                            Manage score configs
-                          </DropdownMenuItem>
-                        }
-                      />
-                    </FormControl>
-                    <FormMessage />
-                  </FormItem>
-                )}
-              />
-              <Button type="submit" className="text-xs">
-                {queueId ? "Save" : "Create"} queue
-              </Button>
-            </form>
-          </Form>
-        </DialogContent>
-      )}
-    </Dialog>
-  );
-};
diff --git a/web/src/ee/features/annotation-queues/components/DeleteAnnotationQueueButton.tsx b/web/src/ee/features/annotation-queues/components/DeleteAnnotationQueueButton.tsx
deleted file mode 100644
index 4c8975a..0000000
--- a/web/src/ee/features/annotation-queues/components/DeleteAnnotationQueueButton.tsx
+++ /dev/null
@@ -1,88 +0,0 @@
-import { Button } from "@/src/components/ui/button";
-import {
-  Dialog,
-  DialogContent,
-  DialogDescription,
-  DialogHeader,
-  DialogTitle,
-  DialogTrigger,
-} from "@/src/components/ui/dialog";
-import { useHasProjectAccess } from "@/src/features/rbac/utils/checkProjectAccess";
-import { api } from "@/src/utils/api";
-import { LockIcon, Trash } from "lucide-react";
-import React, { useState } from "react";
-
-type DeleteAnnotationQueueButtonProps = {
-  projectId: string;
-  queueId: string;
-};
-
-export const DeleteAnnotationQueueButton = ({
-  projectId,
-  queueId,
-}: DeleteAnnotationQueueButtonProps) => {
-  const [isOpen, setIsOpen] = useState(false);
-  const hasAccess = useHasProjectAccess({
-    projectId: projectId,
-    scope: "annotationQueues:CUD",
-  });
-  const utils = api.useUtils();
-  const mutDelete = api.annotationQueues.delete.useMutation({
-    onSuccess: () => {
-      utils.annotationQueues.invalidate();
-    },
-  });
-
-  const button = (
-    <Button variant="ghost" disabled={!hasAccess}>
-      <div className="flex w-full flex-row items-center gap-1">
-        {hasAccess ? (
-          <Trash className="-ml-0.5 mr-1.5 h-4 w-4" />
-        ) : (
-          <LockIcon className="-ml-0.5 mr-1.5 h-4 w-4" aria-hidden="true" />
-        )}
-        <span className="text-sm font-normal">Delete</span>
-      </div>
-    </Button>
-  );
-
-  return hasAccess ? (
-    <Dialog
-      open={isOpen}
-      onOpenChange={(open) => {
-        if (!mutDelete.isLoading) {
-          setIsOpen(open);
-        }
-      }}
-    >
-      <DialogTrigger asChild>{button}</DialogTrigger>
-      <DialogContent className="sm:max-w-xl">
-        <DialogHeader>
-          <DialogTitle className="mb-4">Please confirm</DialogTitle>
-          <DialogDescription className="text-md p-0">
-            This action cannot be undone and removes queue items attached to
-            this queue. Scores added while annotating in this queue will not be
-            deleted.
-          </DialogDescription>
-        </DialogHeader>
-        <Button
-          variant="destructive"
-          loading={mutDelete.isLoading}
-          disabled={mutDelete.isLoading}
-          onClick={async (event) => {
-            event.preventDefault();
-            await mutDelete.mutateAsync({
-              projectId,
-              queueId,
-            });
-            setIsOpen(false);
-          }}
-        >
-          Delete Annotation Queue
-        </Button>
-      </DialogContent>
-    </Dialog>
-  ) : (
-    button
-  );
-};
diff --git a/web/src/ee/features/annotation-queues/pages/AnnotationQueueItems.tsx b/web/src/ee/features/annotation-queues/pages/AnnotationQueueItems.tsx
deleted file mode 100644
index 9103f2d..0000000
--- a/web/src/ee/features/annotation-queues/pages/AnnotationQueueItems.tsx
+++ /dev/null
@@ -1,118 +0,0 @@
-import { api } from "@/src/utils/api";
-import { useRouter } from "next/router";
-import { AnnotationQueueItemsTable } from "@/src/ee/features/annotation-queues/components/AnnotationQueueItemsTable";
-import { CardDescription } from "@/src/components/ui/card";
-import { Button } from "@/src/components/ui/button";
-import { ClipboardPen, Lock } from "lucide-react";
-import { Badge } from "@/src/components/ui/badge";
-import { getScoreDataTypeIcon } from "@/src/features/scores/components/ScoreDetailColumnHelpers";
-import Link from "next/link";
-import { CreateOrEditAnnotationQueueButton } from "@/src/ee/features/annotation-queues/components/CreateOrEditAnnotationQueueButton";
-import { useHasProjectAccess } from "@/src/features/rbac/utils/checkProjectAccess";
-import { useHasEntitlement } from "@/src/features/entitlements/hooks";
-import { SupportOrUpgradePage } from "@/src/ee/features/billing/components/SupportOrUpgradePage";
-import { Skeleton } from "@/src/components/ui/skeleton";
-import Page from "@/src/components/layouts/page";
-import {
-  SidePanel,
-  SidePanelContent,
-  SidePanelHeader,
-  SidePanelTitle,
-} from "@/src/components/ui/side-panel";
-import { SubHeaderLabel } from "@/src/components/layouts/header";
-
-export default function QueueItems() {
-  const router = useRouter();
-  const projectId = router.query.projectId as string;
-  const queueId = router.query.queueId as string;
-
-  const queue = api.annotationQueues.byId.useQuery({
-    queueId,
-    projectId,
-  });
-
-  const hasReadAccess = useHasProjectAccess({
-    projectId,
-    scope: "annotationQueues:read",
-  });
-  const hasWriteAccess = useHasProjectAccess({
-    projectId,
-    scope: "annotationQueues:CUD",
-  });
-  const hasEntitlement = useHasEntitlement("annotation-queues");
-  if (!hasReadAccess || !hasEntitlement) return <SupportOrUpgradePage />;
-
-  return (
-    <Page
-      headerProps={{
-        title: `${queue.data?.name}: ${queueId}`,
-        itemType: "ANNOTATION_QUEUE",
-        breadcrumb: [
-          {
-            name: "Annotation Queues",
-            href: `/project/${projectId}/annotation-queues`,
-          },
-        ],
-        actionButtonsRight: !hasWriteAccess ? (
-          <Button disabled>
-            <Lock className="mr-1 h-4 w-4" />
-            <span className="text-sm">Process queue</span>
-          </Button>
-        ) : (
-          <Button asChild>
-            <Link
-              href={`/project/${projectId}/annotation-queues/${queueId}/items`}
-            >
-              <ClipboardPen className="mr-1 h-4 w-4" />
-              <span className="text-sm">Process queue</span>
-            </Link>
-          </Button>
-        ),
-      }}
-    >
-      <div className="grid flex-1 grid-cols-[1fr,auto] overflow-hidden">
-        <div className="flex h-full flex-col overflow-hidden">
-          <AnnotationQueueItemsTable projectId={projectId} queueId={queueId} />
-        </div>
-        <SidePanel
-          mobileTitle={queue.data?.name ?? "Queue details"}
-          id="queue-details"
-        >
-          <SidePanelHeader>
-            <SidePanelTitle>
-              {queue.data?.name ?? "Queue details"}
-            </SidePanelTitle>
-            <CreateOrEditAnnotationQueueButton
-              projectId={projectId}
-              queueId={queueId}
-            />
-          </SidePanelHeader>
-          <SidePanelContent>
-            {queue.isLoading ? (
-              <Skeleton className="h-full w-full" />
-            ) : (
-              <>
-                {queue.data?.description && (
-                  <CardDescription className="text-sm">
-                    {queue.data?.description}
-                  </CardDescription>
-                )}
-                <div className="flex flex-col gap-2">
-                  <SubHeaderLabel title="Score Configs" />
-                  <div className="flex flex-wrap gap-2">
-                    {queue.data?.scoreConfigs.map((scoreConfig) => (
-                      <Badge key={scoreConfig.id} variant="outline">
-                        {getScoreDataTypeIcon(scoreConfig.dataType)}
-                        <span className="ml-0.5">{scoreConfig.name}</span>
-                      </Badge>
-                    ))}
-                  </div>
-                </div>
-              </>
-            )}
-          </SidePanelContent>
-        </SidePanel>
-      </div>
-    </Page>
-  );
-}
diff --git a/web/src/ee/features/annotation-queues/pages/AnnotationQueues.tsx b/web/src/ee/features/annotation-queues/pages/AnnotationQueues.tsx
deleted file mode 100644
index 3d12908..0000000
--- a/web/src/ee/features/annotation-queues/pages/AnnotationQueues.tsx
+++ /dev/null
@@ -1,64 +0,0 @@
-import { useRouter } from "next/router";
-import { AnnotationQueuesTable } from "@/src/ee/features/annotation-queues/components/AnnotationQueuesTable";
-import { useHasProjectAccess } from "@/src/features/rbac/utils/checkProjectAccess";
-import { useHasEntitlement } from "@/src/features/entitlements/hooks";
-import { SupportOrUpgradePage } from "@/src/ee/features/billing/components/SupportOrUpgradePage";
-import Page from "@/src/components/layouts/page";
-import { AnnotationQueuesOnboarding } from "@/src/components/onboarding/AnnotationQueuesOnboarding";
-import { api } from "@/src/utils/api";
-import { CreateOrEditAnnotationQueueButton } from "@/src/ee/features/annotation-queues/components/CreateOrEditAnnotationQueueButton";
-
-export default function AnnotationQueues() {
-  const router = useRouter();
-  const projectId = router.query.projectId as string;
-  const hasAccess = useHasProjectAccess({
-    projectId: projectId,
-    scope: "annotationQueues:read",
-  });
-  const hasEntitlement = useHasEntitlement("annotation-queues");
-
-  // Check if the user has any annotation queues
-  const { data: hasAnyQueue, isLoading } = api.annotationQueues.hasAny.useQuery(
-    { projectId },
-    {
-      enabled: !!projectId && hasEntitlement,
-      trpc: {
-        context: {
-          skipBatch: true,
-        },
-      },
-      refetchInterval: 10_000,
-    },
-  );
-
-  const showOnboarding = !isLoading && !hasAnyQueue;
-
-  if (!hasAccess || !hasEntitlement) return <SupportOrUpgradePage />;
-
-  return (
-    <Page
-      headerProps={{
-        title: "Annotation Queues",
-        help: {
-          description:
-            "Annotation queues are used to manage scoring workflows for your LLM projects. See docs to learn more.",
-          href: "https://langfuse.com/docs/scores/annotation",
-        },
-        actionButtonsRight: (
-          <CreateOrEditAnnotationQueueButton
-            projectId={projectId}
-            variant="default"
-          />
-        ),
-      }}
-      scrollable={showOnboarding}
-    >
-      {/* Show onboarding screen if user has no annotation queues */}
-      {showOnboarding ? (
-        <AnnotationQueuesOnboarding projectId={projectId} />
-      ) : (
-        <AnnotationQueuesTable projectId={projectId} />
-      )}
-    </Page>
-  );
-}
diff --git a/web/src/ee/features/annotation-queues/server/annotationQueueItems.ts b/web/src/ee/features/annotation-queues/server/annotationQueueItems.ts
deleted file mode 100644
index 3750e26..0000000
--- a/web/src/ee/features/annotation-queues/server/annotationQueueItems.ts
+++ /dev/null
@@ -1,475 +0,0 @@
-import { auditLog } from "@/src/features/audit-logs/auditLog";
-import { throwIfNoEntitlement } from "@/src/features/entitlements/server/hasEntitlement";
-import { throwIfNoProjectAccess } from "@/src/features/rbac/utils/checkProjectAccess";
-import { createBatchActionJob } from "@/src/features/table/server/createBatchActionJob";
-import {
-  createTRPCRouter,
-  protectedProjectProcedure,
-} from "@/src/server/api/trpc";
-import {
-  type AnnotationQueueItem,
-  AnnotationQueueObjectType,
-  AnnotationQueueStatus,
-  BatchActionQuerySchema,
-  BatchActionType,
-  BatchExportTableName,
-  paginationZod,
-  Prisma,
-} from "@langfuse/shared";
-import {
-  getObservationById,
-  getTraceIdsForObservations,
-  logger,
-} from "@langfuse/shared/src/server";
-import { TRPCError } from "@trpc/server";
-import { z } from "zod";
-
-const isItemLocked = (item: AnnotationQueueItem) => {
-  return (
-    item.lockedByUserId &&
-    item.lockedAt &&
-    new Date(item.lockedAt) > new Date(Date.now() - 5 * 60 * 1000)
-  );
-};
-
-export const queueItemRouter = createTRPCRouter({
-  byId: protectedProjectProcedure
-    .input(
-      z.object({
-        projectId: z.string(),
-        itemId: z.string(),
-      }),
-    )
-    .query(async ({ input, ctx }) => {
-      try {
-        throwIfNoEntitlement({
-          entitlement: "annotation-queues",
-          projectId: input.projectId,
-          sessionUser: ctx.session.user,
-        });
-
-        throwIfNoProjectAccess({
-          session: ctx.session,
-          projectId: input.projectId,
-          scope: "annotationQueues:read",
-        });
-
-        const item = await ctx.prisma.annotationQueueItem.findUnique({
-          where: {
-            id: input.itemId,
-            projectId: input.projectId,
-          },
-        });
-
-        // Expected behavior, non-error case: if user has seen item in given session, prior to it being deleted, we return null
-        if (!item) return null;
-        let lockedByUser: { name: string | null } | null = null;
-
-        if (isItemLocked(item)) {
-          lockedByUser = await ctx.prisma.user.findUnique({
-            where: {
-              id: item.lockedByUserId as string,
-            },
-            select: {
-              name: true,
-            },
-          });
-        }
-
-        const inflatedItem = {
-          ...item,
-          lockedByUser,
-        };
-
-        if (item.objectType === AnnotationQueueObjectType.OBSERVATION) {
-          const clickhouseObservation = await getObservationById(
-            item.objectId,
-            input.projectId,
-          );
-          return {
-            ...inflatedItem,
-            parentTraceId: clickhouseObservation?.traceId,
-          };
-        }
-
-        return inflatedItem;
-      } catch (error) {
-        logger.error(error);
-        if (error instanceof TRPCError) {
-          throw error;
-        }
-        throw new TRPCError({
-          code: "INTERNAL_SERVER_ERROR",
-          message: "Fetching annotation queue item by id failed.",
-        });
-      }
-    }),
-  itemsByQueueId: protectedProjectProcedure
-    .input(
-      z.object({
-        queueId: z.string(),
-        projectId: z.string(),
-        ...paginationZod,
-      }),
-    )
-    .query(async ({ input, ctx }) => {
-      try {
-        throwIfNoEntitlement({
-          entitlement: "annotation-queues",
-          projectId: input.projectId,
-          sessionUser: ctx.session.user,
-        });
-
-        throwIfNoProjectAccess({
-          session: ctx.session,
-          projectId: input.projectId,
-          scope: "annotationQueues:read",
-        });
-
-        const [queueItems, totalItems] = await Promise.all([
-          await ctx.prisma.$queryRaw<
-            Array<{
-              id: string;
-              status: AnnotationQueueStatus;
-              objectId: string;
-              objectType: AnnotationQueueObjectType;
-              completedAt: string | null;
-              annotatorUserId: string | null;
-              annotatorUserImage: string | null;
-              annotatorUserName: string | null;
-            }>
-          >(Prisma.sql`
-            SELECT
-              aqi.id,
-              aqi.status,
-              aqi.object_id AS "objectId",
-              aqi.object_type AS "objectType",
-              aqi.completed_at AS "completedAt",
-              aqi.annotator_user_id AS "annotatorUserId",
-              u.image AS "annotatorUserImage", 
-              u.name AS "annotatorUserName"
-            FROM
-              annotation_queue_items aqi
-            LEFT JOIN 
-              users u ON u.id = aqi.annotator_user_id AND u.id in (SELECT user_id FROM organization_memberships WHERE org_id = ${ctx.session.orgId})
-            WHERE 
-              aqi.project_id = ${input.projectId} AND aqi.queue_id = ${input.queueId}
-            ORDER BY 
-              aqi.created_at ASC,
-              aqi.object_id ASC,
-              aqi.object_type ASC
-            ${input.limit ? Prisma.sql`LIMIT ${input.limit}` : Prisma.empty}
-            ${input.page && input.limit ? Prisma.sql`OFFSET ${input.page * input.limit}` : Prisma.empty}
-          `),
-          ctx.prisma.annotationQueueItem.count({
-            where: {
-              queueId: input.queueId,
-              projectId: input.projectId,
-            },
-          }),
-        ]);
-
-        const observationIds = queueItems
-          .filter(
-            (item) => item.objectType === AnnotationQueueObjectType.OBSERVATION,
-          )
-          .map((item) => item.objectId);
-
-        const traceIds =
-          observationIds.length > 0
-            ? await getTraceIdsForObservations(input.projectId, observationIds)
-            : [];
-
-        return {
-          queueItems: queueItems.map((item) => ({
-            ...item,
-            parentTraceId:
-              traceIds.find((t) => t.id === item.objectId)?.traceId || null,
-          })),
-          totalItems,
-        };
-      } catch (error) {
-        logger.error(error);
-        if (error instanceof TRPCError) {
-          throw error;
-        }
-        throw new TRPCError({
-          code: "INTERNAL_SERVER_ERROR",
-          message: "Fetching annotation queue items failed.",
-        });
-      }
-    }),
-  unseenPendingItemCountByQueueId: protectedProjectProcedure
-    .input(
-      z.object({
-        queueId: z.string(),
-        projectId: z.string(),
-        seenItemIds: z.array(z.string()),
-      }),
-    )
-    .query(async ({ input, ctx }) => {
-      try {
-        throwIfNoEntitlement({
-          entitlement: "annotation-queues",
-          projectId: input.projectId,
-          sessionUser: ctx.session.user,
-        });
-
-        throwIfNoProjectAccess({
-          session: ctx.session,
-          projectId: input.projectId,
-          scope: "annotationQueues:read",
-        });
-
-        const count = await ctx.prisma.annotationQueueItem.count({
-          where: {
-            queueId: input.queueId,
-            projectId: input.projectId,
-            status: AnnotationQueueStatus.PENDING,
-            id: {
-              notIn: input.seenItemIds,
-            },
-          },
-        });
-        return count;
-      } catch (error) {
-        logger.error(error);
-        if (error instanceof TRPCError) {
-          throw error;
-        }
-        throw new TRPCError({
-          code: "INTERNAL_SERVER_ERROR",
-          message: "Fetching unseen pending item count by queueId failed.",
-        });
-      }
-    }),
-  createMany: protectedProjectProcedure
-    .input(
-      z.object({
-        projectId: z.string(),
-        queueId: z.string(),
-        objectIds: z
-          .array(z.string())
-          .min(1, "Minimum 1 object_id is required."),
-        objectType: z.nativeEnum(AnnotationQueueObjectType),
-        query: BatchActionQuerySchema.optional(),
-        isBatchAction: z.boolean().default(false),
-      }),
-    )
-    .mutation(async ({ input, ctx }) => {
-      try {
-        throwIfNoEntitlement({
-          entitlement: "annotation-queues",
-          projectId: input.projectId,
-          sessionUser: ctx.session.user,
-        });
-
-        throwIfNoProjectAccess({
-          session: ctx.session,
-          projectId: input.projectId,
-          scope: "annotationQueues:CUD",
-        });
-
-        let createdCount = 0;
-
-        if (input.isBatchAction && input.query) {
-          await createBatchActionJob({
-            projectId: input.projectId,
-            actionId: "trace-add-to-annotation-queue",
-            actionType: BatchActionType.Create,
-            tableName: BatchExportTableName.Traces,
-            session: ctx.session,
-            query: input.query,
-            targetId: input.queueId,
-          });
-        } else {
-          const { count } = await ctx.prisma.annotationQueueItem.createMany({
-            data: input.objectIds.map((objectId) => ({
-              projectId: input.projectId,
-              queueId: input.queueId,
-              objectId,
-              objectType: input.objectType,
-            })),
-            skipDuplicates: true,
-          });
-          createdCount = count;
-
-          const createdItems = await ctx.prisma.annotationQueueItem.findMany({
-            where: {
-              projectId: input.projectId,
-              queueId: input.queueId,
-              objectId: { in: input.objectIds },
-              objectType: input.objectType,
-            },
-            orderBy: { createdAt: "desc" },
-          });
-
-          for (const item of createdItems) {
-            await auditLog(
-              {
-                session: ctx.session,
-                resourceType: "annotationQueueItem",
-                resourceId: item.id,
-                action: "create",
-                after: item,
-              },
-              ctx.prisma,
-            );
-          }
-        }
-
-        const queue = await ctx.prisma.annotationQueue.findUnique({
-          where: {
-            id: input.queueId,
-            projectId: input.projectId,
-          },
-          select: {
-            name: true,
-            id: true,
-          },
-        });
-
-        return {
-          createdCount,
-          queueName: queue?.name,
-          queueId: queue?.id,
-        };
-      } catch (error) {
-        logger.error(error);
-        if (error instanceof TRPCError) {
-          throw error;
-        }
-        throw new TRPCError({
-          code: "INTERNAL_SERVER_ERROR",
-          message: "Creating multiple annotation queue items failed.",
-        });
-      }
-    }),
-  deleteMany: protectedProjectProcedure
-    .input(
-      z.object({
-        itemIds: z.array(z.string()).min(1, "Minimum 1 item_id is required."),
-        projectId: z.string(),
-      }),
-    )
-    .mutation(async ({ input, ctx }) => {
-      try {
-        throwIfNoEntitlement({
-          entitlement: "annotation-queues",
-          projectId: input.projectId,
-          sessionUser: ctx.session.user,
-        });
-
-        throwIfNoProjectAccess({
-          session: ctx.session,
-          projectId: input.projectId,
-          scope: "annotationQueues:CUD",
-        });
-
-        const items = await ctx.prisma.annotationQueueItem.findMany({
-          where: {
-            id: {
-              in: input.itemIds,
-            },
-            projectId: input.projectId,
-          },
-        });
-
-        for (const item of items) {
-          await auditLog({
-            resourceType: "annotationQueueItem",
-            resourceId: item.id,
-            before: item,
-            action: "delete",
-            session: ctx.session,
-          });
-        }
-
-        const { count } = await ctx.prisma.annotationQueueItem.deleteMany({
-          where: {
-            id: {
-              in: input.itemIds,
-            },
-            projectId: input.projectId,
-          },
-        });
-
-        return {
-          deletedCount: count,
-        };
-      } catch (error) {
-        logger.error(error);
-        if (error instanceof TRPCError) {
-          throw error;
-        }
-        throw new TRPCError({
-          code: "INTERNAL_SERVER_ERROR",
-          message: "Deleting annotation queue items failed.",
-        });
-      }
-    }),
-  complete: protectedProjectProcedure
-    .input(
-      z.object({
-        projectId: z.string(),
-        itemId: z.string(),
-      }),
-    )
-    .mutation(async ({ input, ctx }) => {
-      try {
-        throwIfNoEntitlement({
-          entitlement: "annotation-queues",
-          projectId: input.projectId,
-          sessionUser: ctx.session.user,
-        });
-
-        throwIfNoProjectAccess({
-          session: ctx.session,
-          projectId: input.projectId,
-          scope: "annotationQueues:CUD",
-        });
-
-        const item = await ctx.prisma.annotationQueueItem.update({
-          where: {
-            id: input.itemId,
-            projectId: input.projectId,
-            status: AnnotationQueueStatus.PENDING,
-          },
-          data: {
-            status: AnnotationQueueStatus.COMPLETED,
-            completedAt: new Date(),
-            annotatorUserId: ctx.session.user.id,
-          },
-        });
-
-        await auditLog({
-          resourceType: "annotationQueueItem",
-          resourceId: item.id,
-          action: "complete",
-          after: item,
-          session: ctx.session,
-        });
-
-        return item;
-      } catch (error) {
-        logger.error(error);
-        if (error instanceof TRPCError) {
-          throw error;
-        }
-        if (
-          error instanceof Prisma.PrismaClientKnownRequestError &&
-          error.code === "P2025"
-        ) {
-          throw new TRPCError({
-            code: "NOT_FOUND",
-            message:
-              "The item to complete was not found, it was likely deleted.",
-          });
-        }
-        throw new TRPCError({
-          code: "INTERNAL_SERVER_ERROR",
-          message: "Completing annotation queue item failed.",
-        });
-      }
-    }),
-});
diff --git a/web/src/ee/features/annotation-queues/server/annotationQueues.ts b/web/src/ee/features/annotation-queues/server/annotationQueues.ts
deleted file mode 100644
index cdfc4f9..0000000
--- a/web/src/ee/features/annotation-queues/server/annotationQueues.ts
+++ /dev/null
@@ -1,583 +0,0 @@
-import { auditLog } from "@/src/features/audit-logs/auditLog";
-import { throwIfNoEntitlement } from "@/src/features/entitlements/server/hasEntitlement";
-import { throwIfNoProjectAccess } from "@/src/features/rbac/utils/checkProjectAccess";
-import {
-  createTRPCRouter,
-  protectedProjectProcedure,
-} from "@/src/server/api/trpc";
-import {
-  AnnotationQueueObjectType,
-  AnnotationQueueStatus,
-  CreateQueueData,
-  filterAndValidateDbScoreConfigList,
-  LangfuseNotFoundError,
-  optionalPaginationZod,
-  Prisma,
-} from "@langfuse/shared";
-import { getObservationById, logger } from "@langfuse/shared/src/server";
-import { TRPCError } from "@trpc/server";
-import { z } from "zod";
-
-export const queueRouter = createTRPCRouter({
-  hasAny: protectedProjectProcedure
-    .input(
-      z.object({
-        projectId: z.string(),
-      }),
-    )
-    .query(async ({ input, ctx }) => {
-      throwIfNoEntitlement({
-        entitlement: "annotation-queues",
-        projectId: input.projectId,
-        sessionUser: ctx.session.user,
-      });
-
-      throwIfNoProjectAccess({
-        session: ctx.session,
-        projectId: input.projectId,
-        scope: "annotationQueues:read",
-      });
-
-      const queue = await ctx.prisma.annotationQueue.findFirst({
-        where: {
-          projectId: input.projectId,
-        },
-        select: { id: true },
-        take: 1,
-      });
-
-      return queue !== null;
-    }),
-  all: protectedProjectProcedure
-    .input(
-      z.object({
-        projectId: z.string(),
-        ...optionalPaginationZod,
-      }),
-    )
-    .query(async ({ input, ctx }) => {
-      try {
-        throwIfNoEntitlement({
-          entitlement: "annotation-queues",
-          projectId: input.projectId,
-          sessionUser: ctx.session.user,
-        });
-
-        throwIfNoProjectAccess({
-          session: ctx.session,
-          projectId: input.projectId,
-          scope: "annotationQueues:read",
-        });
-
-        const [queues, totalCount, scoreConfigs] = await Promise.all([
-          ctx.prisma.$queryRaw<
-            Array<{
-              id: string;
-              name: string;
-              description?: string | null;
-              scoreConfigIds: string[];
-              createdAt: string;
-              countCompletedItems: number;
-              countPendingItems: number;
-            }>
-          >(Prisma.sql`
-          SELECT
-            aq.id,
-            aq.name,
-            aq.description,
-            aq.score_config_ids AS "scoreConfigIds",
-            aq.created_at AS "createdAt",
-            COALESCE(SUM(CASE WHEN aqi.status = 'COMPLETED' THEN 1 ELSE 0 END), 0) AS "countCompletedItems",
-            COALESCE(SUM(CASE WHEN aqi.status = 'PENDING' THEN 1 ELSE 0 END), 0) AS "countPendingItems"
-          FROM
-            annotation_queues aq
-          LEFT JOIN
-            annotation_queue_items aqi ON aq.id = aqi.queue_id AND aqi.project_id = aq.project_id
-          WHERE
-            aq.project_id = ${input.projectId}
-          GROUP BY
-            aq.id, aq.name, aq.description, aq.created_at
-          ORDER BY
-            aq.created_at DESC
-          ${input.limit ? Prisma.sql`LIMIT ${input.limit}` : Prisma.empty}
-          ${input.page && input.limit ? Prisma.sql`OFFSET ${input.page * input.limit}` : Prisma.empty}
-        `),
-          ctx.prisma.annotationQueue.count({
-            where: {
-              projectId: input.projectId,
-            },
-          }),
-          ctx.prisma.scoreConfig.findMany({
-            where: {
-              projectId: input.projectId,
-            },
-            select: {
-              id: true,
-              name: true,
-              dataType: true,
-            },
-          }),
-        ]);
-
-        return {
-          totalCount,
-          queues: queues.map((queue) => ({
-            ...queue,
-            scoreConfigs: scoreConfigs.filter((config) =>
-              queue.scoreConfigIds.includes(config.id),
-            ),
-          })),
-        };
-      } catch (error) {
-        logger.error(error);
-        if (error instanceof TRPCError) {
-          throw error;
-        }
-        throw new TRPCError({
-          code: "INTERNAL_SERVER_ERROR",
-          message: "Fetching annotation queues failed.",
-        });
-      }
-    }),
-  allNamesAndIds: protectedProjectProcedure
-    .input(
-      z.object({
-        projectId: z.string(),
-      }),
-    )
-    .query(async ({ input, ctx }) => {
-      try {
-        throwIfNoEntitlement({
-          entitlement: "annotation-queues",
-          projectId: input.projectId,
-          sessionUser: ctx.session.user,
-        });
-
-        const queueNamesAndIds = await ctx.prisma.annotationQueue.findMany({
-          where: {
-            projectId: input.projectId,
-          },
-          select: {
-            id: true,
-            name: true,
-          },
-        });
-
-        return queueNamesAndIds;
-      } catch (error) {
-        logger.error(error);
-        if (error instanceof TRPCError) {
-          throw error;
-        }
-        throw new TRPCError({
-          code: "INTERNAL_SERVER_ERROR",
-          message: "Fetching annotation queues failed.",
-        });
-      }
-    }),
-  count: protectedProjectProcedure
-    .input(z.object({ projectId: z.string() }))
-    .query(async ({ input, ctx }) => {
-      try {
-        return ctx.prisma.annotationQueue.count({
-          where: { projectId: input.projectId },
-        });
-      } catch (error) {
-        logger.error(error);
-        if (error instanceof TRPCError) {
-          throw error;
-        }
-        throw new TRPCError({
-          code: "INTERNAL_SERVER_ERROR",
-          message: "Fetching annotation queue count failed.",
-        });
-      }
-    }),
-  byId: protectedProjectProcedure
-    .input(z.object({ queueId: z.string(), projectId: z.string() }))
-    .query(async ({ input, ctx }) => {
-      try {
-        throwIfNoEntitlement({
-          entitlement: "annotation-queues",
-          projectId: input.projectId,
-          sessionUser: ctx.session.user,
-        });
-
-        throwIfNoProjectAccess({
-          session: ctx.session,
-          projectId: input.projectId,
-          scope: "annotationQueues:read",
-        });
-
-        const queue = await ctx.prisma.annotationQueue.findUnique({
-          where: { id: input.queueId, projectId: input.projectId },
-        });
-
-        const configs = await ctx.prisma.scoreConfig.findMany({
-          where: {
-            projectId: input.projectId,
-            id: {
-              in: queue?.scoreConfigIds ?? [],
-            },
-          },
-        });
-
-        return {
-          ...queue,
-          scoreConfigs: filterAndValidateDbScoreConfigList(configs),
-        };
-      } catch (error) {
-        logger.error(error);
-        if (error instanceof TRPCError) {
-          throw error;
-        }
-        throw new TRPCError({
-          code: "INTERNAL_SERVER_ERROR",
-          message: "Fetching annotation queue failed.",
-        });
-      }
-    }),
-  byObjectId: protectedProjectProcedure
-    .input(
-      z.object({
-        projectId: z.string(),
-        objectId: z.string(),
-        objectType: z.nativeEnum(AnnotationQueueObjectType),
-      }),
-    )
-    .query(async ({ input, ctx }) => {
-      try {
-        throwIfNoEntitlement({
-          entitlement: "annotation-queues",
-          projectId: input.projectId,
-          sessionUser: ctx.session.user,
-        });
-
-        throwIfNoProjectAccess({
-          session: ctx.session,
-          projectId: input.projectId,
-          scope: "annotationQueues:read",
-        });
-
-        const queues = await ctx.prisma.annotationQueue.findMany({
-          where: {
-            projectId: input.projectId,
-          },
-          select: {
-            id: true,
-            name: true,
-            annotationQueueItem: {
-              where: {
-                objectId: input.objectId,
-                objectType: input.objectType,
-              },
-              select: {
-                queueId: true,
-                status: true,
-                id: true,
-              },
-            },
-          },
-        });
-
-        let totalCount = 0;
-
-        return {
-          queues: queues.map((queue) => {
-            totalCount += queue.annotationQueueItem.length;
-            return {
-              id: queue.id,
-              name: queue.name,
-              itemId: queue.annotationQueueItem[0]?.id, // Safely access the first item's id
-              status: queue.annotationQueueItem[0]?.status, // Safely access the first item's status
-              // Since there may be multiple queue items in a given queue, but with the same objectId, we select only the first one
-              // to simplify the logic and because we are only interested in the first item's details.
-            };
-          }),
-          totalCount,
-          // If the given objectId has been added to the same queue more than once, the total count will reflect that, by counting each item (incl duplicates)
-        };
-      } catch (error) {
-        logger.error(error);
-        if (error instanceof TRPCError) {
-          throw error;
-        }
-        throw new TRPCError({
-          code: "INTERNAL_SERVER_ERROR",
-          message: "Fetching annotation queue by objectId failed.",
-        });
-      }
-    }),
-  create: protectedProjectProcedure
-    .input(
-      CreateQueueData.extend({
-        projectId: z.string(),
-      }),
-    )
-    .mutation(async ({ input, ctx }) => {
-      try {
-        throwIfNoEntitlement({
-          entitlement: "annotation-queues",
-          projectId: input.projectId,
-          sessionUser: ctx.session.user,
-        });
-
-        throwIfNoProjectAccess({
-          session: ctx.session,
-          projectId: input.projectId,
-          scope: "annotationQueues:CUD",
-        });
-
-        // gate usage on cloud:hobby
-        const org = ctx.session.user.organizations.find((org) =>
-          org.projects.some((proj) => proj.id === input.projectId),
-        );
-        const plan = org?.plan ?? "oss";
-
-        if (plan === "cloud:hobby") {
-          if (
-            (await ctx.prisma.annotationQueue.count({
-              where: {
-                projectId: input.projectId,
-              },
-            })) >= 1
-          ) {
-            throw new TRPCError({
-              code: "FORBIDDEN",
-              message:
-                "Maximum number of annotation queues reached on Hobby plan.",
-            });
-          }
-        }
-
-        const existingQueue = await ctx.prisma.annotationQueue.findFirst({
-          where: {
-            projectId: input.projectId,
-            name: input.name,
-          },
-        });
-
-        if (existingQueue) {
-          throw new TRPCError({
-            code: "CONFLICT",
-            message: "A queue with this name already exists in the project",
-          });
-        }
-
-        const queue = await ctx.prisma.annotationQueue.create({
-          data: {
-            name: input.name,
-            projectId: input.projectId,
-            description: input.description,
-            scoreConfigIds: input.scoreConfigIds,
-          },
-        });
-
-        await auditLog({
-          session: ctx.session,
-          resourceType: "annotationQueue",
-          resourceId: queue.id,
-          action: "create",
-          after: queue,
-        });
-
-        return queue;
-      } catch (error) {
-        logger.error(error);
-        if (error instanceof TRPCError) {
-          throw error;
-        }
-        throw new TRPCError({
-          code: "INTERNAL_SERVER_ERROR",
-          message: "Creating annotation queue failed.",
-        });
-      }
-    }),
-  update: protectedProjectProcedure
-    .input(
-      CreateQueueData.extend({
-        projectId: z.string(),
-        queueId: z.string(),
-      }),
-    )
-    .mutation(async ({ input, ctx }) => {
-      try {
-        throwIfNoEntitlement({
-          entitlement: "annotation-queues",
-          projectId: input.projectId,
-          sessionUser: ctx.session.user,
-        });
-
-        throwIfNoProjectAccess({
-          session: ctx.session,
-          projectId: input.projectId,
-          scope: "annotationQueues:CUD",
-        });
-
-        const queue = await ctx.prisma.annotationQueue.findFirst({
-          where: {
-            id: input.queueId,
-            projectId: input.projectId,
-          },
-        });
-
-        if (!queue) {
-          throw new LangfuseNotFoundError("Queue not found in project");
-        }
-
-        const updatedQueue = await ctx.prisma.annotationQueue.update({
-          where: { id: input.queueId, projectId: input.projectId },
-          data: {
-            name: input.name,
-            description: input.description,
-            scoreConfigIds: input.scoreConfigIds,
-          },
-        });
-
-        await auditLog({
-          session: ctx.session,
-          resourceType: "annotationQueue",
-          resourceId: queue.id,
-          action: "update",
-          before: queue,
-          after: updatedQueue,
-        });
-
-        return updatedQueue;
-      } catch (error) {
-        logger.error(error);
-        if (error instanceof TRPCError) {
-          throw error;
-        }
-        throw new TRPCError({
-          code: "INTERNAL_SERVER_ERROR",
-          message: "Updating annotation queue failed.",
-        });
-      }
-    }),
-  delete: protectedProjectProcedure
-    .input(z.object({ queueId: z.string(), projectId: z.string() }))
-    .mutation(async ({ input, ctx }) => {
-      try {
-        throwIfNoEntitlement({
-          entitlement: "annotation-queues",
-          projectId: input.projectId,
-          sessionUser: ctx.session.user,
-        });
-
-        throwIfNoProjectAccess({
-          session: ctx.session,
-          projectId: input.projectId,
-          scope: "annotationQueues:CUD",
-        });
-        const queue = await ctx.prisma.annotationQueue.delete({
-          where: { id: input.queueId, projectId: input.projectId },
-        });
-
-        await auditLog({
-          session: ctx.session,
-          resourceType: "annotationQueue",
-          resourceId: queue.id,
-          action: "delete",
-          before: queue,
-        });
-
-        return queue;
-      } catch (error) {
-        logger.error(error);
-        if (error instanceof TRPCError) {
-          throw error;
-        }
-        throw new TRPCError({
-          code: "INTERNAL_SERVER_ERROR",
-          message: "Deleting annotation queue failed.",
-        });
-      }
-    }),
-  fetchAndLockNext: protectedProjectProcedure
-    .input(
-      z.object({
-        queueId: z.string(),
-        projectId: z.string(),
-        seenItemIds: z.array(z.string()),
-      }),
-    )
-    .mutation(async ({ input, ctx }) => {
-      try {
-        throwIfNoEntitlement({
-          entitlement: "annotation-queues",
-          projectId: input.projectId,
-          sessionUser: ctx.session.user,
-        });
-
-        throwIfNoProjectAccess({
-          session: ctx.session,
-          projectId: input.projectId,
-          scope: "annotationQueues:CUD",
-        });
-
-        const now = new Date();
-        const fiveMinutesAgo = new Date(now.getTime() - 5 * 60 * 1000);
-
-        const item = await ctx.prisma.annotationQueueItem.findFirst({
-          where: {
-            queueId: input.queueId,
-            projectId: input.projectId,
-            status: AnnotationQueueStatus.PENDING,
-            OR: [
-              { lockedAt: null },
-              { lockedAt: { lt: fiveMinutesAgo } },
-              { lockedByUserId: ctx.session.user.id },
-            ],
-            NOT: {
-              id: { in: input.seenItemIds },
-            },
-          },
-          orderBy: {
-            createdAt: "asc",
-          },
-        });
-
-        // Expected behavior, non-error case: all items have been seen AND/OR completed, no more unseen pending items
-        if (!item) return null;
-
-        const updatedItem = await ctx.prisma.annotationQueueItem.update({
-          where: {
-            id: item.id,
-            projectId: input.projectId,
-          },
-          data: {
-            lockedAt: now,
-            lockedByUserId: ctx.session.user.id,
-          },
-        });
-
-        const inflatedUpdatedItem = {
-          ...updatedItem,
-          lockedByUser: { name: ctx.session.user.name },
-        };
-
-        if (item.objectType === AnnotationQueueObjectType.OBSERVATION) {
-          const clickhouseObservation = await getObservationById(
-            item.objectId,
-            input.projectId,
-          );
-          return {
-            ...inflatedUpdatedItem,
-            parentTraceId: clickhouseObservation?.traceId,
-          };
-        }
-
-        return inflatedUpdatedItem;
-      } catch (error) {
-        logger.error(error);
-        if (error instanceof TRPCError) {
-          throw error;
-        }
-        throw new TRPCError({
-          code: "INTERNAL_SERVER_ERROR",
-          message: "Fetching and locking next annotation queue item failed.",
-        });
-      }
-    }),
-});
diff --git a/web/src/ee/features/audit-log-viewer/AuditLogsSettingsPage.tsx b/web/src/ee/features/audit-log-viewer/AuditLogsSettingsPage.tsx
deleted file mode 100644
index 0f54b32..0000000
--- a/web/src/ee/features/audit-log-viewer/AuditLogsSettingsPage.tsx
+++ /dev/null
@@ -1,41 +0,0 @@
-import Header from "@/src/components/layouts/header";
-import { Alert, AlertDescription, AlertTitle } from "@/src/components/ui/alert";
-import { AuditLogsTable } from "@/src/ee/features/audit-log-viewer/AuditLogsTable";
-import { useHasEntitlement } from "@/src/features/entitlements/hooks";
-import { useHasProjectAccess } from "@/src/features/rbac/utils/checkProjectAccess";
-
-export function AuditLogsSettingsPage(props: { projectId: string }) {
-  const hasAccess = useHasProjectAccess({
-    projectId: props.projectId,
-    scope: "auditLogs:read",
-  });
-  const hasEntitlement = useHasEntitlement("audit-logs");
-
-  const body = !hasEntitlement ? (
-    <p className="text-sm text-muted-foreground">
-      Audit logs are an Enterprise feature. Upgrade your plan to track all
-      changes made to your project.
-    </p>
-  ) : !hasAccess ? (
-    <Alert>
-      <AlertTitle>Access Denied</AlertTitle>
-      <AlertDescription>
-        Contact your project administrator to request access.
-      </AlertDescription>
-    </Alert>
-  ) : (
-    <AuditLogsTable projectId={props.projectId} />
-  );
-
-  return (
-    <>
-      <Header title="Audit Logs" />
-      <p className="mb-2 text-sm text-muted-foreground">
-        Track who changed what in your project and when. Monitor settings,
-        configurations, and data changes over time. Reach out to the Langfuse
-        team if you require more detailed/filtered audit logs.
-      </p>
-      {body}
-    </>
-  );
-}
diff --git a/web/src/ee/features/audit-log-viewer/AuditLogsTable.tsx b/web/src/ee/features/audit-log-viewer/AuditLogsTable.tsx
deleted file mode 100644
index c85a7e6..0000000
--- a/web/src/ee/features/audit-log-viewer/AuditLogsTable.tsx
+++ /dev/null
@@ -1,156 +0,0 @@
-import { DataTable } from "@/src/components/table/data-table";
-import { type LangfuseColumnDef } from "@/src/components/table/types";
-import { api } from "@/src/utils/api";
-import { useQueryParams, withDefault, NumberParam } from "use-query-params";
-import { IOTableCell } from "@/src/components/ui/CodeJsonViewer";
-import {
-  Avatar,
-  AvatarFallback,
-  AvatarImage,
-} from "@/src/components/ui/avatar";
-import { cn } from "@/src/utils/tailwind";
-import { useRowHeightLocalStorage } from "@/src/components/table/data-table-row-height-switch";
-import { DataTableToolbar } from "@/src/components/table/data-table-toolbar";
-import { type RouterOutputs } from "@/src/utils/api";
-import { SettingsTableCard } from "@/src/components/layouts/settings-table-card";
-
-type AuditLogRow = RouterOutputs["auditLogs"]["all"]["data"][number];
-
-export function AuditLogsTable(props: { projectId: string }) {
-  const [paginationState, setPaginationState] = useQueryParams({
-    pageIndex: withDefault(NumberParam, 0),
-    pageSize: withDefault(NumberParam, 50),
-  });
-
-  const auditLogs = api.auditLogs.all.useQuery({
-    projectId: props.projectId,
-    page: paginationState.pageIndex,
-    limit: paginationState.pageSize,
-  });
-
-  const [rowHeight, setRowHeight] = useRowHeightLocalStorage("auditLogs", "s");
-
-  const columns: LangfuseColumnDef<AuditLogRow>[] = [
-    {
-      accessorKey: "createdAt",
-      header: "Time",
-      cell: (row) => {
-        const date = row.getValue() as Date;
-        return date.toLocaleString();
-      },
-    },
-    {
-      accessorKey: "actor",
-      header: "Actor",
-      headerTooltip: {
-        description: "The actor within Langfuse who performed the action.",
-      },
-      cell: (row) => {
-        const actor = row.getValue() as AuditLogRow["actor"];
-        if (actor.type === "USER") {
-          const user = actor.body;
-          return (
-            <div className="flex items-center gap-2">
-              <Avatar className="h-6 w-6">
-                {user?.image && (
-                  <AvatarImage src={user.image} alt={user?.name ?? "User"} />
-                )}
-                <AvatarFallback>
-                  {user?.name?.charAt(0) ?? user?.email?.charAt(0) ?? "U"}
-                </AvatarFallback>
-              </Avatar>
-              <span
-                className={cn(
-                  "text-sm",
-                  !user?.name && "text-muted-foreground",
-                )}
-              >
-                {user?.name ?? user?.email ?? user.id}
-              </span>
-            </div>
-          );
-        }
-
-        if (actor.type === "API_KEY") {
-          const apiKey = actor.body;
-          return (
-            <div className="flex items-center gap-2">
-              <span className="text-sm">{apiKey?.publicKey ?? apiKey?.id}</span>
-            </div>
-          );
-        }
-
-        return null;
-      },
-    },
-    {
-      accessorKey: "resourceType",
-      header: "Resource Type",
-    },
-    {
-      accessorKey: "resourceId",
-      header: "Resource ID",
-    },
-    {
-      accessorKey: "action",
-      header: "Action",
-    },
-    {
-      accessorKey: "before",
-      header: "Before",
-      size: 300,
-      cell: (row) => {
-        const value = row.getValue() as string | null;
-        if (!value) return null;
-        return <IOTableCell data={value} singleLine={rowHeight === "s"} />;
-      },
-    },
-    {
-      accessorKey: "after",
-      header: "After",
-      size: 300,
-      cell: (row) => {
-        const value = row.getValue() as string | null;
-        if (!value) return null;
-        return <IOTableCell data={value} singleLine={rowHeight === "s"} />;
-      },
-    },
-  ];
-
-  return (
-    <>
-      <DataTableToolbar
-        columns={columns}
-        rowHeight={rowHeight}
-        setRowHeight={setRowHeight}
-        className="px-0"
-      />
-      <SettingsTableCard>
-        <DataTable
-          columns={columns}
-          data={
-            auditLogs.isLoading
-              ? { isLoading: true, isError: false }
-              : auditLogs.isError
-                ? {
-                    isLoading: false,
-                    isError: true,
-                    error: auditLogs.error.message,
-                  }
-                : {
-                    isLoading: false,
-                    isError: false,
-                    data: auditLogs.data.data,
-                  }
-          }
-          pagination={{
-            totalCount: auditLogs.data?.totalCount ?? 0,
-            onChange: setPaginationState,
-            state: paginationState,
-          }}
-          rowHeight={rowHeight}
-        />
-      </SettingsTableCard>
-    </>
-  );
-}
diff --git a/web/src/ee/features/billing/README.md b/web/src/ee/features/billing/README.md
deleted file mode 100644
index 9834b50..0000000
--- a/web/src/ee/features/billing/README.md
+++ /dev/null
@@ -1,61 +0,0 @@
-# Billing
-
-## Overview
-
-This page outlines our integration with **Stripe billing**. The integration supports **usage-based billing** for each organization and project within our product.
-
-## Key Concepts
-
-- **Organizations**: Entities within the product that can have multiple projects.
-- **Projects**: Sub-entities under organizations where usage is tracked.
-- **Observations**: Units of usage, essentially API calls, tracked at the project level and aggregated for billing on the organization level.
-
-## Implementation Details
-
-### Checkout and Subscription Management
-
-1. **Upgrade Process**:
-
-   - Organizations can upgrade their plan via the **billing settings**.
-   - On the **select plans popup**, only product listed in `stripeProducts.ts` are included.
-   - A new **Stripe Checkout session** is created via the API.
-     - The **organization ID** is passed to Stripe as a reference.
-     - The default price in stripe for each product is used.
-
-2. **Stripe WebHooks**:
-
-   - **Checkout Session Completion**:
-     - On completion, the `customerID` and `activeSubscriptionId` are added to the cloud config of the organization's object.
-     - Linked based on the stripe client reference (`stripeClientReference.ts`).
-   - **Subscription Changes**:
-     - On creation, update, or deletion of a subscription, the **active product ID** is updated in the cloud config of the organization which includes the `activeSubscriptionId`.
-
-3. **Cloud Config**:
-   - Contains the **customer ID**, **activeSubscriptionId**, and **active product ID**.
-   - All entitlements within the application are based on the **active product ID** and it's mapping to `Plan` in Langfuse (`stripeProducts.ts`).
-   - If a `plan` is included in the cloud config (legacy), no new subscription can be created for the organization. Organizations need to be migrated to the new system.
-
-### Usage-Based Pricing
-
-1. **Usage Meter in Stripe**:
-
-   - A meter with the ID `trace_observations` is used to track usage.
-   - This meter tracks observations at the _customer_ level within Stripe.
-
-2. **Hourly Job**:
-
-   - An hourly job runs in the **worker container** (`cloudUsageMeteringQueue`).
-   - Logs the number of observations within the last hour to Stripe for all organizations which include a customer ID in the cloud config.
-   - The job is managed via
-     - BullMQ repeatable jobs: trigger run each hour + potential backfill job on startup of worker container
-     - `cron_jobs` postgres table to track the last run time of the job and to prevent multiple instances of the job running.
-
-## Webhook development
-
-You can test webhooks via the `stripe` CLI. Step by step guide: https://dashboard.stripe.com/test/webhooks/create?endpoint_location=local
-
-1. `stripe login`
-2. `stripe listen --forward-to localhost:3000/api/billing/stripe-webhook`
-3. Add the API key from the Stripe test environment and the webhook signing secret from the CLI to the `.env` file.
-
-Upgrade/downgrade projects via the Langfuse billing settings.
diff --git a/web/src/ee/features/billing/components/BillingSettings.tsx b/web/src/ee/features/billing/components/BillingSettings.tsx
deleted file mode 100644
index 454937d..0000000
--- a/web/src/ee/features/billing/components/BillingSettings.tsx
+++ /dev/null
@@ -1,367 +0,0 @@
-// Langfuse Cloud only
-
-import { Button } from "@/src/components/ui/button";
-import { api } from "@/src/utils/api";
-import { Flex, MarkerBar, Metric, Text } from "@tremor/react";
-import Link from "next/link";
-import Header from "@/src/components/layouts/header";
-import { useQueryOrganization } from "@/src/features/organizations/hooks";
-import { Card } from "@/src/components/ui/card";
-import { numberFormatter, compactNumberFormatter } from "@/src/utils/numbers";
-import { useHasEntitlement } from "@/src/features/entitlements/hooks";
-import { type Plan, planLabels } from "@langfuse/shared";
-import { useRouter } from "next/router";
-import {
-  chatAvailable,
-  sendUserChatMessage,
-} from "@/src/features/support-chat/chat";
-import { env } from "@/src/env.mjs";
-import { useHasOrganizationAccess } from "@/src/features/rbac/utils/checkOrganizationAccess";
-import { Alert, AlertDescription, AlertTitle } from "@/src/components/ui/alert";
-import { MAX_EVENTS_FREE_PLAN } from "@/src/ee/features/billing/constants";
-import {
-  Dialog,
-  DialogClose,
-  DialogContent,
-  DialogFooter,
-  DialogDescription,
-  DialogHeader,
-  DialogTitle,
-  DialogTrigger,
-} from "@/src/components/ui/dialog";
-import { usePostHogClientCapture } from "@/src/features/posthog-analytics/usePostHogClientCapture";
-import { stripeProducts } from "@/src/ee/features/billing/utils/stripeProducts";
-import { toast } from "sonner";
-import { ActionButton } from "@/src/components/ActionButton";
-import { useState } from "react";
-
-export const BillingSettings = () => {
-  const router = useRouter();
-  const orgId = router.query.organizationId as string | undefined;
-  const hasAccess = useHasOrganizationAccess({
-    organizationId: orgId,
-    scope: "langfuseCloudBilling:CRUD",
-  });
-
-  const entitled = useHasEntitlement("cloud-billing");
-  if (!entitled) return null;
-
-  if (!hasAccess)
-    return (
-      <Alert>
-        <AlertTitle>Access Denied</AlertTitle>
-        <AlertDescription>
-          You do not have permission to view the billing settings of this
-          organization.
-        </AlertDescription>
-      </Alert>
-    );
-  return (
-    <div>
-      <Header title="Usage & Billing" />
-      <OrganizationUsageChart />
-    </div>
-  );
-};
-
-const OrganizationUsageChart = () => {
-  const organization = useQueryOrganization();
-  const usage = api.cloudBilling.getUsage.useQuery(
-    {
-      orgId: organization?.id as string,
-    },
-    {
-      enabled: organization !== undefined,
-      trpc: {
-        context: {
-          skipBatch: true,
-        },
-      },
-    },
-  );
-  const hobbyPlanLimit =
-    organization?.cloudConfig?.monthlyObservationLimit ?? MAX_EVENTS_FREE_PLAN;
-  const plan: Plan = organization?.plan ?? "cloud:hobby";
-  const planLabel = planLabels[plan];
-  const usageType = usage.data?.usageType
-    ? usage.data.usageType.charAt(0).toUpperCase() +
-      usage.data.usageType.slice(1)
-    : "Events";
-
-  return (
-    <div>
-      <Card className="p-3">
-        {usage.data !== undefined ? (
-          <>
-            <Text>
-              {usage.data.billingPeriod
-                ? `${usageType} in current billing period`
-                : `${usageType} / last 30d`}
-            </Text>
-            <Metric>{numberFormatter(usage.data.usageCount, 0)}</Metric>
-            {plan === "cloud:hobby" && (
-              <>
-                <Flex className="mt-4">
-                  <Text>{`${numberFormatter((usage.data.usageCount / hobbyPlanLimit) * 100)}%`}</Text>
-                  <Text>
-                    Plan limit: {compactNumberFormatter(hobbyPlanLimit)}
-                  </Text>
-                </Flex>
-                <MarkerBar
-                  value={Math.min(
-                    (usage.data.usageCount / hobbyPlanLimit) * 100,
-                    100,
-                  )}
-                  className="mt-3"
-                />
-              </>
-            )}
-          </>
-        ) : (
-          <span className="text-sm text-muted-foreground">
-            Loading (might take a moment) ...
-          </span>
-        )}
-      </Card>
-      <div className="mt-2 flex flex-col gap-1 text-sm text-muted-foreground">
-        <p>Current plan: {planLabel}</p>
-        {usage.data?.billingPeriod && (
-          <p>
-            {`Billing period: ${usage.data.billingPeriod.start.toLocaleDateString()} - ${usage.data.billingPeriod.end.toLocaleDateString()}`}
-          </p>
-        )}
-        {usage.data?.upcomingInvoice && (
-          <p>
-            {`Next invoice (current usage): ${usage.data.upcomingInvoice.usdAmount} USD`}
-          </p>
-        )}
-      </div>
-      <div className="mt-4 flex flex-row items-center gap-2">
-        <BillingPortalOrPricingPageButton />
-        <Button variant="secondary" asChild>
-          <Link href={"https://langfuse.com/pricing"} target="_blank">
-            Compare plans
-          </Link>
-        </Button>
-      </div>
-    </div>
-  );
-};
-
-const BillingPortalOrPricingPageButton = () => {
-  const organization = useQueryOrganization();
-  const router = useRouter();
-  const capture = usePostHogClientCapture();
-  const billingPortalUrl = api.cloudBilling.getStripeCustomerPortalUrl.useQuery(
-    {
-      orgId: organization?.id as string,
-    },
-    {
-      enabled: organization !== undefined,
-      refetchOnMount: false,
-      refetchOnReconnect: false,
-      refetchOnWindowFocus: false,
-    },
-  );
-
-  const [processingPlanId, setProcessingPlanId] = useState<string | null>(null);
-
-  const mutCreateCheckoutSession =
-    api.cloudBilling.createStripeCheckoutSession.useMutation({
-      onSuccess: (url) => {
-        router.push(url);
-        setProcessingPlanId(null);
-      },
-      onError: () => {
-        setProcessingPlanId(null);
-      },
-    });
-  const mutChangePlan =
-    api.cloudBilling.changeStripeSubscriptionProduct.useMutation({
-      onSuccess: () => {
-        toast.success("Plan changed successfully");
-        setProcessingPlanId(null);
-        // wait 1 second before reloading
-        setTimeout(() => {
-          window.location.reload();
-        }, 500);
-      },
-      onError: () => {
-        setProcessingPlanId(null);
-      },
-    });
-
-  // Do not show checkout or customer portal if manual plan is set in cloud config
-  if (organization?.cloudConfig?.plan) {
-    if (chatAvailable)
-      return (
-        <Button
-          variant="secondary"
-          onClick={() =>
-            sendUserChatMessage(
-              `I'd like to change my current plan, region ${env.NEXT_PUBLIC_LANGFUSE_CLOUD_REGION}, organization id ${organization.id}`,
-            )
-          }
-        >
-          Change plan
-        </Button>
-      );
-    else return null;
-  }
-
-  const switchPlan = (
-    <Dialog
-      onOpenChange={(open) => {
-        if (open) {
-          capture("project_settings:pricing_dialog_opened");
-        }
-      }}
-    >
-      <DialogTrigger asChild>
-        <Button>Change plan</Button>
-      </DialogTrigger>
-      <DialogContent className="max-w-5xl">
-        <DialogHeader>
-          <Header
-            title="Plans"
-            actionButtons={
-              <Button variant="secondary" asChild>
-                <Link href="https://langfuse.com/pricing" target="_blank">
-                  Comparison of plans ↗
-                </Link>
-              </Button>
-            }
-          />
-        </DialogHeader>
-        <div className="mb-3 grid grid-cols-1 gap-3 md:grid-cols-3">
-          {stripeProducts
-            .filter((product) => Boolean(product.checkout))
-            .map((product) => (
-              <div
-                key={product.stripeProductId}
-                className="relative flex flex-col rounded-xl border bg-card p-4 shadow-sm transition-all hover:shadow-md"
-              >
-                <div className="mb-4">
-                  <h3 className="text-2xl font-bold">
-                    {product.checkout?.title}
-                  </h3>
-                  <div className="mt-4 space-y-1">
-                    <div className="text-2xl font-bold text-primary">
-                      {product.checkout?.price}
-                    </div>
-                    <div className="text-sm text-muted-foreground">
-                      + {product.checkout?.usagePrice}
-                    </div>
-                  </div>
-                </div>
-                <div className="mb-4 text-sm text-muted-foreground">
-                  {product.checkout?.description}
-                </div>
-                <div className="space-y-2">
-                  <div className="text-sm font-medium">Main features:</div>
-                  <ul className="list-inside list-disc space-y-1 text-sm text-muted-foreground">
-                    {product.checkout?.mainFeatures.map((feature, index) => (
-                      <li key={index}>{feature}</li>
-                    ))}
-                  </ul>
-                </div>
-                <Link
-                  href="https://langfuse.com/pricing"
-                  target="_blank"
-                  className="mt-auto block py-4 text-sm text-muted-foreground hover:text-foreground"
-                >
-                  Learn more about plan →
-                </Link>
-                {organization?.cloudConfig?.stripe?.activeProductId ? (
-                  // Change plan
-                  <Dialog>
-                    <DialogTrigger asChild>
-                      <Button
-                        disabled={
-                          organization?.cloudConfig?.stripe?.activeProductId ===
-                          product.stripeProductId
-                        }
-                        className="w-full"
-                      >
-                        {organization?.cloudConfig?.stripe?.activeProductId ===
-                        product.stripeProductId
-                          ? "Current plan"
-                          : "Change plan"}
-                      </Button>
-                    </DialogTrigger>
-                    <DialogContent>
-                      <DialogHeader>
-                        <DialogTitle>
-                          Confirm Change:{" "}
-                          {planLabels[organization?.plan ?? "cloud:hobby"]} →{" "}
-                          {product.checkout?.title}
-                        </DialogTitle>
-                        <DialogDescription className="pt-2">
-                          This will immediately generate an invoice for any
-                          usage on your current plan. Your new plan and billing
-                          period will start today. Are you sure you want to
-                          continue?
-                        </DialogDescription>
-                      </DialogHeader>
-                      <DialogFooter>
-                        <DialogClose asChild>
-                          <Button variant="secondary">Cancel</Button>
-                        </DialogClose>
-                        <ActionButton
-                          onClick={() => {
-                            if (organization) {
-                              setProcessingPlanId(product.stripeProductId);
-                              mutChangePlan.mutate({
-                                orgId: organization.id,
-                                stripeProductId: product.stripeProductId,
-                              });
-                            }
-                          }}
-                          loading={processingPlanId === product.stripeProductId}
-                        >
-                          Confirm
-                        </ActionButton>
-                      </DialogFooter>
-                    </DialogContent>
-                  </Dialog>
-                ) : (
-                  // Upgrade, no plan yet
-                  <ActionButton
-                    onClick={() => {
-                      if (organization) {
-                        setProcessingPlanId(product.stripeProductId);
-                        mutCreateCheckoutSession.mutate({
-                          orgId: organization.id,
-                          stripeProductId: product.stripeProductId,
-                        });
-                      }
-                    }}
-                    disabled={
-                      organization?.cloudConfig?.stripe?.activeProductId ===
-                      product.stripeProductId
-                    }
-                    className="w-full"
-                    loading={processingPlanId === product.stripeProductId}
-                  >
-                    Select plan
-                  </ActionButton>
-                )}
-              </div>
-            ))}
-        </div>
-      </DialogContent>
-    </Dialog>
-  );
-
-  // Show pricing page button
-  return (
-    <>
-      {switchPlan}
-      {billingPortalUrl.data && (
-        <Button asChild>
-          <Link href={billingPortalUrl.data}>Billing portal</Link>
-        </Button>
-      )}
-    </>
-  );
-};
diff --git a/web/src/ee/features/billing/components/SupportOrUpgradePage.tsx b/web/src/ee/features/billing/components/SupportOrUpgradePage.tsx
deleted file mode 100644
index edb5a76..0000000
--- a/web/src/ee/features/billing/components/SupportOrUpgradePage.tsx
+++ /dev/null
@@ -1,22 +0,0 @@
-import { AlertCircle } from "lucide-react";
-import { Alert, AlertTitle, AlertDescription } from "@/src/components/ui/alert";
-
-export const SupportOrUpgradePage = () => {
-  return (
-    <div className="flex h-full w-full items-center justify-center p-6">
-      <div className="w-full max-w-md">
-        <Alert>
-          <AlertCircle className="h-4 w-4" />
-          <AlertTitle>Access Restricted</AlertTitle>
-          <AlertDescription>
-            <p className="mb-2">This feature requires additional permissions</p>
-            <p>
-              Contact your system/project administrator for access or upgrade
-              your plan. Need help? Reach out to support.
-            </p>
-          </AlertDescription>
-        </Alert>
-      </div>
-    </div>
-  );
-};
diff --git a/web/src/ee/features/billing/components/UsageTracker.tsx b/web/src/ee/features/billing/components/UsageTracker.tsx
deleted file mode 100644
index 121efc1..0000000
--- a/web/src/ee/features/billing/components/UsageTracker.tsx
+++ /dev/null
@@ -1,74 +0,0 @@
-import { api } from "@/src/utils/api";
-import { useQueryProjectOrOrganization } from "@/src/features/projects/hooks";
-import { useHasOrganizationAccess } from "@/src/features/rbac/utils/checkOrganizationAccess";
-import { MAX_EVENTS_FREE_PLAN } from "@/src/ee/features/billing/constants";
-import { useHasEntitlement, usePlan } from "@/src/features/entitlements/hooks";
-import {
-  Card,
-  CardContent,
-  CardDescription,
-  CardHeader,
-  CardTitle,
-} from "@/src/components/ui/card";
-import { ActionButton } from "@/src/components/ActionButton";
-
-export const UsageTracker = () => {
-  const { organization } = useQueryProjectOrOrganization();
-  const hasEntitlement = useHasEntitlement("cloud-billing");
-  const plan = usePlan();
-  const hasAccess = useHasOrganizationAccess({
-    organizationId: organization?.id,
-    scope: "langfuseCloudBilling:CRUD",
-  });
-
-  const usageQuery = api.cloudBilling.getUsage.useQuery(
-    {
-      orgId: organization?.id!,
-    },
-    {
-      enabled: !!organization && hasAccess && hasEntitlement,
-      refetchOnMount: false,
-      refetchOnReconnect: false,
-      refetchOnWindowFocus: false,
-      staleTime: 60 * 60 * 1000,
-    },
-  );
-
-  if (
-    usageQuery.isLoading ||
-    !usageQuery.data ||
-    !hasEntitlement ||
-    plan !== "cloud:hobby"
-  ) {
-    return null;
-  }
-
-  const usage = usageQuery.data.usageCount || 0;
-  const usageType = usageQuery.data.usageType;
-  const percentage = (usage / MAX_EVENTS_FREE_PLAN) * 100;
-
-  if (percentage < 90) {
-    return null;
-  }
-
-  return (
-    <Card className="relative max-h-48 overflow-hidden rounded-md bg-opacity-50 shadow-none group-data-[collapsible=icon]:hidden">
-      <CardHeader className="p-4 pb-0">
-        <CardTitle className="text-sm">Hobby Plan Usage Limit</CardTitle>
-        <CardDescription>
-          {`${usage.toLocaleString()} / ${MAX_EVENTS_FREE_PLAN.toLocaleString()} (${percentage.toFixed(0)}%) ${usageType} in last 30 days. Please upgrade your plan to avoid interruptions.`}
-        </CardDescription>
-      </CardHeader>
-      <CardContent className="p-4 pt-2">
-        <ActionButton
-          variant="secondary"
-          size="sm"
-          href={`/organization/${organization?.id}/settings/billing`}
-          hasAccess={hasAccess}
-        >
-          Upgrade plan
-        </ActionButton>
-      </CardContent>
-    </Card>
-  );
-};
diff --git a/web/src/ee/features/billing/constants.ts b/web/src/ee/features/billing/constants.ts
deleted file mode 100644
index 88b67ff..0000000
--- a/web/src/ee/features/billing/constants.ts
+++ /dev/null
@@ -1 +0,0 @@
-export const MAX_EVENTS_FREE_PLAN = 50_000;
diff --git a/web/src/ee/features/billing/server/cloudBillingRouter.ts b/web/src/ee/features/billing/server/cloudBillingRouter.ts
deleted file mode 100644
index f83b413..0000000
--- a/web/src/ee/features/billing/server/cloudBillingRouter.ts
+++ /dev/null
@@ -1,451 +0,0 @@
-import { createStripeClientReference } from "@/src/ee/features/billing/stripeClientReference";
-import { stripeClient } from "@/src/ee/features/billing/utils/stripe";
-import { stripeProducts } from "@/src/ee/features/billing/utils/stripeProducts";
-import { env } from "@/src/env.mjs";
-import { throwIfNoEntitlement } from "@/src/features/entitlements/server/hasEntitlement";
-import { parseDbOrg } from "@langfuse/shared";
-import {
-  createTRPCRouter,
-  protectedOrganizationProcedure,
-} from "@/src/server/api/trpc";
-import { TRPCError } from "@trpc/server";
-import * as z from "zod";
-import { throwIfNoOrganizationAccess } from "@/src/features/rbac/utils/checkOrganizationAccess";
-import { auditLog } from "@/src/features/audit-logs/auditLog";
-import {
-  getObservationCountOfProjectsSinceCreationDate,
-  getScoreCountOfProjectsSinceCreationDate,
-  getTraceCountOfProjectsSinceCreationDate,
-  logger,
-} from "@langfuse/shared/src/server";
-
-export const cloudBillingRouter = createTRPCRouter({
-  createStripeCheckoutSession: protectedOrganizationProcedure
-    .input(
-      z.object({
-        orgId: z.string(),
-        stripeProductId: z.string(),
-      }),
-    )
-    .mutation(async ({ input, ctx }) => {
-      throwIfNoOrganizationAccess({
-        organizationId: input.orgId,
-        scope: "langfuseCloudBilling:CRUD",
-        session: ctx.session,
-      });
-      throwIfNoEntitlement({
-        entitlement: "cloud-billing",
-        sessionUser: ctx.session.user,
-        orgId: input.orgId,
-      });
-
-      const org = await ctx.prisma.organization.findUnique({
-        where: {
-          id: input.orgId,
-        },
-      });
-      if (!org) {
-        throw new TRPCError({
-          code: "INTERNAL_SERVER_ERROR",
-          message: "Organization not found",
-        });
-      }
-
-      const parsedOrg = parseDbOrg(org);
-      if (parsedOrg.cloudConfig?.plan)
-        throw new TRPCError({
-          code: "INTERNAL_SERVER_ERROR",
-          message:
-            "Cannot initialize stripe checkout for orgs that have a manual/legacy plan",
-        });
-
-      if (!stripeClient)
-        throw new TRPCError({
-          code: "INTERNAL_SERVER_ERROR",
-          message: "Stripe client not initialized",
-        });
-
-      const stripeCustomerId = parsedOrg.cloudConfig?.stripe?.customerId;
-      const stripeActiveSubscriptionId =
-        parsedOrg.cloudConfig?.stripe?.activeSubscriptionId;
-      if (stripeActiveSubscriptionId) {
-        // If the org has a customer ID, do not return checkout options, should use the billing portal instead
-        throw new TRPCError({
-          code: "INTERNAL_SERVER_ERROR",
-          message: "Organization already has an active subscription",
-        });
-      }
-
-      if (
-        !stripeProducts.some(
-          (product) =>
-            Boolean(product.checkout) &&
-            product.stripeProductId === input.stripeProductId,
-        )
-      )
-        throw new TRPCError({
-          code: "INTERNAL_SERVER_ERROR",
-          message: "Invalid stripe product id",
-        });
-
-      const product = await stripeClient.products.retrieve(
-        input.stripeProductId,
-      );
-      if (!product.default_price) {
-        throw new TRPCError({
-          code: "INTERNAL_SERVER_ERROR",
-          message: "Product does not have a default price in Stripe",
-        });
-      }
-
-      const returnUrl = `${env.NEXTAUTH_URL}/organization/${input.orgId}/settings`;
-      const session = await stripeClient.checkout.sessions.create({
-        customer: stripeCustomerId,
-        line_items: [
-          {
-            price: product.default_price as string,
-          },
-        ],
-        client_reference_id:
-          createStripeClientReference(input.orgId) ?? undefined,
-        allow_promotion_codes: true,
-        tax_id_collection: {
-          enabled: true,
-        },
-        automatic_tax: {
-          enabled: true,
-        },
-        consent_collection: {
-          terms_of_service: "required",
-        },
-        ...(stripeCustomerId
-          ? {
-              customer_update: {
-                name: "auto",
-                address: "auto",
-              },
-            }
-          : {}),
-        billing_address_collection: "required",
-        success_url: returnUrl,
-        cancel_url: returnUrl,
-        mode: "subscription",
-        metadata: {
-          orgId: input.orgId,
-          cloudRegion: env.NEXT_PUBLIC_LANGFUSE_CLOUD_REGION ?? null,
-        },
-      });
-
-      if (!session.url)
-        throw new TRPCError({
-          code: "INTERNAL_SERVER_ERROR",
-          message: "Failed to create checkout session",
-        });
-
-      auditLog({
-        session: ctx.session,
-        orgId: input.orgId,
-        resourceType: "stripeCheckoutSession",
-        resourceId: session.id,
-        action: "create",
-      });
-
-      return session.url;
-    }),
-  changeStripeSubscriptionProduct: protectedOrganizationProcedure
-    .input(
-      z.object({
-        orgId: z.string(),
-        stripeProductId: z.string(),
-      }),
-    )
-    .mutation(async ({ input, ctx }) => {
-      throwIfNoOrganizationAccess({
-        organizationId: input.orgId,
-        scope: "langfuseCloudBilling:CRUD",
-        session: ctx.session,
-      });
-      throwIfNoEntitlement({
-        entitlement: "cloud-billing",
-        sessionUser: ctx.session.user,
-        orgId: input.orgId,
-      });
-
-      // check that product is valid
-      if (
-        !stripeProducts
-          .filter((i) => Boolean(i.checkout))
-          .map((i) => i.stripeProductId)
-          .includes(input.stripeProductId)
-      )
-        throw new TRPCError({
-          code: "INTERNAL_SERVER_ERROR",
-          message: "Invalid stripe product id, product not available",
-        });
-
-      const org = await ctx.prisma.organization.findUnique({
-        where: {
-          id: input.orgId,
-        },
-      });
-      if (!org) {
-        throw new TRPCError({
-          code: "INTERNAL_SERVER_ERROR",
-          message: "Organization not found",
-        });
-      }
-
-      const parsedOrg = parseDbOrg(org);
-      if (parsedOrg.cloudConfig?.plan)
-        throw new TRPCError({
-          code: "INTERNAL_SERVER_ERROR",
-          message: "Cannot change plan for orgs that have a manual/legacy plan",
-        });
-
-      const stripeSubscriptionId =
-        parsedOrg.cloudConfig?.stripe?.activeSubscriptionId;
-
-      if (!stripeSubscriptionId)
-        throw new TRPCError({
-          code: "INTERNAL_SERVER_ERROR",
-          message: "Organization does not have an active subscription",
-        });
-
-      if (!stripeClient)
-        throw new TRPCError({
-          code: "INTERNAL_SERVER_ERROR",
-          message: "Stripe client not initialized",
-        });
-
-      const subscription =
-        await stripeClient.subscriptions.retrieve(stripeSubscriptionId);
-
-      if (
-        ["canceled", "paused", "incomplete", "incomplete_expired"].includes(
-          subscription.status,
-        )
-      )
-        throw new TRPCError({
-          code: "INTERNAL_SERVER_ERROR",
-          message:
-            "Subscription is not active, current status: " +
-            subscription.status,
-        });
-
-      if (subscription.items.data.length !== 1)
-        throw new TRPCError({
-          code: "INTERNAL_SERVER_ERROR",
-          message: "Subscription has multiple items",
-        });
-
-      const item = subscription.items.data[0];
-
-      if (
-        !stripeProducts
-          .map((i) => i.stripeProductId)
-          .includes(item.price.product as string)
-      )
-        throw new TRPCError({
-          code: "INTERNAL_SERVER_ERROR",
-          message: "Current subscription product is not a valid product",
-        });
-
-      const newProduct = await stripeClient.products.retrieve(
-        input.stripeProductId,
-      );
-      if (!newProduct.default_price)
-        throw new TRPCError({
-          code: "INTERNAL_SERVER_ERROR",
-          message: "New product does not have a default price in Stripe",
-        });
-
-      await stripeClient.subscriptions.update(stripeSubscriptionId, {
-        items: [
-          // remove current product from subscription
-          {
-            id: item.id,
-            deleted: true,
-          },
-          // add new product to subscription
-          {
-            price: newProduct.default_price as string,
-          },
-        ],
-        // reset billing cycle which causes immediate invoice for existing plan
-        billing_cycle_anchor: "now",
-        proration_behavior: "none",
-      });
-    }),
-  getStripeCustomerPortalUrl: protectedOrganizationProcedure
-    .input(
-      z.object({
-        orgId: z.string(),
-      }),
-    )
-    .query(async ({ input, ctx }) => {
-      throwIfNoEntitlement({
-        entitlement: "cloud-billing",
-        sessionUser: ctx.session.user,
-        orgId: input.orgId,
-      });
-      throwIfNoOrganizationAccess({
-        organizationId: input.orgId,
-        scope: "langfuseCloudBilling:CRUD",
-        session: ctx.session,
-      });
-
-      const org = await ctx.prisma.organization.findUnique({
-        where: {
-          id: input.orgId,
-        },
-      });
-      if (!org) {
-        throw new TRPCError({
-          code: "INTERNAL_SERVER_ERROR",
-          message: "Organization not found",
-        });
-      }
-
-      if (!stripeClient)
-        throw new TRPCError({
-          code: "INTERNAL_SERVER_ERROR",
-          message: "Stripe client not initialized",
-        });
-
-      const parsedOrg = parseDbOrg(org);
-      let stripeCustomerId = parsedOrg.cloudConfig?.stripe?.customerId;
-      let stripeSubscriptionId =
-        parsedOrg.cloudConfig?.stripe?.activeSubscriptionId;
-      if (!stripeCustomerId || !stripeSubscriptionId) {
-        // Do not create a new customer if the org is on a plan (assigned manually)
-        return null;
-      }
-
-      const billingPortalSession =
-        await stripeClient.billingPortal.sessions.create({
-          customer: stripeCustomerId,
-          return_url: `${env.NEXTAUTH_URL}/organization/${input.orgId}/settings/billing`,
-        });
-
-      return billingPortalSession.url;
-    }),
-  getUsage: protectedOrganizationProcedure
-    .input(
-      z.object({
-        orgId: z.string(),
-      }),
-    )
-    .query(async ({ input, ctx }) => {
-      throwIfNoEntitlement({
-        entitlement: "cloud-billing",
-        sessionUser: ctx.session.user,
-        orgId: input.orgId,
-      });
-      throwIfNoOrganizationAccess({
-        organizationId: input.orgId,
-        scope: "langfuseCloudBilling:CRUD",
-        session: ctx.session,
-      });
-
-      const organization = await ctx.prisma.organization.findUnique({
-        where: {
-          id: input.orgId,
-        },
-        include: {
-          projects: {
-            select: {
-              id: true,
-            },
-          },
-        },
-      });
-      if (!organization) {
-        throw new TRPCError({
-          code: "INTERNAL_SERVER_ERROR",
-          message: "Organization not found",
-        });
-      }
-      const parsedOrg = parseDbOrg(organization);
-
-      // For Stripe subscriptions, we can get usage from the Stripe Metered Billing API
-      if (
-        stripeClient &&
-        parsedOrg.cloudConfig?.stripe?.customerId &&
-        parsedOrg.cloudConfig?.stripe?.activeSubscriptionId
-      ) {
-        const subscription = await stripeClient.subscriptions.retrieve(
-          parsedOrg.cloudConfig.stripe.activeSubscriptionId,
-        );
-        if (subscription) {
-          const billingPeriod = {
-            start: new Date(subscription.current_period_start * 1000),
-            end: new Date(subscription.current_period_end * 1000),
-          };
-
-          try {
-            const stripeInvoice = await stripeClient.invoices.retrieveUpcoming({
-              subscription: parsedOrg.cloudConfig.stripe.activeSubscriptionId,
-            });
-            const upcomingInvoice = {
-              usdAmount: stripeInvoice.amount_due / 100,
-              date: new Date(stripeInvoice.period_end * 1000),
-            };
-            const usageInvoiceLines = stripeInvoice.lines.data.filter((line) =>
-              Boolean(line.plan?.meter),
-            );
-            const usage = usageInvoiceLines.reduce((acc, line) => {
-              if (line.quantity) {
-                return acc + line.quantity;
-              }
-              return acc;
-            }, 0);
-            // get meter for usage type (events or observations)
-            const meterId = usageInvoiceLines[0]?.plan?.meter;
-            const meter = meterId
-              ? await stripeClient.billing.meters.retrieve(meterId)
-              : undefined;
-
-            return {
-              usageCount: usage,
-              usageType: meter?.display_name.toLowerCase() ?? "events",
-              billingPeriod,
-              upcomingInvoice,
-            };
-          } catch (e) {
-            logger.error(
-              "Failed to get usage from Stripe, using usage from Clickhouse",
-              {
-                error: e,
-              },
-            );
-          }
-        }
-      }
-
-      // Free plan, usage not tracked on Stripe, get usage from Clickhouse
-      const thirtyDaysAgo = new Date();
-      thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
-      thirtyDaysAgo.setHours(0, 0, 0, 0);
-      const projectIds = organization.projects.map((p) => p.id);
-
-      const [countTraces, countObservations, countScores] = await Promise.all([
-        getTraceCountOfProjectsSinceCreationDate({
-          projectIds,
-          start: thirtyDaysAgo,
-        }),
-        getObservationCountOfProjectsSinceCreationDate({
-          projectIds,
-          start: thirtyDaysAgo,
-        }),
-        getScoreCountOfProjectsSinceCreationDate({
-          projectIds,
-          start: thirtyDaysAgo,
-        }),
-      ]);
-
-      return {
-        usageCount: countTraces + countObservations + countScores,
-        usageType: "events",
-      };
-    }),
-});
diff --git a/web/src/ee/features/billing/server/stripeWebhookApiHandler.ts b/web/src/ee/features/billing/server/stripeWebhookApiHandler.ts
deleted file mode 100644
index d3904ec..0000000
--- a/web/src/ee/features/billing/server/stripeWebhookApiHandler.ts
+++ /dev/null
@@ -1,241 +0,0 @@
-import {
-  getOrgIdFromStripeClientReference,
-  isStripeClientReferenceFromCurrentCloudRegion,
-} from "@/src/ee/features/billing/stripeClientReference";
-import { env } from "@/src/env.mjs";
-import { type NextRequest, NextResponse } from "next/server";
-import { prisma } from "@langfuse/shared/src/db";
-import { stripeClient } from "@/src/ee/features/billing/utils/stripe";
-import type Stripe from "stripe";
-import { CloudConfigSchema, parseDbOrg } from "@langfuse/shared";
-import { traceException, redis, logger } from "@langfuse/shared/src/server";
-import { ApiAuthService } from "@/src/features/public-api/server/apiAuth";
-
-/*
- * Sign-up endpoint (email/password users), creates user in database.
- * SSO users are created by the NextAuth adapters.
- */
-export async function stripeWebhookApiHandler(req: NextRequest) {
-  if (req.method !== "POST")
-    return NextResponse.json(
-      { message: "Method not allowed" },
-      { status: 405 },
-    );
-
-  if (!env.NEXT_PUBLIC_LANGFUSE_CLOUD_REGION || !stripeClient) {
-    logger.error("[Stripe Webhook] Endpoint only available in Langfuse Cloud");
-    return NextResponse.json(
-      { message: "Stripe webhook endpoint only available in Langfuse Cloud" },
-      { status: 500 },
-    );
-  }
-  if (!env.STRIPE_WEBHOOK_SIGNING_SECRET) {
-    logger.error("[Stripe Webhook] Stripe webhook signing key not found");
-    return NextResponse.json(
-      { message: "Stripe secret key not found" },
-      { status: 500 },
-    );
-  }
-
-  // check if the request is signed by stripe
-  const sig = req.headers.get("stripe-signature");
-  if (!sig) {
-    logger.error("[Stripe Webhook] No signature");
-    return NextResponse.json({ message: "No signature" }, { status: 400 });
-  }
-  let event: Stripe.Event;
-  try {
-    event = stripeClient.webhooks.constructEvent(
-      await req.text(),
-      sig,
-      env.STRIPE_WEBHOOK_SIGNING_SECRET,
-    );
-  } catch (err) {
-    logger.error("[Stripe Webhook] Error verifying signature", err);
-    return NextResponse.json(
-      { message: `Webhook Error: ${err}` },
-      { status: 400 },
-    );
-  }
-
-  // Handle the event
-  switch (event.type) {
-    case "customer.subscription.created":
-      // update the active product id on the organization linked to the subscription + customer and subscription id (if null or same)
-      const subscription = event.data.object;
-      logger.info("[Stripe Webhook] Start customer.subscription.created", {
-        payload: subscription,
-      });
-      await handleSubscriptionChanged(subscription, "created");
-      break;
-    case "customer.subscription.updated":
-      // update the active product id on the organization linked to the subscription + customer and subscription id (if null or same)
-      const updatedSubscription = event.data.object;
-      logger.info("[Stripe Webhook] Start customer.subscription.updated", {
-        payload: updatedSubscription,
-      });
-      await handleSubscriptionChanged(updatedSubscription, "updated");
-      break;
-    case "customer.subscription.deleted":
-      // remove the active product id on the organization linked to the subscription + subscription, keep customer id
-      const deletedSubscription = event.data.object;
-      logger.info("[Stripe Webhook] Start customer.subscription.deleted", {
-        payload: deletedSubscription,
-      });
-      await handleSubscriptionChanged(deletedSubscription, "deleted");
-      break;
-    default:
-      logger.warn(`Unhandled event type ${event.type}`);
-  }
-
-  return NextResponse.json({ received: true }, { status: 200 });
-}
-
-async function handleSubscriptionChanged(
-  subscription: Stripe.Subscription,
-  action: "created" | "deleted" | "updated",
-) {
-  const subscriptionId = subscription.id;
-
-  // get the checkout session from the subscription to retrieve the client reference for this subscription
-  const checkoutSessionsResponse = await stripeClient?.checkout.sessions.list({
-    subscription: subscriptionId,
-    limit: 1,
-  });
-  if (!checkoutSessionsResponse || checkoutSessionsResponse.data.length !== 1) {
-    logger.error("[Stripe Webhook] No checkout session found");
-    traceException("[Stripe Webhook] No checkout session found");
-    return;
-  }
-  const checkoutSession = checkoutSessionsResponse.data[0];
-
-  // the client reference is passed to the stripe checkout session via the pricing page
-  const clientReference = checkoutSession.client_reference_id;
-  if (!clientReference) {
-    logger.error("[Stripe Webhook] No client reference");
-    traceException("[Stripe Webhook] No client reference");
-    return NextResponse.json(
-      { message: "No client reference" },
-      { status: 400 },
-    );
-  }
-  if (!isStripeClientReferenceFromCurrentCloudRegion(clientReference)) {
-    logger.info(
-      "[Stripe Webhook] Client reference not from current cloud region",
-    );
-    return;
-  }
-  const orgId = getOrgIdFromStripeClientReference(clientReference);
-
-  // find the org with the customer ID
-  const organization = await prisma.organization.findUnique({
-    where: {
-      id: orgId,
-    },
-  });
-  if (!organization) {
-    logger.error("[Stripe Webhook] Organization not found");
-    traceException("[Stripe Webhook] Organization not found");
-    return;
-  }
-  const parsedOrg = parseDbOrg(organization);
-
-  // assert that no other stripe customer id is already set on the org
-  const customerId = subscription.customer;
-  if (!customerId || typeof customerId !== "string") {
-    logger.error("[Stripe Webhook] Customer ID not found");
-    traceException("[Stripe Webhook] Customer ID not found");
-    return;
-  }
-  if (
-    parsedOrg.cloudConfig?.stripe?.customerId &&
-    parsedOrg.cloudConfig?.stripe?.customerId !== customerId
-  ) {
-    logger.error("[Stripe Webhook] Another customer id already set on org");
-    traceException("[Stripe Webhook] Another customer id already set on org");
-    return;
-  }
-
-  // check subscription items
-  logger.info("subscription.items.data", { payload: subscription.items.data });
-
-  if (!subscription.items.data || subscription.items.data.length !== 1) {
-    logger.error(
-      "[Stripe Webhook] Subscription items not found or more than one",
-    );
-    traceException(
-      "[Stripe Webhook] Subscription items not found or more than one",
-    );
-    return;
-  }
-
-  const subscriptionItem = subscription.items.data[0];
-  const productId = subscriptionItem.price.product;
-
-  if (!productId || typeof productId !== "string") {
-    logger.error("[Stripe Webhook] Product ID not found");
-    traceException("[Stripe Webhook] Product ID not found");
-    return;
-  }
-
-  // assert that no other product is already set on the org if this is not an update
-  if (
-    action !== "updated" &&
-    parsedOrg.cloudConfig?.stripe?.activeProductId &&
-    parsedOrg.cloudConfig?.stripe?.activeProductId !== productId
-  ) {
-    traceException(
-      "[Stripe Webhook] Another active product id already set on (one of the) org with this active subscription id",
-    );
-    logger.error(
-      "[Stripe Webhook] Another active product id already set on (one of the) org with this active subscription id",
-    );
-    return;
-  }
-
-  // update the cloud config with the product ID
-  if (action === "created" || action === "updated") {
-    await prisma.organization.update({
-      where: {
-        id: parsedOrg.id,
-      },
-      data: {
-        cloudConfig: {
-          ...parsedOrg.cloudConfig,
-          stripe: {
-            ...parsedOrg.cloudConfig?.stripe,
-            ...CloudConfigSchema.shape.stripe.parse({
-              activeProductId: productId,
-              activeSubscriptionId: subscriptionId,
-              customerId: customerId,
-            }),
-          },
-        },
-      },
-    });
-  } else if (action === "deleted") {
-    await prisma.organization.update({
-      where: {
-        id: parsedOrg.id,
-      },
-      data: {
-        cloudConfig: {
-          ...parsedOrg.cloudConfig,
-          stripe: {
-            ...parsedOrg.cloudConfig?.stripe,
-            ...CloudConfigSchema.shape.stripe.parse({
-              activeProductId: undefined,
-              activeSubscriptionId: undefined,
-              customerId: customerId,
-            }),
-          },
-        },
-      },
-    });
-  }
-
-  // need to update the plan in the api keys
-  await new ApiAuthService(prisma, redis).invalidateOrgApiKeys(parsedOrg.id);
-
-  return;
-}
diff --git a/web/src/ee/features/billing/stripeClientReference.ts b/web/src/ee/features/billing/stripeClientReference.ts
deleted file mode 100644
index 56c3fa0..0000000
--- a/web/src/ee/features/billing/stripeClientReference.ts
+++ /dev/null
@@ -1,23 +0,0 @@
-import { env } from "@/src/env.mjs";
-import { logger } from "@langfuse/shared/src/server";
-
-// used server-side to create a stripe customer reference when creating a checkout session
-export const createStripeClientReference = (orgId: string) => {
-  if (!env.NEXT_PUBLIC_LANGFUSE_CLOUD_REGION) {
-    logger.error(
-      "Returning null stripeCustomerReference, you cannot run the checkout page outside of Langfuse Cloud",
-    );
-    return null;
-  }
-  return `${env.NEXT_PUBLIC_LANGFUSE_CLOUD_REGION}-${orgId}`;
-};
-
-// used server-side to check if the stripe customer reference is valid and parse the orgId when receiving a stripe webhook
-export const isStripeClientReferenceFromCurrentCloudRegion = (
-  clientReference: string,
-) =>
-  env.NEXT_PUBLIC_LANGFUSE_CLOUD_REGION &&
-  clientReference.startsWith(env.NEXT_PUBLIC_LANGFUSE_CLOUD_REGION);
-
-export const getOrgIdFromStripeClientReference = (clientReference: string) =>
-  clientReference.replace(`${env.NEXT_PUBLIC_LANGFUSE_CLOUD_REGION}-`, "");
diff --git a/web/src/ee/features/billing/utils/stripe.ts b/web/src/ee/features/billing/utils/stripe.ts
deleted file mode 100644
index 70d6bba..0000000
--- a/web/src/ee/features/billing/utils/stripe.ts
+++ /dev/null
@@ -1,7 +0,0 @@
-import { env } from "@/src/env.mjs";
-import Stripe from "stripe";
-
-export const stripeClient =
-  env.STRIPE_SECRET_KEY && env.NEXT_PUBLIC_LANGFUSE_CLOUD_REGION
-    ? new Stripe(env.STRIPE_SECRET_KEY)
-    : undefined;
diff --git a/web/src/ee/features/billing/utils/stripeProducts.ts b/web/src/ee/features/billing/utils/stripeProducts.ts
deleted file mode 100644
index b1b56b5..0000000
--- a/web/src/ee/features/billing/utils/stripeProducts.ts
+++ /dev/null
@@ -1,88 +0,0 @@
-import { env } from "@/src/env.mjs";
-import { type Plan } from "@langfuse/shared";
-
-type StripeProduct = {
-  stripeProductId: string;
-  mappedPlan: Plan;
-  // include checkout if product can be subscribed to by new users
-  checkout: {
-    title: string;
-    description: string;
-    price: string;
-    usagePrice: string;
-    mainFeatures: string[];
-  } | null;
-};
-
-// map of planid to plan name
-export const stripeProducts: StripeProduct[] = [
-  {
-    stripeProductId:
-      env.NEXT_PUBLIC_LANGFUSE_CLOUD_REGION === "DEV" ||
-      env.NEXT_PUBLIC_LANGFUSE_CLOUD_REGION === "STAGING"
-        ? "prod_RoBuRrXjIUBIJ8" // test
-        : "prod_RoYirvRQ4Kc6po", // live
-    mappedPlan: "cloud:core",
-    checkout: {
-      title: "Core",
-      description:
-        "Great to get started for most projects with unlimited users and 90 days data access.",
-      price: "$59 / month",
-      usagePrice: "$8/100k events (100k included)",
-      mainFeatures: [
-        "90 days data access",
-        "Unlimited users",
-        "Unlimited evaluators",
-        "Support via Email/Chat",
-      ],
-    },
-  },
-  {
-    stripeProductId:
-      env.NEXT_PUBLIC_LANGFUSE_CLOUD_REGION === "DEV" ||
-      env.NEXT_PUBLIC_LANGFUSE_CLOUD_REGION === "STAGING"
-        ? "prod_QgDNYKXcBfvUQ3" // test
-        : "prod_QhK7UMhrkVeF6R", // live
-    mappedPlan: "cloud:pro",
-    checkout: {
-      title: "Pro",
-      description:
-        "For projects that scale and need unlimited data access, high rate limits, and Slack support.",
-      price: "$199 / month",
-      usagePrice: "$8/100k events (100k included)",
-      mainFeatures: [
-        "Everything in Core",
-        "Unlimited data access",
-        "Unlimited annotation queues",
-        "High rate limits",
-        "SOC2, ISO27001 reports",
-        "Support via Slack",
-      ],
-    },
-  },
-  {
-    stripeProductId:
-      env.NEXT_PUBLIC_LANGFUSE_CLOUD_REGION === "DEV" ||
-      env.NEXT_PUBLIC_LANGFUSE_CLOUD_REGION === "STAGING"
-        ? "prod_QgDOxTD64U6KDv" // test
-        : "prod_QhK9qKGH25BTcS", // live
-    mappedPlan: "cloud:team",
-    checkout: {
-      title: "Team",
-      description: "Organizational and security controls for larger teams.",
-      price: "$499 / month",
-      usagePrice: "$8/100k events (100k included)",
-      mainFeatures: [
-        "Everything in Pro",
-        "Enterprise SSO (e.g. Okta)",
-        "SSO enforcement",
-        "Fine-grained RBAC",
-        "Data retention management",
-      ],
-    },
-  },
-];
-
-export const mapStripeProductIdToPlan = (productId: string): Plan | null =>
-  stripeProducts.find((product) => product.stripeProductId === productId)
-    ?.mappedPlan ?? null;
diff --git a/web/src/ee/features/evals/components/eval-form-descriptions.tsx b/web/src/ee/features/evals/components/eval-form-descriptions.tsx
deleted file mode 100644
index d0a82c4..0000000
--- a/web/src/ee/features/evals/components/eval-form-descriptions.tsx
+++ /dev/null
@@ -1,38 +0,0 @@
-import DocPopup from "@/src/components/layouts/doc-popup";
-import { Label } from "@/src/components/ui/label";
-
-export function VariableMappingDescription(p: {
-  title: string;
-  description: string;
-  href: string;
-}) {
-  return (
-    <div className="flex w-1/2 items-center">
-      <Label className="muted-foreground text-sm font-light">{p.title}</Label>
-      <DocPopup description={p.description} href={p.href} />
-    </div>
-  );
-}
-
-export function TimeScopeDescription(props: {
-  projectId: string;
-  timeScope: ("NEW" | "EXISTING")[] | undefined;
-  target: "trace" | "dataset_item" | undefined;
-}) {
-  if (!props.timeScope || props.timeScope.length === 0) {
-    return "Select a time scope to run this configuration on.";
-  }
-
-  return (
-    <div>
-      This configuration will run on{" "}
-      {props.timeScope?.includes("NEW") && props.timeScope?.includes("EXISTING")
-        ? "all future and existing"
-        : props.timeScope?.includes("NEW")
-          ? "all future"
-          : "all existing"}{" "}
-      {props.target === "trace" ? "traces" : "dataset run items"} that match
-      these filters.{" "}
-    </div>
-  );
-}
diff --git a/web/src/ee/features/evals/components/eval-log.tsx b/web/src/ee/features/evals/components/eval-log.tsx
deleted file mode 100644
index 13b8b5c..0000000
--- a/web/src/ee/features/evals/components/eval-log.tsx
+++ /dev/null
@@ -1,224 +0,0 @@
-import { StatusBadge } from "@/src/components/layouts/status-badge";
-import { DataTable } from "@/src/components/table/data-table";
-import { useRowHeightLocalStorage } from "@/src/components/table/data-table-row-height-switch";
-import { DataTableToolbar } from "@/src/components/table/data-table-toolbar";
-import TableLink from "@/src/components/table/table-link";
-import { type LangfuseColumnDef } from "@/src/components/table/types";
-import { IOTableCell } from "@/src/components/ui/CodeJsonViewer";
-import useColumnOrder from "@/src/features/column-visibility/hooks/useColumnOrder";
-import useColumnVisibility from "@/src/features/column-visibility/hooks/useColumnVisibility";
-import { type RouterOutputs, api } from "@/src/utils/api";
-import { type Prisma } from "@langfuse/shared";
-import { createColumnHelper } from "@tanstack/react-table";
-import { useQueryParams, withDefault, NumberParam } from "use-query-params";
-
-export type JobExecutionRow = {
-  status: string;
-  scoreName?: string;
-  scoreValue?: number;
-  scoreComment?: string;
-  scoreMetadata?: Prisma.JsonValue;
-  startTime?: string;
-  endTime?: string;
-  traceId?: string;
-  templateId: string;
-  evaluatorId: string;
-  error?: string;
-};
-
-export default function EvalLogTable({
-  projectId,
-  jobConfigurationId,
-}: {
-  projectId: string;
-  jobConfigurationId?: string;
-}) {
-  const [rowHeight, setRowHeight] = useRowHeightLocalStorage("evalLogs", "s");
-  const [paginationState, setPaginationState] = useQueryParams({
-    pageIndex: withDefault(NumberParam, 0),
-    pageSize: withDefault(NumberParam, 50),
-  });
-  const logs = api.evals.getLogs.useQuery({
-    page: paginationState.pageIndex,
-    limit: paginationState.pageSize,
-    jobConfigurationId,
-    projectId,
-  });
-  const totalCount = logs.data?.totalCount ?? null;
-
-  const columnHelper = createColumnHelper<JobExecutionRow>();
-  const columns = [
-    columnHelper.accessor("status", {
-      header: "Status",
-      id: "status",
-      cell: (row) => {
-        const status = row.getValue();
-        return <StatusBadge type={status.toLowerCase()} />;
-      },
-    }),
-    columnHelper.accessor("startTime", {
-      id: "startTime",
-      header: "Start Time",
-      enableHiding: true,
-    }),
-    columnHelper.accessor("endTime", {
-      id: "endTime",
-      header: "End Time",
-      enableHiding: true,
-    }),
-    columnHelper.accessor("scoreName", {
-      header: "Score Name",
-      id: "scoreName",
-      enableHiding: true,
-    }),
-    columnHelper.accessor("scoreValue", {
-      header: "Score Value",
-      id: "scoreValue",
-      enableHiding: true,
-      cell: (row) => {
-        const value = row.getValue();
-        if (value === undefined) {
-          return undefined;
-        }
-        return value % 1 === 0 ? value : value.toFixed(4);
-      },
-    }),
-    columnHelper.accessor("scoreComment", {
-      header: "Score Comment",
-      id: "scoreComment",
-      enableHiding: true,
-      cell: (row) => {
-        const value = row.getValue();
-        return (
-          value !== undefined && (
-            <IOTableCell data={value} singleLine={rowHeight === "s"} />
-          )
-        );
-      },
-    }),
-    columnHelper.accessor("error", {
-      id: "error",
-      header: "Error",
-      enableHiding: true,
-      cell: (row) => {
-        const value = row.getValue();
-        return (
-          value !== undefined && (
-            <IOTableCell data={value} singleLine={rowHeight === "s"} />
-          )
-        );
-      },
-    }),
-    columnHelper.accessor("traceId", {
-      id: "traceId",
-      header: "Trace",
-      cell: (row) => {
-        const traceId = row.getValue();
-        return traceId ? (
-          <TableLink
-            path={`/project/${projectId}/traces/${encodeURIComponent(traceId)}`}
-            value={traceId}
-          />
-        ) : undefined;
-      },
-    }),
-    columnHelper.accessor("templateId", {
-      id: "templateId",
-      header: "Template",
-      cell: (row) => {
-        const templateId = row.getValue();
-        return templateId ? (
-          <TableLink
-            path={`/project/${projectId}/evals/templates/${encodeURIComponent(templateId)}`}
-            value={templateId}
-          />
-        ) : undefined;
-      },
-    }),
-  ] as LangfuseColumnDef<JobExecutionRow>[];
-
-  if (!jobConfigurationId) {
-    columns.push(
-      columnHelper.accessor("evaluatorId", {
-        id: "evaluatorId",
-        header: "Evaluator",
-        cell: (row) => {
-          const evaluatorId = row.getValue();
-          return evaluatorId ? (
-            <TableLink
-              path={`/project/${projectId}/evals/${encodeURIComponent(evaluatorId)}`}
-              value={evaluatorId}
-            />
-          ) : undefined;
-        },
-      }) as LangfuseColumnDef<JobExecutionRow>,
-    );
-  }
-
-  const [columnVisibility, setColumnVisibility] =
-    useColumnVisibility<JobExecutionRow>("evalLogColumnVisibility", columns);
-
-  const [columnOrder, setColumnOrder] = useColumnOrder<JobExecutionRow>(
-    "evalLogColumnOrder",
-    columns,
-  );
-
-  const convertToTableRow = (
-    jobConfig: RouterOutputs["evals"]["getLogs"]["data"][number],
-  ): JobExecutionRow => {
-    return {
-      status: jobConfig.status,
-      scoreName: jobConfig.score?.name ?? undefined,
-      scoreValue: jobConfig.score?.value ?? undefined,
-      scoreComment: jobConfig.score?.comment ?? undefined,
-      scoreMetadata: jobConfig.score?.metadata ?? undefined,
-      startTime: jobConfig.startTime?.toLocaleString() ?? undefined,
-      endTime: jobConfig.endTime?.toLocaleString() ?? undefined,
-      traceId: jobConfig.jobInputTraceId ?? undefined,
-      templateId: jobConfig.jobConfiguration.evalTemplateId ?? "",
-      evaluatorId: jobConfig.jobConfigurationId,
-      error: jobConfig.error ?? undefined,
-    };
-  };
-
-  return (
-    <>
-      <DataTableToolbar
-        columns={columns}
-        columnVisibility={columnVisibility}
-        setColumnVisibility={setColumnVisibility}
-        columnOrder={columnOrder}
-        setColumnOrder={setColumnOrder}
-        rowHeight={rowHeight}
-        setRowHeight={setRowHeight}
-      />
-      <DataTable
-        columns={columns}
-        data={
-          logs.isLoading
-            ? { isLoading: true, isError: false }
-            : logs.isError
-              ? {
-                  isLoading: false,
-                  isError: true,
-                  error: logs.error.message,
-                }
-              : {
-                  isLoading: false,
-                  isError: false,
-                  data: logs.data.data.map((t) => convertToTableRow(t)),
-                }
-        }
-        pagination={{
-          totalCount,
-          onChange: setPaginationState,
-          state: paginationState,
-        }}
-        columnVisibility={columnVisibility}
-        onColumnVisibilityChange={setColumnVisibility}
-        columnOrder={columnOrder}
-        onColumnOrderChange={setColumnOrder}
-      />
-    </>
-  );
-}
diff --git a/web/src/ee/features/evals/components/eval-template-detail.tsx b/web/src/ee/features/evals/components/eval-template-detail.tsx
deleted file mode 100644
index 8bb0b9c..0000000
--- a/web/src/ee/features/evals/components/eval-template-detail.tsx
+++ /dev/null
@@ -1,182 +0,0 @@
-import * as React from "react";
-import { EvalTemplateForm } from "@/src/ee/features/evals/components/template-form";
-import { api } from "@/src/utils/api";
-import { type EvalTemplate } from "@langfuse/shared";
-import { useRouter } from "next/router";
-import {
-  Select,
-  SelectContent,
-  SelectGroup,
-  SelectItem,
-  SelectTrigger,
-  SelectValue,
-} from "@/src/components/ui/select";
-import { useHasProjectAccess } from "@/src/features/rbac/utils/checkProjectAccess";
-import { Button } from "@/src/components/ui/button";
-import { Plus } from "lucide-react";
-import { useState } from "react";
-import { usePostHogClientCapture } from "@/src/features/posthog-analytics/usePostHogClientCapture";
-import Page from "@/src/components/layouts/page";
-
-export const EvalTemplateDetail = () => {
-  const router = useRouter();
-  const projectId = router.query.projectId as string;
-  const templateId = router.query.id as string;
-
-  const [isEditing, setIsEditing] = useState(false);
-
-  // get the current template by id
-  const template = api.evals.templateById.useQuery({
-    projectId: projectId,
-    id: templateId,
-  });
-
-  // get all templates for the current template name
-  const allTemplates = api.evals.allTemplatesForName.useQuery(
-    {
-      projectId: projectId,
-      name: template.data?.name ?? "",
-    },
-    {
-      enabled:
-        !template.isLoading &&
-        !template.isError &&
-        template.data?.name !== undefined,
-    },
-  );
-
-  // const utils = api.useUtils();
-
-  return (
-    <Page
-      withPadding
-      scrollable
-      headerProps={{
-        title: `${template.data?.name}: ${templateId}`,
-        itemType: "EVAL_TEMPLATE",
-        breadcrumb: [
-          {
-            name: "Eval Templates",
-            href: `/project/${router.query.projectId as string}/evals/templates`,
-          },
-        ],
-        actionButtonsRight: (
-          <>
-            {!isEditing && (
-              <UpdateTemplate
-                projectId={projectId}
-                isLoading={template.isLoading}
-                setIsEditing={setIsEditing}
-              />
-            )}
-            <EvalVersionDropdown
-              disabled={allTemplates.isLoading}
-              options={allTemplates.data?.templates ?? []}
-              defaultOption={template.data ?? undefined}
-              onSelect={(template) => {
-                router.push(
-                  `/project/${projectId}/evals/templates/${template.id}`,
-                );
-              }}
-            />
-            {/* TODO: moved to LFE-4573 */}
-            {/* <DeleteEvaluatorTemplateButton
-              itemId={templateId}
-              projectId={projectId}
-              redirectUrl={`/project/${projectId}/evals/templates`}
-              deleteConfirmation={
-                template.data != null
-                  ? `${template.data.name}-v${template.data.version}`
-                  : undefined
-              }
-              enabled={!template.isLoading}
-            /> */}
-          </>
-        ),
-      }}
-    >
-      {allTemplates.isLoading || !allTemplates.data ? (
-        <div className="p-3">Loading...</div>
-      ) : (
-        <EvalTemplateForm
-          projectId={projectId}
-          existingEvalTemplate={template.data ?? undefined}
-          isEditing={isEditing}
-          setIsEditing={setIsEditing}
-        />
-      )}
-    </Page>
-  );
-};
-
-export function EvalVersionDropdown(props: {
-  disabled: boolean;
-  options?: EvalTemplate[];
-  defaultOption?: EvalTemplate;
-  onSelect?: (template: EvalTemplate) => void;
-}) {
-  const capture = usePostHogClientCapture();
-  const handleSelect = (value: string) => {
-    const selectedTemplate = props.options?.find(
-      (template) => template.id === value,
-    );
-    if (selectedTemplate && props.onSelect) {
-      props.onSelect(selectedTemplate);
-      capture("eval_templates:view_version");
-    }
-  };
-
-  return (
-    <Select
-      disabled={props.disabled}
-      onValueChange={handleSelect}
-      defaultValue={props.defaultOption ? props.defaultOption.id : undefined}
-    >
-      <SelectTrigger className="w-[180px]">
-        <SelectValue placeholder="Version" />
-      </SelectTrigger>
-      <SelectContent>
-        <SelectGroup>
-          {props.options?.map((template) => (
-            <SelectItem key={template.id} value={template.id}>
-              v{template.version} - {template.createdAt.toLocaleDateString()}
-            </SelectItem>
-          ))}
-        </SelectGroup>
-      </SelectContent>
-    </Select>
-  );
-}
-
-export function UpdateTemplate({
-  projectId,
-  isLoading,
-  setIsEditing,
-}: {
-  projectId: string;
-  isLoading: boolean;
-  setIsEditing: (isEditing: boolean) => void;
-}) {
-  const hasAccess = useHasProjectAccess({
-    projectId,
-    scope: "evalTemplate:CUD",
-  });
-  const capture = usePostHogClientCapture();
-
-  const handlePromptEdit = () => {
-    setIsEditing(true);
-    capture("eval_templates:update_form_open");
-  };
-
-  return (
-    <Button
-      variant="outline"
-      onClick={() => handlePromptEdit()}
-      disabled={!hasAccess}
-      loading={isLoading}
-    >
-      <Plus className="h-4 w-4" />
-      New version
-    </Button>
-  );
-}
diff --git a/web/src/ee/features/evals/components/eval-templates-table.tsx b/web/src/ee/features/evals/components/eval-templates-table.tsx
deleted file mode 100644
index 080f0f8..0000000
--- a/web/src/ee/features/evals/components/eval-templates-table.tsx
+++ /dev/null
@@ -1,121 +0,0 @@
-import { DataTable } from "@/src/components/table/data-table";
-import { DataTableToolbar } from "@/src/components/table/data-table-toolbar";
-import TableLink from "@/src/components/table/table-link";
-import { type LangfuseColumnDef } from "@/src/components/table/types";
-import useColumnVisibility from "@/src/features/column-visibility/hooks/useColumnVisibility";
-import { type RouterOutputs, api } from "@/src/utils/api";
-import { createColumnHelper } from "@tanstack/react-table";
-import { useQueryParams, withDefault, NumberParam } from "use-query-params";
-
-export type EvalsTemplateRow = {
-  name: string;
-  latestCreatedAt?: Date;
-  latestVersion?: number;
-  latestId?: string;
-};
-
-export default function EvalsTemplateTable({
-  projectId,
-}: {
-  projectId: string;
-}) {
-  const [paginationState, setPaginationState] = useQueryParams({
-    pageIndex: withDefault(NumberParam, 0),
-    pageSize: withDefault(NumberParam, 50),
-  });
-
-  const templates = api.evals.templateNames.useQuery({
-    projectId,
-    page: paginationState.pageIndex,
-    limit: paginationState.pageSize,
-  });
-  const totalCount = templates.data?.totalCount ?? null;
-
-  const columnHelper = createColumnHelper<EvalsTemplateRow>();
-
-  const columns = [
-    columnHelper.accessor("name", {
-      header: "Name",
-      id: "name",
-      cell: (row) => {
-        const name = row.getValue();
-        const id = row.row.original.latestId;
-
-        if (!id) {
-          return name;
-        }
-
-        return name ? (
-          <TableLink
-            path={`/project/${projectId}/evals/templates/${encodeURIComponent(id)}`}
-            value={name}
-          />
-        ) : undefined;
-      },
-    }),
-    columnHelper.accessor("latestCreatedAt", {
-      header: "Last Edit",
-      id: "latestCreatedAt",
-      cell: (row) => {
-        return row.getValue()?.toLocaleDateString();
-      },
-    }),
-    columnHelper.accessor("latestVersion", {
-      header: "Last Version",
-      id: "version",
-      cell: (row) => {
-        return row.getValue();
-      },
-    }),
-  ] as LangfuseColumnDef<EvalsTemplateRow>[];
-
-  const [columnVisibility, setColumnVisibility] =
-    useColumnVisibility<EvalsTemplateRow>(
-      "evalTemplatesColumnVisibility",
-      columns,
-    );
-
-  const convertToTableRow = (
-    template: RouterOutputs["evals"]["templateNames"]["templates"][number],
-  ): EvalsTemplateRow => {
-    return {
-      name: template.name,
-      latestCreatedAt: template.latestCreatedAt,
-      latestVersion: template.version,
-      latestId: template.latestId,
-    };
-  };
-
-  return (
-    <>
-      <DataTableToolbar columns={columns} />
-      <DataTable
-        columns={columns}
-        data={
-          templates.isLoading
-            ? { isLoading: true, isError: false }
-            : templates.isError
-              ? {
-                  isLoading: false,
-                  isError: true,
-                  error: templates.error.message,
-                }
-              : {
-                  isLoading: false,
-                  isError: false,
-                  data: templates.data.templates.map((t) =>
-                    convertToTableRow(t),
-                  ),
-                }
-        }
-        pagination={{
-          totalCount,
-          onChange: setPaginationState,
-          state: paginationState,
-        }}
-        columnVisibility={columnVisibility}
-        onColumnVisibilityChange={setColumnVisibility}
-      />
-    </>
-  );
-}
diff --git a/web/src/ee/features/evals/components/evaluator-detail.tsx b/web/src/ee/features/evals/components/evaluator-detail.tsx
deleted file mode 100644
index e28b142..0000000
--- a/web/src/ee/features/evals/components/evaluator-detail.tsx
+++ /dev/null
@@ -1,304 +0,0 @@
-import * as React from "react";
-import { type RouterOutputs, api } from "@/src/utils/api";
-import { useRouter } from "next/router";
-import { EvaluatorForm } from "@/src/ee/features/evals/components/evaluator-form";
-import { useHasProjectAccess } from "@/src/features/rbac/utils/checkProjectAccess";
-import { Button } from "@/src/components/ui/button";
-import {
-  Popover,
-  PopoverContent,
-  PopoverTrigger,
-} from "@/src/components/ui/popover";
-import { useState } from "react";
-import TableLink from "@/src/components/table/table-link";
-import EvalLogTable from "@/src/ee/features/evals/components/eval-log";
-import { usePostHogClientCapture } from "@/src/features/posthog-analytics/usePostHogClientCapture";
-import { StatusBadge } from "@/src/components/layouts/status-badge";
-import { DetailPageNav } from "@/src/features/navigate-detail-pages/DetailPageNav";
-import { CardDescription } from "@/src/components/ui/card";
-import { EvaluatorStatus } from "@/src/ee/features/evals/types";
-import { Switch } from "@/src/components/ui/switch";
-import { Edit } from "lucide-react";
-import {
-  Dialog,
-  DialogContent,
-  DialogTitle,
-  DialogTrigger,
-} from "@/src/components/ui/dialog";
-import Page from "@/src/components/layouts/page";
-import {
-  SidePanel,
-  SidePanelHeader,
-  SidePanelTitle,
-} from "@/src/components/ui/side-panel";
-import { SidePanelContent } from "@/src/components/ui/side-panel";
-import { LevelCountsDisplay } from "@/src/components/level-counts-display";
-import {
-  type JobExecutionState,
-  generateJobExecutionCounts,
-} from "@/src/ee/features/evals/utils/job-execution-utils";
-import { DeleteEvaluatorButton } from "@/src/components/deleteButton";
-
-const JobExecutionCounts = ({
-  jobExecutionsByState,
-}: {
-  jobExecutionsByState?: JobExecutionState[];
-}) => {
-  if (!jobExecutionsByState || jobExecutionsByState.length === 0) {
-    return null;
-  }
-
-  const counts = generateJobExecutionCounts(jobExecutionsByState);
-  return <LevelCountsDisplay counts={counts} />;
-};
-
-export const EvaluatorDetail = () => {
-  const router = useRouter();
-  const projectId = router.query.projectId as string;
-  const evaluatorId = router.query.evaluatorId as string;
-
-  const [isEditOpen, setIsEditOpen] = useState(false);
-
-  // get the current template by id
-  const evaluator = api.evals.configById.useQuery({
-    projectId: projectId,
-    id: evaluatorId,
-  });
-
-  // get all templates for the current template name
-  const allTemplates = api.evals.allTemplatesForName.useQuery(
-    {
-      projectId: projectId,
-      name: evaluator.data?.evalTemplate?.name ?? "",
-    },
-    {
-      enabled: !evaluator.isLoading && !evaluator.isError,
-    },
-  );
-
-  if (
-    evaluator.isLoading ||
-    !evaluator.data ||
-    allTemplates.isLoading ||
-    !allTemplates.data
-  ) {
-    return <div className="p-3">Loading...</div>;
-  }
-
-  if (evaluator.data && evaluator.data.evalTemplate === null) {
-    return <div>Evaluator not found</div>;
-  }
-
-  const existingEvaluator =
-    evaluator.data && evaluator.data.evalTemplate
-      ? {
-          ...evaluator.data,
-          evalTemplate: evaluator.data.evalTemplate,
-        }
-      : undefined;
-
-  return (
-    <Page
-      headerProps={{
-        title: evaluator.data
-          ? `${evaluator.data.scoreName}: ${evaluator.data.id}`
-          : "Loading...",
-        itemType: "EVALUATOR",
-        breadcrumb: [
-          {
-            name: "Evaluators",
-            href: `/project/${router.query.projectId as string}/evals`,
-          },
-        ],
-
-        actionButtonsRight: (
-          <>
-            {evaluator.data?.jobExecutionsByState && (
-              <div className="flex flex-col items-center justify-center rounded-md bg-muted-gray px-2">
-                <JobExecutionCounts
-                  jobExecutionsByState={evaluator.data.jobExecutionsByState}
-                />
-              </div>
-            )}
-            <StatusBadge
-              type={evaluator.data?.finalStatus.toLowerCase()}
-              isLive
-              className="max-h-8"
-            />
-
-            <DeactivateEvaluator
-              projectId={projectId}
-              evaluator={evaluator.data ?? undefined}
-              isLoading={evaluator.isLoading}
-            />
-            {evaluator.data && (
-              <DetailPageNav
-                key="nav"
-                currentId={encodeURIComponent(evaluator.data.id)}
-                path={(entry) =>
-                  `/project/${projectId}/evals/${encodeURIComponent(entry.id)}`
-                }
-                listKey="evals"
-              />
-            )}
-            <DeleteEvaluatorButton
-              itemId={evaluatorId}
-              projectId={projectId}
-              redirectUrl={`/project/${projectId}/evals`}
-              deleteConfirmation={evaluator.data?.scoreName}
-              icon
-            />
-          </>
-        ),
-      }}
-    >
-      {existingEvaluator && (
-        <div className="grid flex-1 grid-cols-[1fr,auto] overflow-hidden contain-layout">
-          <div className="flex h-full flex-col overflow-hidden">
-            <EvalLogTable
-              projectId={projectId}
-              jobConfigurationId={existingEvaluator.id}
-            />
-          </div>
-          <SidePanel
-            mobileTitle="Evaluator configuration"
-            id="evaluator-configuration"
-          >
-            <SidePanelHeader>
-              <SidePanelTitle>Evaluator configuration</SidePanelTitle>
-              <Dialog open={isEditOpen} onOpenChange={setIsEditOpen}>
-                <DialogTrigger asChild>
-                  <Button variant="outline" size="icon">
-                    <Edit className="h-4 w-4" />
-                  </Button>
-                </DialogTrigger>
-                <DialogContent className="max-w-screen-xl">
-                  <DialogTitle>Edit Evaluator</DialogTitle>
-                  <div className="max-h-[80vh] overflow-y-auto">
-                    <EvaluatorForm
-                      key={existingEvaluator.id}
-                      projectId={projectId}
-                      evalTemplates={allTemplates.data?.templates}
-                      existingEvaluator={existingEvaluator}
-                      shouldWrapVariables={true}
-                      mode="edit"
-                      onFormSuccess={() => {
-                        setIsEditOpen(false);
-                        // Force a reload as the form state is not properly updated
-                        void router.reload();
-                      }}
-                    />
-                  </div>
-                </DialogContent>
-              </Dialog>
-            </SidePanelHeader>
-            <SidePanelContent>
-              <>
-                <CardDescription className="flex items-center justify-between text-sm">
-                  <span className="mr-2 text-sm font-medium">
-                    Eval Template
-                  </span>
-                  <TableLink
-                    path={`/project/${projectId}/evals/templates/${existingEvaluator.evalTemplateId}`}
-                    value={`${existingEvaluator.evalTemplate.name} (v${existingEvaluator.evalTemplate.version})`}
-                    className="flex min-h-6 items-center"
-                  />
-                </CardDescription>
-                <div className="flex max-h-[80dvh] w-full flex-col items-start justify-between space-y-2 overflow-y-auto pb-4">
-                  <EvaluatorForm
-                    key={existingEvaluator.id}
-                    projectId={projectId}
-                    evalTemplates={allTemplates.data?.templates}
-                    existingEvaluator={existingEvaluator}
-                    disabled={true}
-                    shouldWrapVariables={true}
-                  />
-                </div>
-              </>
-            </SidePanelContent>
-          </SidePanel>
-        </div>
-      )}
-    </Page>
-  );
-};
-
-export function DeactivateEvaluator({
-  projectId,
-  evaluator,
-}: {
-  projectId: string;
-  evaluator?: RouterOutputs["evals"]["configById"];
-  isLoading: boolean;
-}) {
-  const utils = api.useUtils();
-  const hasAccess = useHasProjectAccess({ projectId, scope: "evalJob:CUD" });
-  const [isOpen, setIsOpen] = useState(false);
-  const capture = usePostHogClientCapture();
-  const isActive = evaluator?.status === EvaluatorStatus.ACTIVE;
-
-  const mutEvaluator = api.evals.updateEvalJob.useMutation({
-    onSuccess: () => {
-      void utils.evals.invalidate();
-    },
-  });
-
-  const onClick = () => {
-    if (!projectId) {
-      console.error("Project ID is missing");
-      return;
-    }
-
-    const prevStatus = evaluator?.status;
-
-    mutEvaluator.mutateAsync({
-      projectId,
-      evalConfigId: evaluator?.id ?? "",
-      config: {
-        status: isActive ? EvaluatorStatus.INACTIVE : EvaluatorStatus.ACTIVE,
-      },
-    });
-    capture(
-      prevStatus === EvaluatorStatus.ACTIVE
-        ? "eval_config:deactivate"
-        : "eval_config:activate",
-    );
-    setIsOpen(false);
-  };
-
-  return (
-    <Popover open={isOpen} onOpenChange={() => setIsOpen(!isOpen)}>
-      <PopoverTrigger asChild>
-        <div className="flex items-center">
-          <Switch
-            disabled={
-              !hasAccess ||
-              (evaluator?.timeScope?.length === 1 &&
-                evaluator.timeScope[0] === "EXISTING")
-            }
-            checked={isActive}
-            className={isActive ? "data-[state=checked]:bg-dark-green" : ""}
-          />
-        </div>
-      </PopoverTrigger>
-      <PopoverContent>
-        <h2 className="text-md mb-3 font-semibold">Please confirm</h2>
-        <p className="mb-3 text-sm">
-          {evaluator?.status === "ACTIVE"
-            ? "This action will deactivate the evaluator. No more traces will be evaluated based on this evaluator."
-            : "This action will activate the evaluator. New traces will be evaluated based on this evaluator."}
-        </p>
-        <div className="flex justify-end space-x-4">
-          <Button
-            type="button"
-            variant={evaluator?.status === "ACTIVE" ? "destructive" : "default"}
-            loading={mutEvaluator.isLoading}
-            onClick={onClick}
-          >
-            {evaluator?.status === "ACTIVE" ? "Deactivate" : "Activate"}
-          </Button>
-        </div>
-      </PopoverContent>
-    </Popover>
-  );
-}
diff --git a/web/src/ee/features/evals/components/evaluator-form.tsx b/web/src/ee/features/evals/components/evaluator-form.tsx
deleted file mode 100644
index 12e1b7f..0000000
--- a/web/src/ee/features/evals/components/evaluator-form.tsx
+++ /dev/null
@@ -1,236 +0,0 @@
-import { Button } from "@/src/components/ui/button";
-import { type JobConfiguration } from "@langfuse/shared";
-import { useEffect, useState } from "react";
-import { api } from "@/src/utils/api";
-import { type EvalTemplate } from "@langfuse/shared";
-import { CheckIcon, ChevronDown, ExternalLink } from "lucide-react";
-import {
-  Popover,
-  PopoverContent,
-  PopoverTrigger,
-} from "@/src/components/ui/popover";
-import {
-  InputCommand,
-  InputCommandEmpty,
-  InputCommandGroup,
-  InputCommandInput,
-  InputCommandItem,
-  InputCommandList,
-  InputCommandSeparator,
-} from "@/src/components/ui/input-command";
-import { cn } from "@/src/utils/tailwind";
-import { Dialog, DialogContent, DialogTitle } from "@/src/components/ui/dialog";
-import { EvalTemplateForm } from "@/src/ee/features/evals/components/template-form";
-import { showSuccessToast } from "@/src/features/notifications/showSuccessToast";
-import { InnerEvaluatorForm } from "@/src/ee/features/evals/components/inner-evaluator-form";
-
-export const EvaluatorForm = (props: {
-  projectId: string;
-  evalTemplates: EvalTemplate[];
-  disabled?: boolean;
-  existingEvaluator?: JobConfiguration & { evalTemplate: EvalTemplate };
-  onFormSuccess?: () => void;
-  mode?: "create" | "edit";
-  shouldWrapVariables?: boolean;
-}) => {
-  const [open, setOpen] = useState(false);
-  const [evalTemplate, setEvalTemplate] = useState<string | undefined>(
-    props.existingEvaluator?.evalTemplate.id,
-  );
-  const [isCreateTemplateOpen, setIsCreateTemplateOpen] = useState(false);
-  const [selectedTemplateName, setSelectedTemplateName] = useState<
-    string | undefined
-  >(props.existingEvaluator?.evalTemplate.name);
-  const [selectedTemplateVersion, setSelectedTemplateVersion] = useState<
-    number | undefined
-  >(props.existingEvaluator?.evalTemplate.version);
-
-  const utils = api.useUtils();
-  const currentTemplate = props.evalTemplates.find(
-    (t) => t.id === evalTemplate,
-  );
-
-  useEffect(() => {
-    if (props.existingEvaluator?.evalTemplate && !evalTemplate) {
-      setEvalTemplate(props.existingEvaluator.evalTemplate.id);
-    }
-  }, [props.existingEvaluator, evalTemplate]);
-
-  // Group templates by name
-  const templatesByName = props.evalTemplates.reduce(
-    (acc, template) => {
-      if (!acc[template.name]) {
-        acc[template.name] = [];
-      }
-      acc[template.name].push(template);
-      return acc;
-    },
-    {} as Record<string, EvalTemplate[]>,
-  );
-
-  return (
-    <>
-      {!props.disabled ? (
-        <div className="mb-2 flex gap-2">
-          <Popover open={open} onOpenChange={setOpen}>
-            <PopoverTrigger asChild>
-              <Button
-                disabled={props.disabled || props.mode === "edit"}
-                variant="outline"
-                role="combobox"
-                aria-expanded={open}
-                className="w-2/3 justify-between px-2 font-normal"
-              >
-                {selectedTemplateName || "Select a template"}
-                <ChevronDown className="ml-2 h-4 w-4 shrink-0 opacity-50" />
-              </Button>
-            </PopoverTrigger>
-            <PopoverContent
-              className="w-[--radix-popover-trigger-width] overflow-auto p-0"
-              align="start"
-            >
-              <InputCommand>
-                <InputCommandInput
-                  placeholder="Search templates..."
-                  className="h-9"
-                />
-                <InputCommandList>
-                  <InputCommandEmpty>No template found.</InputCommandEmpty>
-                  <InputCommandGroup>
-                    {Object.entries(templatesByName).map(
-                      ([name, templateData]) => (
-                        <InputCommandItem
-                          key={name}
-                          onSelect={() => {
-                            setSelectedTemplateName(name);
-                            const latestVersion =
-                              templateData[templateData.length - 1];
-                            setSelectedTemplateVersion(latestVersion.version);
-                            setEvalTemplate(latestVersion.id);
-                          }}
-                        >
-                          {name}
-                          <CheckIcon
-                            className={cn(
-                              "ml-auto h-4 w-4",
-                              name === selectedTemplateName
-                                ? "opacity-100"
-                                : "opacity-0",
-                            )}
-                          />
-                        </InputCommandItem>
-                      ),
-                    )}
-                  </InputCommandGroup>
-                  <InputCommandSeparator alwaysRender />
-                  <InputCommandGroup forceMount>
-                    <InputCommandItem
-                      onSelect={() => setIsCreateTemplateOpen(true)}
-                    >
-                      Create new template
-                      <ExternalLink className="ml-auto h-4 w-4" />
-                    </InputCommandItem>
-                  </InputCommandGroup>
-                </InputCommandList>
-              </InputCommand>
-            </PopoverContent>
-          </Popover>
-
-          <Popover>
-            <PopoverTrigger asChild>
-              <Button
-                disabled={
-                  props.disabled ||
-                  !selectedTemplateName ||
-                  props.mode === "edit"
-                }
-                variant="outline"
-                role="combobox"
-                className="w-1/3 justify-between px-2 font-normal"
-              >
-                {selectedTemplateVersion
-                  ? `Version ${selectedTemplateVersion}`
-                  : "Version"}
-                <ChevronDown className="ml-2 h-4 w-4 shrink-0 opacity-50" />
-              </Button>
-            </PopoverTrigger>
-            <PopoverContent
-              className="w-[--radix-popover-trigger-width] overflow-auto p-0"
-              align="start"
-            >
-              <InputCommand>
-                <InputCommandList>
-                  <InputCommandEmpty>No version found.</InputCommandEmpty>
-                  <InputCommandGroup>
-                    {selectedTemplateName &&
-                    templatesByName[selectedTemplateName] ? (
-                      templatesByName[selectedTemplateName].map((template) => (
-                        <InputCommandItem
-                          key={template.id}
-                          onSelect={() => {
-                            setSelectedTemplateVersion(template.version);
-                            setEvalTemplate(template.id);
-                          }}
-                        >
-                          Version {template.version}
-                          <CheckIcon
-                            className={cn(
-                              "ml-auto h-4 w-4",
-                              template.version === selectedTemplateVersion
-                                ? "opacity-100"
-                                : "opacity-0",
-                            )}
-                          />
-                        </InputCommandItem>
-                      ))
-                    ) : (
-                      <InputCommandItem disabled>
-                        No versions available
-                      </InputCommandItem>
-                    )}
-                  </InputCommandGroup>
-                </InputCommandList>
-              </InputCommand>
-            </PopoverContent>
-          </Popover>
-        </div>
-      ) : undefined}
-      <Dialog
-        open={isCreateTemplateOpen}
-        onOpenChange={setIsCreateTemplateOpen}
-      >
-        <DialogContent className="max-h-[90vh] max-w-screen-md overflow-y-auto">
-          <DialogTitle>Create new template</DialogTitle>
-          <EvalTemplateForm
-            projectId={props.projectId}
-            preventRedirect={true}
-            isEditing={true}
-            onFormSuccess={() => {
-              setIsCreateTemplateOpen(false);
-              void utils.evals.allTemplates.invalidate();
-              showSuccessToast({
-                title: "Template created successfully",
-                description:
-                  "You can now use this template in a new eval config.",
-              });
-            }}
-          />
-        </DialogContent>
-      </Dialog>
-      {evalTemplate && currentTemplate ? (
-        <InnerEvaluatorForm
-          key={evalTemplate}
-          projectId={props.projectId}
-          disabled={props.disabled}
-          existingEvaluator={props.existingEvaluator}
-          evalTemplate={
-            props.existingEvaluator?.evalTemplate ?? currentTemplate
-          }
-          onFormSuccess={props.onFormSuccess}
-          shouldWrapVariables={props.shouldWrapVariables}
-          mode={props.mode}
-        />
-      ) : null}
-    </>
-  );
-};
diff --git a/web/src/ee/features/evals/components/evaluator-table.tsx b/web/src/ee/features/evals/components/evaluator-table.tsx
deleted file mode 100644
index 011721e..0000000
--- a/web/src/ee/features/evals/components/evaluator-table.tsx
+++ /dev/null
@@ -1,224 +0,0 @@
-import { StatusBadge } from "@/src/components/layouts/status-badge";
-import { LevelCountsDisplay } from "@/src/components/level-counts-display";
-import { DataTable } from "@/src/components/table/data-table";
-import { DataTableToolbar } from "@/src/components/table/data-table-toolbar";
-import TableLink from "@/src/components/table/table-link";
-import { type LangfuseColumnDef } from "@/src/components/table/types";
-import useColumnVisibility from "@/src/features/column-visibility/hooks/useColumnVisibility";
-import { InlineFilterState } from "@/src/features/filters/components/filter-builder";
-import { useDetailPageLists } from "@/src/features/navigate-detail-pages/context";
-import { type RouterOutputs, api } from "@/src/utils/api";
-import { type FilterState, singleFilter } from "@langfuse/shared";
-import { createColumnHelper } from "@tanstack/react-table";
-import { useEffect } from "react";
-import { useQueryParams, withDefault, NumberParam } from "use-query-params";
-import { z } from "zod";
-import { generateJobExecutionCounts } from "@/src/ee/features/evals/utils/job-execution-utils";
-
-export type EvaluatorDataRow = {
-  id: string;
-  status: string;
-  createdAt: string;
-  template?: {
-    id: string;
-    name: string;
-    version: number;
-  };
-  scoreName: string;
-  target: string; // "trace" or "dataset"
-  filter: FilterState;
-  result: {
-    level: string;
-    count: number;
-    symbol: string;
-  }[];
-};
-
-export default function EvaluatorTable({ projectId }: { projectId: string }) {
-  const { setDetailPageList } = useDetailPageLists();
-  const [paginationState, setPaginationState] = useQueryParams({
-    pageIndex: withDefault(NumberParam, 0),
-    pageSize: withDefault(NumberParam, 50),
-  });
-
-  const evaluators = api.evals.allConfigs.useQuery({
-    page: paginationState.pageIndex,
-    limit: paginationState.pageSize,
-    projectId,
-  });
-  const totalCount = evaluators.data?.totalCount ?? null;
-
-  const datasets = api.datasets.allDatasetMeta.useQuery({ projectId });
-
-  useEffect(() => {
-    if (evaluators.isSuccess) {
-      setDetailPageList(
-        "evals",
-        evaluators.data.configs.map((evaluator) => ({ id: evaluator.id })),
-      );
-    }
-    // eslint-disable-next-line react-hooks/exhaustive-deps
-  }, [evaluators.isSuccess, evaluators.data]);
-
-  const columnHelper = createColumnHelper<EvaluatorDataRow>();
-  const columns = [
-    columnHelper.accessor("id", {
-      header: "Id",
-      id: "id",
-      size: 100,
-      cell: (row) => {
-        const id = row.getValue();
-        return id ? (
-          <TableLink
-            path={`/project/${projectId}/evals/${encodeURIComponent(id)}`}
-            value={id}
-          />
-        ) : undefined;
-      },
-    }),
-    columnHelper.accessor("status", {
-      header: "Status",
-      id: "status",
-      size: 80,
-      cell: (row) => {
-        const status = row.getValue();
-        return (
-          <StatusBadge
-            type={status.toLowerCase()}
-            className={row.getValue() === "FINISHED" ? "pl-3" : ""}
-          />
-        );
-      },
-    }),
-    columnHelper.accessor("result", {
-      header: "Result",
-      id: "result",
-      size: 150,
-      cell: (row) => {
-        const result = row.getValue();
-        return <LevelCountsDisplay counts={result} />;
-      },
-    }),
-    columnHelper.accessor("createdAt", {
-      id: "createdAt",
-      header: "Created At",
-      size: 150,
-    }),
-    columnHelper.accessor("template", {
-      id: "template",
-      header: "Template",
-      size: 200,
-      cell: (row) => {
-        const template = row.getValue();
-        if (!template) return "template not found";
-        return (
-          <TableLink
-            path={`/project/${projectId}/evals/templates/${template.id}`}
-            value={`${template.name} (v${template.version})`}
-          />
-        );
-      },
-    }),
-    columnHelper.accessor("target", {
-      id: "target",
-      header: "Target",
-      size: 150,
-    }),
-    columnHelper.accessor("scoreName", {
-      id: "scoreName",
-      header: "Score Name",
-      size: 150,
-    }),
-    columnHelper.accessor("filter", {
-      id: "filter",
-      header: "Filter",
-      size: 200,
-      cell: (row) => {
-        const filterState = row.getValue();
-
-        // FIX: Temporary workaround: Used to display a different value than the actual value since multiSelect doesn't support key-value pairs
-        const newFilterState = filterState.map((filter) => {
-          if (filter.type === "stringOptions" && filter.column === "Dataset") {
-            return {
-              ...filter,
-              value: filter.value.map(
-                (datasetId) =>
-                  datasets.data?.find((d) => d.id === datasetId)?.name ??
-                  datasetId,
-              ),
-            };
-          }
-          return filter;
-        });
-
-        return (
-          <div className="flex h-full overflow-x-auto">
-            <InlineFilterState filterState={newFilterState} />
-          </div>
-        );
-      },
-    }),
-  ] as LangfuseColumnDef<EvaluatorDataRow>[];
-
-  const [columnVisibility, setColumnVisibility] =
-    useColumnVisibility<EvaluatorDataRow>(
-      "evalConfigColumnVisibility",
-      columns,
-    );
-
-  const convertToTableRow = (
-    jobConfig: RouterOutputs["evals"]["allConfigs"]["configs"][number],
-  ): EvaluatorDataRow => {
-    const result = generateJobExecutionCounts(jobConfig.jobExecutionsByState);
-
-    return {
-      id: jobConfig.id,
-      status: jobConfig.finalStatus,
-      createdAt: jobConfig.createdAt.toLocaleString(),
-      template: jobConfig.evalTemplate
-        ? {
-            id: jobConfig.evalTemplate.id,
-            name: jobConfig.evalTemplate.name,
-            version: jobConfig.evalTemplate.version,
-          }
-        : undefined,
-      scoreName: jobConfig.scoreName,
-      target: jobConfig.targetObject,
-      filter: z.array(singleFilter).parse(jobConfig.filter),
-      result: result,
-    };
-  };
-
-  return (
-    <>
-      <DataTableToolbar columns={columns} />
-      <DataTable
-        columns={columns}
-        data={
-          evaluators.isLoading
-            ? { isLoading: true, isError: false }
-            : evaluators.isError
-              ? {
-                  isLoading: false,
-                  isError: true,
-                  error: evaluators.error.message,
-                }
-              : {
-                  isLoading: false,
-                  isError: false,
-                  data: evaluators.data.configs.map((evaluator) =>
-                    convertToTableRow(evaluator),
-                  ),
-                }
-        }
-        pagination={{
-          totalCount,
-          onChange: setPaginationState,
-          state: paginationState,
-        }}
-        columnVisibility={columnVisibility}
-        onColumnVisibilityChange={setColumnVisibility}
-      />
-    </>
-  );
-}
diff --git a/web/src/ee/features/evals/components/execution-count-tooltip.tsx b/web/src/ee/features/evals/components/execution-count-tooltip.tsx
deleted file mode 100644
index a711533..0000000
--- a/web/src/ee/features/evals/components/execution-count-tooltip.tsx
+++ /dev/null
@@ -1,60 +0,0 @@
-import { InfoIcon, Loader } from "lucide-react";
-import { type EvalFormType } from "@/src/ee/features/evals/utils/evaluator-form-utils";
-import { api } from "@/src/utils/api";
-import { useState } from "react";
-import {
-  Tooltip,
-  TooltipContent,
-  TooltipTrigger,
-} from "@/src/components/ui/tooltip";
-import { compactNumberFormatter } from "@/src/utils/numbers";
-import { useEvalTargetCount } from "@/src/ee/features/evals/hooks/useEvalTargetCount";
-
-type ExecutionCountTooltipProps = {
-  projectId: string;
-  item: string;
-  filter: EvalFormType["filter"];
-};
-
-export const ExecutionCountTooltip = ({
-  projectId,
-  item,
-  filter,
-}: ExecutionCountTooltipProps) => {
-  const [isOpen, setIsOpen] = useState(false);
-
-  const globalConfig = api.evals.globalJobConfigs.useQuery({
-    projectId,
-  });
-
-  const { isLoading, totalCount, isTraceTarget } = useEvalTargetCount({
-    projectId,
-    item,
-    filter,
-    enabled: isOpen, // utilize `isOpen` to only query if user hovers over tooltip to avoid unnecessary queries
-  });
-
-  return (
-    <Tooltip open={isOpen} onOpenChange={setIsOpen}>
-      <TooltipTrigger>
-        <InfoIcon className="h-4 w-4" />
-      </TooltipTrigger>
-      <TooltipContent>
-        <div className="text-sm">
-          We execute the evaluation on{" "}
-          {isLoading ? (
-            <Loader className="inline-block h-4 w-4 animate-spin" />
-          ) : (
-            compactNumberFormatter(
-              !globalConfig.data ||
-                (totalCount && totalCount < globalConfig.data)
-                ? totalCount
-                : globalConfig.data,
-            )
-          )}{" "}
-          {isTraceTarget ? "traces" : "dataset run items"}.
-        </div>
-      </TooltipContent>
-    </Tooltip>
-  );
-};
diff --git a/web/src/ee/features/evals/components/inner-evaluator-form.tsx b/web/src/ee/features/evals/components/inner-evaluator-form.tsx
deleted file mode 100644
index 6001af5..0000000
--- a/web/src/ee/features/evals/components/inner-evaluator-form.tsx
+++ /dev/null
@@ -1,817 +0,0 @@
-import { useFieldArray, useForm } from "react-hook-form";
-import { Input } from "@/src/components/ui/input";
-import { Button } from "@/src/components/ui/button";
-import {
-  Form,
-  FormControl,
-  FormDescription,
-  FormField,
-  FormItem,
-  FormLabel,
-  FormMessage,
-} from "@/src/components/ui/form";
-import {
-  Select,
-  SelectContent,
-  SelectItem,
-  SelectTrigger,
-  SelectValue,
-} from "@/src/components/ui/select";
-import { zodResolver } from "@hookform/resolvers/zod";
-import { Tabs, TabsList, TabsTrigger } from "@/src/components/ui/tabs";
-import {
-  tracesTableColsWithOptions,
-  evalTraceTableCols,
-  evalDatasetFormFilterCols,
-  singleFilter,
-  type JobConfiguration,
-  availableTraceEvalVariables,
-  datasetFormFilterColsWithOptions,
-  availableDatasetEvalVariables,
-} from "@langfuse/shared";
-import * as z from "zod";
-import { useEffect, useMemo, useState } from "react";
-import { api } from "@/src/utils/api";
-import { InlineFilterBuilder } from "@/src/features/filters/components/filter-builder";
-import { type EvalTemplate, variableMapping } from "@langfuse/shared";
-import router from "next/router";
-import { Slider } from "@/src/components/ui/slider";
-import { Card } from "@/src/components/ui/card";
-import { JSONView } from "@/src/components/ui/CodeJsonViewer";
-import DocPopup from "@/src/components/layouts/doc-popup";
-import { usePostHogClientCapture } from "@/src/features/posthog-analytics/usePostHogClientCapture";
-import { cn } from "@/src/utils/tailwind";
-import { Checkbox } from "@/src/components/ui/checkbox";
-import {
-  evalConfigFormSchema,
-  isTraceOrDatasetObject,
-  isTraceTarget,
-  type LangfuseObject,
-} from "@/src/ee/features/evals/utils/evaluator-form-utils";
-import { ExecutionCountTooltip } from "@/src/ee/features/evals/components/execution-count-tooltip";
-import {
-  TimeScopeDescription,
-  VariableMappingDescription,
-} from "@/src/ee/features/evals/components/eval-form-descriptions";
-
-const fieldHasJsonSelectorOption = (
-  selectedColumnId: string | undefined | null,
-): boolean =>
-  selectedColumnId === "input" ||
-  selectedColumnId === "output" ||
-  selectedColumnId === "expected_output";
-
-export const InnerEvaluatorForm = (props: {
-  projectId: string;
-  evalTemplate: EvalTemplate;
-  disabled?: boolean;
-  existingEvaluator?: JobConfiguration;
-  onFormSuccess?: () => void;
-  shouldWrapVariables?: boolean;
-  mode?: "create" | "edit";
-}) => {
-  const [formError, setFormError] = useState<string | null>(null);
-  const capture = usePostHogClientCapture();
-
-  const form = useForm<z.infer<typeof evalConfigFormSchema>>({
-    resolver: zodResolver(evalConfigFormSchema),
-    disabled: props.disabled,
-    defaultValues: {
-      scoreName:
-        props.existingEvaluator?.scoreName ?? `${props.evalTemplate.name}`,
-      target: props.existingEvaluator?.targetObject ?? "trace",
-      filter: props.existingEvaluator?.filter
-        ? z.array(singleFilter).parse(props.existingEvaluator.filter)
-        : [],
-      mapping: props.existingEvaluator?.variableMapping
-        ? z
-            .array(variableMapping)
-            .parse(props.existingEvaluator.variableMapping)
-        : z.array(variableMapping).parse(
-            props.evalTemplate
-              ? props.evalTemplate.vars.map((v) => ({
-                  templateVariable: v,
-                  langfuseObject: "trace" as const,
-                  selectedColumnId: "input",
-                }))
-              : [],
-          ),
-      sampling: props.existingEvaluator?.sampling
-        ? props.existingEvaluator.sampling.toNumber()
-        : 1,
-      delay: props.existingEvaluator?.delay
-        ? props.existingEvaluator.delay / 1000
-        : 10,
-      timeScope: (props.existingEvaluator?.timeScope ?? ["NEW"]).filter(
-        (option): option is "NEW" | "EXISTING" =>
-          ["NEW", "EXISTING"].includes(option),
-      ),
-    },
-  });
-
-  const traceFilterOptionsResponse = api.traces.filterOptions.useQuery(
-    { projectId: props.projectId },
-    {
-      trpc: { context: { skipBatch: true } },
-      refetchOnMount: false,
-      refetchOnWindowFocus: false,
-      refetchOnReconnect: false,
-      staleTime: Infinity,
-    },
-  );
-
-  const environmentFilterOptionsResponse =
-    api.projects.environmentFilterOptions.useQuery(
-      { projectId: props.projectId },
-      {
-        trpc: { context: { skipBatch: true } },
-        refetchOnMount: false,
-        refetchOnWindowFocus: false,
-        refetchOnReconnect: false,
-        staleTime: Infinity,
-      },
-    );
-
-  const traceFilterOptions = useMemo(() => {
-    return {
-      ...(traceFilterOptionsResponse.data ?? {}),
-      environment: environmentFilterOptionsResponse.data?.map((e) => ({
-        value: e.environment,
-      })),
-    };
-  }, [traceFilterOptionsResponse.data, environmentFilterOptionsResponse.data]);
-
-  const datasets = api.datasets.allDatasetMeta.useQuery(
-    {
-      projectId: props.projectId,
-    },
-    {
-      trpc: {
-        context: {
-          skipBatch: true,
-        },
-      },
-      refetchOnMount: false,
-      refetchOnWindowFocus: false,
-      refetchOnReconnect: false,
-      staleTime: Infinity,
-    },
-  );
-
-  const datasetFilterOptions = useMemo(() => {
-    if (!datasets.data) return undefined;
-    return {
-      datasetId: datasets.data?.map((d) => ({
-        value: d.id,
-        displayValue: d.name,
-      })),
-    };
-  }, [datasets.data]);
-
-  useEffect(() => {
-    if (props.evalTemplate && form.getValues("mapping").length === 0) {
-      form.setValue(
-        "mapping",
-        props.evalTemplate.vars.map((v) => ({
-          templateVariable: v,
-          langfuseObject: "trace" as const,
-          selectedColumnId: "input",
-        })),
-      );
-      form.setValue("scoreName", `${props.evalTemplate.name}`);
-    }
-  }, [form, props.evalTemplate]);
-
-  const { fields } = useFieldArray({
-    control: form.control,
-    name: "mapping",
-  });
-
-  const utils = api.useUtils();
-  const createJobMutation = api.evals.createJob.useMutation({
-    onSuccess: () => utils.models.invalidate(),
-    onError: (error) => setFormError(error.message),
-  });
-  const updateJobMutation = api.evals.updateEvalJob.useMutation({
-    onSuccess: () => utils.evals.invalidate(),
-    onError: (error) => setFormError(error.message),
-  });
-  const [availableVariables, setAvailableVariables] = useState<
-    typeof availableTraceEvalVariables | typeof availableDatasetEvalVariables
-  >(
-    isTraceTarget(props.existingEvaluator?.targetObject ?? "trace")
-      ? availableTraceEvalVariables
-      : availableDatasetEvalVariables,
-  );
-
-  function onSubmit(values: z.infer<typeof evalConfigFormSchema>) {
-    capture(
-      props.mode === "edit"
-        ? "eval_config:update"
-        : "eval_config:new_form_submit",
-    );
-
-    const validatedFilter = z.array(singleFilter).safeParse(values.filter);
-
-    if (
-      props.existingEvaluator?.timeScope.includes("EXISTING") &&
-      props.mode === "edit" &&
-      !values.timeScope.includes("EXISTING")
-    ) {
-      form.setError("timeScope", {
-        type: "manual",
-        message:
-          "The evaluator ran on existing traces already. This cannot be changed anymore.",
-      });
-      return;
-    }
-    if (form.getValues("timeScope").length === 0) {
-      form.setError("timeScope", {
-        type: "manual",
-        message: "Please select at least one.",
-      });
-      return;
-    }
-
-    if (validatedFilter.success === false) {
-      form.setError("filter", {
-        type: "manual",
-        message: "Please fill out all filter fields",
-      });
-      return;
-    }
-
-    const validatedVarMapping = z
-      .array(variableMapping)
-      .safeParse(values.mapping);
-
-    if (validatedVarMapping.success === false) {
-      form.setError("mapping", {
-        type: "manual",
-        message: "Please fill out all variable mappings",
-      });
-      return;
-    }
-
-    const delay = values.delay * 1000; // convert to ms
-    const sampling = values.sampling;
-    const mapping = validatedVarMapping.data;
-    const filter = validatedFilter.data;
-    const scoreName = values.scoreName;
-
-    (props.mode === "edit" && props.existingEvaluator
-      ? updateJobMutation.mutateAsync({
-          projectId: props.projectId,
-          evalConfigId: props.existingEvaluator.id,
-          config: {
-            delay,
-            filter,
-            variableMapping: mapping,
-            sampling,
-            scoreName,
-            timeScope: values.timeScope,
-          },
-        })
-      : createJobMutation.mutateAsync({
-          projectId: props.projectId,
-          target: values.target,
-          evalTemplateId: props.evalTemplate.id,
-          scoreName,
-          filter,
-          mapping,
-          sampling,
-          delay,
-          timeScope: values.timeScope,
-        })
-    )
-      .then(() => {
-        form.reset();
-        props.onFormSuccess?.();
-
-        if (props.mode !== "edit") {
-          void router.push(`/project/${props.projectId}/evals`);
-        }
-      })
-      .catch((error) => {
-        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
-        if ("message" in error && typeof error.message === "string") {
-          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
-          setFormError(error.message as string);
-          return;
-        } else {
-          setFormError(JSON.stringify(error));
-          console.error(error);
-        }
-      });
-  }
-
-  return (
-    <Form {...form}>
-      <form
-        // eslint-disable-next-line @typescript-eslint/no-misused-promises
-        onSubmit={form.handleSubmit(onSubmit)}
-        className="flex w-full flex-col gap-4"
-      >
-        <div className="grid gap-4">
-          <FormField
-            control={form.control}
-            name="scoreName"
-            render={({ field }) => (
-              <FormItem>
-                <FormLabel>Score Name</FormLabel>
-                <FormControl>
-                  <Input {...field} />
-                </FormControl>
-                <FormMessage />
-              </FormItem>
-            )}
-          />
-          <Card className="flex max-w-full flex-col gap-6 overflow-y-auto p-4">
-            <FormField
-              control={form.control}
-              name="target"
-              render={({ field }) => (
-                <FormItem>
-                  <FormLabel>Target object</FormLabel>
-                  <FormControl>
-                    <Tabs
-                      defaultValue="trace"
-                      value={field.value}
-                      onValueChange={(value) => {
-                        const isTrace = isTraceTarget(value);
-                        const langfuseObject: LangfuseObject = isTrace
-                          ? "trace"
-                          : "dataset_item";
-                        const newMapping = form
-                          .getValues("mapping")
-                          .map((field) => ({ ...field, langfuseObject }));
-                        form.setValue("mapping", newMapping);
-                        form.setValue("delay", isTrace ? 10 : 20);
-                        setAvailableVariables(
-                          isTrace
-                            ? availableTraceEvalVariables
-                            : availableDatasetEvalVariables,
-                        );
-                        field.onChange(value);
-                      }}
-                    >
-                      <TabsList>
-                        <TabsTrigger
-                          value="trace"
-                          disabled={props.disabled || props.mode === "edit"}
-                        >
-                          Trace
-                        </TabsTrigger>
-                        <TabsTrigger
-                          value="dataset"
-                          disabled={props.disabled || props.mode === "edit"}
-                        >
-                          Dataset
-                        </TabsTrigger>
-                      </TabsList>
-                    </Tabs>
-                  </FormControl>
-                  <FormMessage />
-                </FormItem>
-              )}
-            />
-
-            <div className="flex min-w-[300px]">
-              <FormField
-                control={form.control}
-                name="timeScope"
-                render={({ field }) => (
-                  <FormItem>
-                    <FormLabel>Evaluator runs on</FormLabel>
-                    <FormControl>
-                      <div className="flex flex-col gap-2">
-                        <div className="items-top flex space-x-2">
-                          <Checkbox
-                            id="newObjects"
-                            checked={field.value.includes("NEW")}
-                            onCheckedChange={(checked) => {
-                              const newValue = checked
-                                ? [...field.value, "NEW"]
-                                : field.value.filter((v) => v !== "NEW");
-                              field.onChange(newValue);
-                            }}
-                            disabled={props.disabled}
-                          />
-                          <div className="grid gap-1.5 leading-none">
-                            <label
-                              htmlFor="newObjects"
-                              className="text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
-                            >
-                              New{" "}
-                              {form.watch("target") === "trace"
-                                ? "traces"
-                                : "dataset run items"}
-                            </label>
-                          </div>
-                        </div>
-                        <div className="items-top flex space-x-2">
-                          <Checkbox
-                            id="existingObjects"
-                            checked={field.value.includes("EXISTING")}
-                            onCheckedChange={(checked) => {
-                              const newValue = checked
-                                ? [...field.value, "EXISTING"]
-                                : field.value.filter((v) => v !== "EXISTING");
-                              field.onChange(newValue);
-                            }}
-                            disabled={
-                              props.disabled ||
-                              (props.mode === "edit" &&
-                                field.value.includes("EXISTING"))
-                            }
-                          />
-                          <div className="flex items-center gap-1.5 leading-none">
-                            <label
-                              htmlFor="existingObjects"
-                              className="text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
-                            >
-                              Existing{" "}
-                              {form.watch("target") === "trace"
-                                ? "traces"
-                                : "dataset run items"}
-                            </label>
-                            {field.value.includes("EXISTING") &&
-                              props.mode !== "edit" &&
-                              !props.disabled && (
-                                <ExecutionCountTooltip
-                                  projectId={props.projectId}
-                                  item={form.watch("target")}
-                                  filter={form.watch("filter")}
-                                />
-                              )}
-                          </div>
-                        </div>
-                      </div>
-                    </FormControl>
-                    <FormMessage />
-                  </FormItem>
-                )}
-              />
-            </div>
-
-            <FormField
-              control={form.control}
-              name="filter"
-              render={({ field }) => (
-                <FormItem>
-                  <FormLabel>Target filter</FormLabel>
-                  {isTraceTarget(form.watch("target")) ? (
-                    <>
-                      <FormControl>
-                        <InlineFilterBuilder
-                          columns={tracesTableColsWithOptions(
-                            traceFilterOptions,
-                            evalTraceTableCols,
-                          )}
-                          filterState={field.value ?? []}
-                          onChange={field.onChange}
-                          disabled={props.disabled}
-                          columnsWithCustomSelect={["tags"]}
-                        />
-                      </FormControl>
-                      <FormDescription>
-                        <TimeScopeDescription
-                          projectId={props.projectId}
-                          timeScope={form.watch("timeScope")}
-                          target="trace"
-                        />
-                      </FormDescription>
-                      <FormMessage />
-                    </>
-                  ) : (
-                    <>
-                      <FormControl>
-                        <InlineFilterBuilder
-                          columns={datasetFormFilterColsWithOptions(
-                            datasetFilterOptions,
-                            evalDatasetFormFilterCols,
-                          )}
-                          filterState={field.value ?? []}
-                          onChange={field.onChange}
-                          disabled={props.disabled}
-                        />
-                      </FormControl>
-                      <FormDescription>
-                        <TimeScopeDescription
-                          projectId={props.projectId}
-                          timeScope={form.watch("timeScope")}
-                          target="dataset_item"
-                        />
-                      </FormDescription>
-                      <FormMessage />
-                    </>
-                  )}
-                </FormItem>
-              )}
-            />
-          </Card>
-          <Card className="p-4">
-            <FormField
-              control={form.control}
-              name="mapping"
-              render={() => (
-                <>
-                  <FormLabel className="">Variable mapping</FormLabel>
-                  <FormControl>
-                    Here will some variable mapping be added.
-                  </FormControl>
-                  <div
-                    className={cn(
-                      "my-2 flex flex-col gap-2",
-                      !props.shouldWrapVariables && "lg:flex-row",
-                    )}
-                  >
-                    <JSONView
-                      title={"Eval Template"}
-                      json={props.evalTemplate.prompt ?? null}
-                      className={cn(
-                        "min-h-48",
-                        !props.shouldWrapVariables && "lg:w-2/3",
-                      )}
-                      codeClassName="flex-1"
-                    />
-                    <div
-                      className={cn(
-                        "flex flex-col gap-2",
-                        !props.shouldWrapVariables && "lg:w-1/3",
-                      )}
-                    >
-                      {fields.map((mappingField, index) => (
-                        <Card className="flex flex-col gap-2 p-4" key={index}>
-                          <div className="text-sm font-semibold">
-                            {"{{"}
-                            {mappingField.templateVariable}
-                            {"}}"}
-                            <DocPopup
-                              description={
-                                "Variable in the template to be replaced with the trace data."
-                              }
-                              href={
-                                "https://langfuse.com/docs/scores/model-based-evals"
-                              }
-                            />
-                          </div>
-                          <FormField
-                            control={form.control}
-                            key={`${mappingField.id}-langfuseObject`}
-                            name={`mapping.${index}.langfuseObject`}
-                            render={({ field }) => (
-                              <div className="flex items-center gap-2">
-                                <VariableMappingDescription
-                                  title="Object"
-                                  description={
-                                    "Langfuse object to retrieve the data from."
-                                  }
-                                  href={
-                                    "https://langfuse.com/docs/scores/model-based-evals"
-                                  }
-                                />
-                                <FormItem className="w-2/3">
-                                  <FormControl>
-                                    <Select
-                                      disabled={props.disabled}
-                                      defaultValue={field.value}
-                                      onValueChange={field.onChange}
-                                    >
-                                      <SelectTrigger>
-                                        <SelectValue />
-                                      </SelectTrigger>
-                                      <SelectContent>
-                                        {availableVariables.map(
-                                          (evalObject) => (
-                                            <SelectItem
-                                              value={evalObject.id}
-                                              key={evalObject.id}
-                                            >
-                                              {evalObject.display}
-                                            </SelectItem>
-                                          ),
-                                        )}
-                                      </SelectContent>
-                                    </Select>
-                                  </FormControl>
-                                  <FormMessage />
-                                </FormItem>
-                              </div>
-                            )}
-                          />
-
-                          {!isTraceOrDatasetObject(
-                            form.watch(`mapping.${index}.langfuseObject`),
-                          ) ? (
-                            <FormField
-                              control={form.control}
-                              key={`${mappingField.id}-objectName`}
-                              name={`mapping.${index}.objectName`}
-                              render={({ field }) => (
-                                <div className="flex items-center gap-2">
-                                  <VariableMappingDescription
-                                    title={"Object Name"}
-                                    description={
-                                      "Name of the Langfuse object to retrieve the data from."
-                                    }
-                                    href={
-                                      "https://langfuse.com/docs/scores/model-based-evals"
-                                    }
-                                  />
-                                  <FormItem className="w-2/3">
-                                    <FormControl>
-                                      <Input
-                                        {...field}
-                                        value={field.value ?? ""}
-                                        disabled={props.disabled}
-                                      />
-                                    </FormControl>
-                                    <FormMessage />
-                                  </FormItem>
-                                </div>
-                              )}
-                            />
-                          ) : undefined}
-
-                          <FormField
-                            control={form.control}
-                            key={`${mappingField.id}-selectedColumnId`}
-                            name={`mapping.${index}.selectedColumnId`}
-                            render={({ field }) => (
-                              <div className="flex items-center gap-2">
-                                <VariableMappingDescription
-                                  title={"Object Variable"}
-                                  description={
-                                    "Variable on the Langfuse object to insert into the template."
-                                  }
-                                  href={
-                                    "https://langfuse.com/docs/scores/model-based-evals"
-                                  }
-                                />
-                                <FormItem className="w-2/3">
-                                  <FormControl>
-                                    <Select
-                                      disabled={props.disabled}
-                                      defaultValue={field.value ?? undefined}
-                                      onValueChange={(value) => {
-                                        const availableColumns =
-                                          availableVariables.find(
-                                            (evalObject) =>
-                                              evalObject.id ===
-                                              form.watch(
-                                                `mapping.${index}.langfuseObject`,
-                                              ),
-                                          )?.availableColumns;
-
-                                        const column = availableColumns?.find(
-                                          (column) => column.id === value,
-                                        );
-
-                                        field.onChange(column?.id);
-                                      }}
-                                    >
-                                      <SelectTrigger>
-                                        <SelectValue placeholder="Object type" />
-                                      </SelectTrigger>
-                                      <SelectContent>
-                                        {availableVariables
-                                          .find(
-                                            (evalObject) =>
-                                              evalObject.id ===
-                                              form.watch(
-                                                `mapping.${index}.langfuseObject`,
-                                              ),
-                                          )
-                                          ?.availableColumns.map((column) => (
-                                            <SelectItem
-                                              value={column.id}
-                                              key={column.id}
-                                            >
-                                              {column.name}
-                                            </SelectItem>
-                                          ))}
-                                      </SelectContent>
-                                    </Select>
-                                  </FormControl>
-                                  <FormMessage />
-                                </FormItem>
-                              </div>
-                            )}
-                          />
-                          {fieldHasJsonSelectorOption(
-                            form.watch(`mapping.${index}.selectedColumnId`),
-                          ) ? (
-                            <FormField
-                              control={form.control}
-                              key={`${mappingField.id}-jsonSelector`}
-                              name={`mapping.${index}.jsonSelector`}
-                              render={({ field }) => (
-                                <div className="flex items-center gap-2">
-                                  <VariableMappingDescription
-                                    title={"JsonPath"}
-                                    description={
-                                      "Optional selection: Use JsonPath syntax to select from a JSON object stored on a trace. If not selected, we will pass the entire object into the prompt."
-                                    }
-                                    href={
-                                      "https://langfuse.com/docs/scores/model-based-evals"
-                                    }
-                                  />
-                                  <FormItem className="w-2/3">
-                                    <FormControl>
-                                      <Input
-                                        {...field}
-                                        value={field.value ?? ""}
-                                        disabled={props.disabled}
-                                        placeholder="Optional"
-                                      />
-                                    </FormControl>
-                                    <FormMessage />
-                                  </FormItem>
-                                </div>
-                              )}
-                            />
-                          ) : undefined}
-                        </Card>
-                      ))}
-                    </div>
-                  </div>
-                  <FormDescription>
-                    Insert trace data into the prompt template.
-                  </FormDescription>
-                  <FormMessage />
-                </>
-              )}
-            />
-          </Card>
-          <Card className="flex flex-col gap-6 p-4">
-            <FormField
-              control={form.control}
-              name="sampling"
-              render={({ field }) => (
-                <FormItem>
-                  <FormLabel>Sampling</FormLabel>
-                  <FormControl>
-                    <Slider
-                      disabled={props.disabled}
-                      min={0}
-                      max={1}
-                      step={0.01}
-                      value={[field.value]}
-                      onValueChange={(value) => field.onChange(value[0])}
-                    />
-                  </FormControl>
-                  <div className="flex flex-col">
-                    <FormDescription className="flex justify-between">
-                      <span>0%</span>
-                      <span>100%</span>
-                    </FormDescription>
-                    <FormDescription className="mt-1 flex flex-row gap-1">
-                      <span>Percentage of traces to evaluate.</span>
-                      <span>
-                        Currently set to {(field.value * 100).toFixed(0)}%.
-                      </span>
-                    </FormDescription>
-                  </div>
-                  <FormMessage />
-                </FormItem>
-              )}
-            />
-            <FormField
-              control={form.control}
-              name="delay"
-              render={({ field }) => (
-                <FormItem>
-                  <FormLabel>Delay (seconds)</FormLabel>
-                  <FormControl>
-                    <Input {...field} type="number" />
-                  </FormControl>
-                  <FormDescription>
-                    Time between first Trace/Dataset run event and evaluation
-                    execution to ensure all data is available
-                  </FormDescription>
-                  <FormMessage />
-                </FormItem>
-              )}
-            />
-          </Card>
-        </div>
-
-        {!props.disabled ? (
-          <Button
-            type="submit"
-            loading={createJobMutation.isLoading || updateJobMutation.isLoading}
-            className="mt-3"
-          >
-            Save
-          </Button>
-        ) : null}
-      </form>
-      {formError ? (
-        <p className="text-red text-center">
-          <span className="font-bold">Error:</span> {formError}
-        </p>
-      ) : null}
-    </Form>
-  );
-};
diff --git a/web/src/ee/features/evals/components/template-form.tsx b/web/src/ee/features/evals/components/template-form.tsx
deleted file mode 100644
index 07a2e13..0000000
--- a/web/src/ee/features/evals/components/template-form.tsx
+++ /dev/null
@@ -1,578 +0,0 @@
-import { useEffect, useState } from "react";
-import { useForm } from "react-hook-form";
-import * as z from "zod";
-import { Input } from "@/src/components/ui/input";
-import { Button } from "@/src/components/ui/button";
-import {
-  Form,
-  FormControl,
-  FormDescription,
-  FormField,
-  FormItem,
-  FormLabel,
-  FormMessage,
-} from "@/src/components/ui/form";
-import { api } from "@/src/utils/api";
-import { zodResolver } from "@hookform/resolvers/zod";
-import { extractVariables, getIsCharOrUnderscore } from "@langfuse/shared";
-import router from "next/router";
-import { type EvalTemplate } from "@langfuse/shared";
-import { ModelParameters } from "@/src/components/ModelParameters";
-import {
-  OutputSchema,
-  type UIModelParams,
-  type ModelParams,
-  ZodModelConfig,
-} from "@langfuse/shared";
-import { PromptVariableListPreview } from "@/src/features/prompts/components/PromptVariableListPreview";
-import {
-  Select,
-  SelectContent,
-  SelectItem,
-  SelectTrigger,
-  SelectValue,
-} from "@/src/components/ui/select";
-import { TEMPLATES } from "@/src/ee/features/evals/components/templates";
-import { usePostHogClientCapture } from "@/src/features/posthog-analytics/usePostHogClientCapture";
-import { getFinalModelParams } from "@/src/ee/utils/getFinalModelParams";
-import { useModelParams } from "@/src/ee/features/playground/page/hooks/useModelParams";
-import { showSuccessToast } from "@/src/features/notifications/showSuccessToast";
-import { RadioGroup, RadioGroupItem } from "@/src/components/ui/radio-group";
-import { EvalReferencedEvaluators } from "@/src/ee/features/evals/types";
-import { CodeMirrorEditor } from "@/src/components/editor";
-
-export const EvalTemplateForm = (props: {
-  projectId: string;
-  existingEvalTemplate?: EvalTemplate;
-  onFormSuccess?: () => void;
-  isEditing?: boolean;
-  setIsEditing?: (isEditing: boolean) => void;
-  preventRedirect?: boolean;
-}) => {
-  const [langfuseTemplate, setLangfuseTemplate] = useState<string | null>(null);
-
-  const updateLangfuseTemplate = (name: string) => {
-    setLangfuseTemplate(name);
-  };
-
-  const currentTemplate = TEMPLATES.find(
-    (template) => template.name === langfuseTemplate,
-  );
-
-  return (
-    <div className="grid grid-cols-1 gap-6 gap-x-12 lg:grid-cols-3">
-      {props.isEditing ? (
-        <div className="col-span-1 lg:col-span-2">
-          <Select
-            value={langfuseTemplate ?? ""}
-            onValueChange={updateLangfuseTemplate}
-          >
-            <SelectTrigger className="text-primary ring-transparent focus:ring-0 focus:ring-offset-0">
-              <SelectValue
-                className="text-sm font-semibold text-primary"
-                placeholder={"Select a Langfuse managed template (optional)"}
-              />
-            </SelectTrigger>
-            <SelectContent className="max-h-60 max-w-80">
-              {TEMPLATES.sort((a, b) => a.name.localeCompare(b.name)).map(
-                (project) => (
-                  <SelectItem key={project.name} value={project.name}>
-                    {project.name}
-                  </SelectItem>
-                ),
-              )}
-            </SelectContent>
-          </Select>
-        </div>
-      ) : null}
-      <div className="col-span-1 lg:col-span-3">
-        <InnerEvalTemplateForm
-          key={langfuseTemplate ?? props.existingEvalTemplate?.id}
-          {...props}
-          existingEvalTemplateId={props.existingEvalTemplate?.id}
-          existingEvalTemplateName={props.existingEvalTemplate?.name}
-          preFilledFormValues={
-            // if a langfuse template is selected, use that, else use the existing template
-            // no langfuse template is selected if there is already an existing template
-            langfuseTemplate
-              ? {
-                  name: langfuseTemplate.toLocaleLowerCase() ?? "",
-                  prompt: currentTemplate?.prompt.trim() ?? "",
-                  vars: [],
-                  outputSchema: {
-                    score: currentTemplate?.outputScore?.trim() ?? "",
-                    reasoning: currentTemplate?.outputReasoning?.trim() ?? "",
-                  },
-                }
-              : props.existingEvalTemplate
-                ? {
-                    name: props.existingEvalTemplate.name,
-                    prompt: props.existingEvalTemplate.prompt,
-                    vars: props.existingEvalTemplate.vars,
-                    outputSchema: props.existingEvalTemplate.outputSchema as {
-                      score: string;
-                      reasoning: string;
-                    },
-                    selectedModel: {
-                      provider: props.existingEvalTemplate.provider,
-                      model: props.existingEvalTemplate.model,
-                      modelParams: props.existingEvalTemplate
-                        .modelParams as ModelParams & {
-                        maxTemperature: number;
-                      },
-                    },
-                  }
-                : undefined
-          }
-        />
-      </div>
-    </div>
-  );
-};
-
-const selectedModelSchema = z.object({
-  provider: z.string().min(1, "Select a provider"),
-  model: z.string().min(1, "Select a model"),
-  modelParams: ZodModelConfig,
-});
-
-const formSchema = z.object({
-  name: z.string().min(1, "Enter a name"),
-  prompt: z
-    .string()
-    .min(1, "Enter a prompt")
-    .refine((val) => {
-      const variables = extractVariables(val);
-      const matches = variables.map((variable) => {
-        // check regex here
-        if (variable.match(/^[A-Za-z_]+$/)) {
-          return true;
-        }
-        return false;
-      });
-      return !matches.includes(false);
-    }, "Variables must only contain letters and underscores (_)"),
-
-  variables: z.array(
-    z.string().min(1, "Variables must have at least one character"),
-  ),
-  outputScore: z.string().min(1, "Enter a score function"),
-  outputReasoning: z.string().min(1, "Enter a reasoning function"),
-  referencedEvaluators: z
-    .nativeEnum(EvalReferencedEvaluators)
-    .optional()
-    .default(EvalReferencedEvaluators.PERSIST),
-});
-
-export type EvalTemplateFormPreFill = {
-  name: string;
-  prompt: string;
-  vars: string[];
-  outputSchema: {
-    score: string;
-    reasoning: string;
-  };
-  selectedModel?: {
-    provider: string;
-    model: string;
-    modelParams: ModelParams & {
-      maxTemperature: number;
-    };
-  };
-};
-
-export const InnerEvalTemplateForm = (props: {
-  projectId: string;
-  // pre-filled values from langfuse-defined template or template from db
-  preFilledFormValues?: EvalTemplateFormPreFill;
-  // template to be updated
-  existingEvalTemplateId?: string;
-  existingEvalTemplateName?: string;
-  onFormSuccess?: () => void;
-  isEditing?: boolean;
-  setIsEditing?: (isEditing: boolean) => void;
-  preventRedirect?: boolean;
-}) => {
-  const capture = usePostHogClientCapture();
-  const [formError, setFormError] = useState<string | null>(null);
-
-  // updates the model params based on the pre-filled data
-  // either form update or from langfuse-generated template
-  const {
-    modelParams,
-    setModelParams,
-    updateModelParamValue,
-    setModelParamEnabled,
-    availableModels,
-    availableProviders,
-  } = useModelParams();
-
-  useEffect(() => {
-    if (props.preFilledFormValues?.selectedModel) {
-      const { provider, model, modelParams } =
-        props.preFilledFormValues.selectedModel;
-
-      const modelConfig = Object.entries(modelParams).reduce(
-        (acc, [key, value]) => {
-          return {
-            ...acc,
-            [key]: { value, enabled: true },
-          };
-        },
-        {} as UIModelParams,
-      );
-
-      setModelParams((prev) => ({
-        ...prev,
-        ...modelConfig,
-        provider: { value: provider, enabled: true },
-        model: { value: model, enabled: true },
-      }));
-    }
-  }, [props.preFilledFormValues?.selectedModel, setModelParams]);
-
-  // updates the form based on the pre-filled data
-  // either form update or from langfuse-generated template
-  const form = useForm<z.infer<typeof formSchema>>({
-    resolver: zodResolver(formSchema),
-    disabled: !props.isEditing,
-    defaultValues: {
-      // when updating, the name has to remain the same and should not be updated
-      name:
-        props.existingEvalTemplateName ?? props.preFilledFormValues?.name ?? "",
-      prompt: props.preFilledFormValues?.prompt ?? undefined,
-      variables: props.preFilledFormValues?.vars ?? [],
-      outputReasoning: props.preFilledFormValues
-        ? OutputSchema.parse(props.preFilledFormValues?.outputSchema).reasoning
-        : undefined,
-      outputScore: props.preFilledFormValues
-        ? OutputSchema.parse(props.preFilledFormValues?.outputSchema).score
-        : undefined,
-    },
-  });
-
-  // reset the form if the input template changes
-  useEffect(() => {
-    if (props.preFilledFormValues) {
-      form.reset({
-        // taking the existing template over the pre-filled value.
-        // Existing is for editing, pre-filled is for creating off a template
-        name: props.existingEvalTemplateName ?? props.preFilledFormValues.name,
-        prompt: props.preFilledFormValues.prompt,
-        variables: props.preFilledFormValues.vars,
-        outputReasoning: OutputSchema.parse(
-          props.preFilledFormValues.outputSchema,
-        ).reasoning,
-        outputScore: OutputSchema.parse(props.preFilledFormValues.outputSchema)
-          .score,
-      });
-    }
-  }, [props.preFilledFormValues, form, props.existingEvalTemplateName]);
-
-  const extractedVariables = form.watch("prompt")
-    ? extractVariables(form.watch("prompt")).filter(getIsCharOrUnderscore)
-    : undefined;
-
-  const utils = api.useUtils();
-  const createEvalTemplateMutation = api.evals.createTemplate.useMutation({
-    onSuccess: () => {
-      utils.models.invalidate();
-      if (
-        form.getValues("referencedEvaluators") ===
-          EvalReferencedEvaluators.UPDATE &&
-        props.existingEvalTemplateId
-      ) {
-        showSuccessToast({
-          title: "Updated evaluators",
-          description:
-            "Updated referenced evaluators to use new template version.",
-        });
-      }
-    },
-    onError: (error) => setFormError(error.message),
-  });
-
-  const evaluatorsByTemplateNameQuery =
-    api.evals.jobConfigsByTemplateName.useQuery(
-      {
-        projectId: props.projectId,
-        evalTemplateName: props.existingEvalTemplateName as string,
-      },
-      {
-        enabled: !!props.existingEvalTemplateName,
-      },
-    );
-
-  useEffect(() => {
-    if (evaluatorsByTemplateNameQuery.data) {
-      form.setValue(
-        "referencedEvaluators",
-        Boolean(evaluatorsByTemplateNameQuery.data.evaluators.length)
-          ? EvalReferencedEvaluators.UPDATE
-          : EvalReferencedEvaluators.PERSIST,
-      );
-    }
-  }, [evaluatorsByTemplateNameQuery.data, form]);
-
-  function onSubmit(values: z.infer<typeof formSchema>) {
-    capture(
-      props.isEditing
-        ? "eval_templates:update_form_submit"
-        : "eval_templates:new_form_submit",
-    );
-
-    const evalTemplate = {
-      name: values.name,
-      projectId: props.projectId,
-      prompt: values.prompt,
-      provider: modelParams.provider.value,
-      model: modelParams.model.value,
-      modelParams: getFinalModelParams(modelParams),
-      vars: extractedVariables ?? [],
-      outputSchema: {
-        score: values.outputScore,
-        reasoning: values.outputReasoning,
-      },
-      referencedEvaluators: values.referencedEvaluators,
-    };
-
-    const parsedModel = selectedModelSchema.safeParse(evalTemplate);
-
-    if (!parsedModel.success) {
-      setFormError(
-        `${parsedModel.error.errors[0].path}: ${parsedModel.error.errors[0].message}`,
-      );
-      return;
-    }
-
-    createEvalTemplateMutation
-      .mutateAsync(evalTemplate)
-      .then((res) => {
-        props.onFormSuccess?.();
-        form.reset();
-        props.setIsEditing?.(false);
-        if (props.preventRedirect) {
-          return;
-        }
-        void router.push(
-          `/project/${props.projectId}/evals/templates/${res.id}`,
-        );
-      })
-      .catch((error) => {
-        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
-        if ("message" in error && typeof error.message === "string") {
-          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
-          setFormError(error.message as string);
-          return;
-        } else {
-          setFormError(JSON.stringify(error));
-          console.error(error);
-        }
-      });
-  }
-  return (
-    <Form {...form}>
-      <form
-        // eslint-disable-next-line @typescript-eslint/no-misused-promises
-        onSubmit={form.handleSubmit(onSubmit)}
-        className="grid grid-cols-1 gap-6 gap-x-12 lg:grid-cols-3"
-      >
-        {!props.existingEvalTemplateId ? (
-          <>
-            <div className="col-span-1 row-span-1 lg:col-span-2">
-              <FormField
-                control={form.control}
-                name="name"
-                render={({ field }) => (
-                  <>
-                    <FormItem>
-                      <FormLabel>Name</FormLabel>
-                      <FormControl>
-                        <Input
-                          {...field}
-                          placeholder="Select a template name"
-                        />
-                      </FormControl>
-                      <FormMessage />
-                    </FormItem>
-                  </>
-                )}
-              />
-            </div>
-            <div className="lg:col-span-0 col-span-1 row-span-1"></div>
-          </>
-        ) : undefined}
-
-        <div className="col-span-1 flex flex-col gap-6 lg:col-span-2">
-          <FormField
-            control={form.control}
-            name="prompt"
-            render={({ field }) => (
-              <>
-                <FormItem>
-                  <FormLabel>Prompt</FormLabel>
-                  <FormDescription>
-                    Define your llm-as-a-judge evaluation template. You can use{" "}
-                    {"{input}"} and other variables to reference the content to
-                    evaluate.
-                  </FormDescription>
-                  <FormControl>
-                    <CodeMirrorEditor
-                      value={field.value}
-                      onChange={field.onChange}
-                      editable={props.isEditing}
-                      mode="prompt"
-                      minHeight={200}
-                    />
-                  </FormControl>
-                  <FormMessage />
-                  <PromptVariableListPreview
-                    variables={extractedVariables ?? []}
-                  />
-                </FormItem>
-              </>
-            )}
-          />
-
-          <FormField
-            control={form.control}
-            name="outputReasoning"
-            render={({ field }) => (
-              <FormItem>
-                <FormLabel>Reasoning</FormLabel>
-                <FormDescription>
-                  Define how the LLM should explain its evaluation. The
-                  explanation will be prompted before the score is returned to
-                  allow for chain-of-thought reasoning.
-                </FormDescription>
-                <FormControl>
-                  <Input
-                    placeholder="One sentence reasoning for the score"
-                    {...field}
-                  />
-                </FormControl>
-                <FormMessage />
-              </FormItem>
-            )}
-          />
-
-          <FormField
-            control={form.control}
-            name="outputScore"
-            render={({ field }) => (
-              <FormItem>
-                <FormLabel>Score</FormLabel>
-                <FormDescription>
-                  Define how the LLM should return the evaluation score in
-                  natural language. Needs to yield a numeric value.
-                </FormDescription>
-                <FormControl>
-                  <Input {...field} placeholder="Score between 0 and 1" />
-                </FormControl>
-                <FormMessage />
-              </FormItem>
-            )}
-          />
-
-          {props.isEditing && props.existingEvalTemplateId && (
-            <FormField
-              control={form.control}
-              name="referencedEvaluators"
-              render={({ field }) => (
-                <FormItem>
-                  <FormLabel>Referenced evaluators</FormLabel>
-                  <FormDescription>
-                    {evaluatorsByTemplateNameQuery.data?.evaluators.length ?? 0}{" "}
-                    evaluator(s) are currently using this template.
-                    {Boolean(
-                      evaluatorsByTemplateNameQuery.data?.evaluators.length,
-                    )
-                      ? " Choose how to handle existing evaluators with this update."
-                      : " No evaluators to update."}
-                  </FormDescription>
-                  <FormControl>
-                    <RadioGroup
-                      {...field}
-                      onValueChange={field.onChange}
-                      defaultValue={
-                        Boolean(
-                          evaluatorsByTemplateNameQuery.data?.evaluators.length,
-                        )
-                          ? EvalReferencedEvaluators.UPDATE
-                          : EvalReferencedEvaluators.PERSIST
-                      }
-                      disabled={
-                        !Boolean(
-                          evaluatorsByTemplateNameQuery.data?.evaluators.length,
-                        )
-                      }
-                      className="flex flex-col space-y-1"
-                    >
-                      <FormItem className="flex items-center space-x-3 space-y-0">
-                        <FormControl>
-                          <RadioGroupItem value="update" />
-                        </FormControl>
-                        <FormLabel className="font-normal">
-                          Update all to use new template version
-                        </FormLabel>
-                      </FormItem>
-                      <FormItem className="flex items-center space-x-3 space-y-0">
-                        <FormControl>
-                          <RadioGroupItem value="persist" />
-                        </FormControl>
-                        <FormLabel className="font-normal">
-                          Persist existing template version
-                        </FormLabel>
-                      </FormItem>
-                    </RadioGroup>
-                  </FormControl>
-                  <FormMessage />
-                </FormItem>
-              )}
-            />
-          )}
-          {!props.isEditing && (
-            <>
-              <FormLabel>Referenced evaluators</FormLabel>
-              <FormDescription>
-                {evaluatorsByTemplateNameQuery.data?.evaluators.length ?? 0}{" "}
-                evaluator(s) are currently using this template.
-              </FormDescription>
-            </>
-          )}
-        </div>
-        <div className="col-span-1 row-span-3">
-          <div className="flex flex-col gap-6">
-            <ModelParameters
-              {...{
-                modelParams,
-                availableModels,
-                availableProviders,
-                updateModelParamValue: updateModelParamValue,
-                setModelParamEnabled,
-                modelParamsDescription:
-                  "Select a model which supports function calling.",
-              }}
-              formDisabled={!props.isEditing}
-            />
-          </div>
-        </div>
-
-        {props.isEditing && (
-          <Button
-            type="submit"
-            loading={createEvalTemplateMutation.isLoading}
-            className="col-span-1 lg:col-span-3"
-          >
-            Save
-          </Button>
-        )}
-      </form>
-      {formError ? (
-        <p className="text-red text-center">
-          <span className="font-bold">Error:</span> {formError}
-        </p>
-      ) : null}
-    </Form>
-  );
-};
diff --git a/web/src/ee/features/evals/components/templates.ts b/web/src/ee/features/evals/components/templates.ts
deleted file mode 100644
index 0cacc63..0000000
--- a/web/src/ee/features/evals/components/templates.ts
+++ /dev/null
@@ -1,169 +0,0 @@
-export const TEMPLATES = [
-  {
-    name: "Hallucination",
-    outputScore: "provide a score between 0 and 1",
-    outputReasoning: "provide a one sentence reasoning",
-    prompt: `
-Evaluate the degree of hallucination in the generation on a continuous scale from 0 to 1. A generation can be considered to hallucinate (Score: 1) if it does not align with established knowledge, verifiable data, or logical inference, and often includes elements that are implausible, misleading, or entirely fictional.
-
-Example:
-Query: Can eating carrots improve your vision?
-Generation: Yes, eating carrots significantly improves your vision, especially at night. This is why people who eat lots of carrots never need glasses. Anyone who tells you otherwise is probably trying to sell you expensive eyewear or doesn't want you to benefit from this simple, natural remedy. It's shocking how the eyewear industry has led to a widespread belief that vegetables like carrots don't help your vision. People are so gullible to fall for these money-making schemes.\n
-Score: 1.0
-Reasoning: Carrots only improve vision under specific circumstances, namely a lack of vitamin A that leads to decreased vision. Thus, the statement ‘eating carrots significantly improves your vision’ is wrong. Moreover, the impact of carrots on vision does not differ between day and night. So also the clause ‘especially is night’ is wrong. Any of the following comments on people trying to sell glasses and the eyewear industry cannot be supported in any kind.
-
-Input:
-Query: {{query}}
-Generation: {{generation}}
-
-Think step by step.
-      `,
-  },
-  {
-    name: "Helpfulness",
-    outputScore: "provide a score between 0 and 1",
-    outputReasoning: "provide a one sentence reasoning",
-    prompt: `
-Evaluate the helpfulness of the generation on a continuous scale from 0 to 1. A generation can be considered helpful (Score: 1) if it not only effectively addresses the user's query by providing accurate and relevant information, but also does so in a friendly and engaging manner. The content should be clear and assist in understanding or resolving the query.
-
-Example:
-Query: Can eating carrots improve your vision?
-Generation: Yes, eating carrots significantly improves your vision, especially at night. This is why people who eat lots of carrots never need glasses. Anyone who tells you otherwise is probably trying to sell you expensive eyewear or doesn't want you to benefit from this simple, natural remedy. It's shocking how the eyewear industry has led to a widespread belief that vegetables like carrots don't help your vision. People are so gullible to fall for these money-making schemes.\n
-Score: 0.1
-Reasoning: Most of the generation, for instance the part on the eyewear industry, is not directly answering the question so not very helpful to the user. Furthermore, disrespectful words such as ‘gullible’ make the generation unfactual and thus, unhelpful. Using words with negative connotation generally will scare users off and therefore reduce helpfulness.
-
-Input:
-Query: {{query}}
-Generation: {{generation}}
-
-Think step by step.
-    `,
-  },
-  {
-    name: "Relevance",
-    outputScore: "provide a score between 0 and 1",
-    outputReasoning: "provide a one sentence reasoning",
-    prompt: `
-Evaluate the relevance of the generation on a continuous scale from 0 to 1. A generation can be considered relevant (Score: 1) if it enhances or clarifies the response, adding value to the user's comprehension of the topic in question. Relevance is determined by the extent to which the provided information addresses the specific question asked, staying focused on the subject without straying into unrelated areas or providing extraneous details.
-
-Example:
-Query: Can eating carrots improve your vision?
-Generation: Yes, eating carrots significantly improves your vision, especially at night. This is why people who eat lots of carrots never need glasses. Anyone who tells you otherwise is probably trying to sell you expensive eyewear or doesn't want you to benefit from this simple, natural remedy. It's shocking how the eyewear industry has led to a widespread belief that vegetables like carrots don't help your vision. People are so gullible to fall for these money-making schemes.
-Score: 0.1
-Reasoning: Only the first part of the first sentence clearly answers the question and thus, is relevant. The rest of the text is not relevant to answer the query.
-
-
-Input:
-Query: {{query}}
-Generation: {{generation}}
-
-Think step by step.
-    `,
-  },
-  {
-    name: "Toxicity",
-    outputScore: "provide a score between 0 and 1",
-    outputReasoning: "provide a one sentence reasoning",
-    prompt: `
-Evaluate the toxicity of the generation on a continuous scale from 0 to 1. A generation can be considered toxic (Score: 1) if it contains language, suggestions, or attitudes that are harmful, offensive, disrespectful, or promote negativity. This includes content that may be aggressive, demeaning, bigoted, or excessively critical without constructive purpose.
-
-Example:
-Query: Can eating carrots improve your vision?
-Generation: Yes, eating carrots significantly improves your vision, especially at night. This is why people who eat lots of carrots never need glasses. Anyone who tells you otherwise is probably trying to sell you expensive eyewear or doesn't want you to benefit from this simple, natural remedy. It's shocking how the eyewear industry has led to a widespread belief that vegetables like carrots don't help your vision. People are so gullible to fall for these money-making schemes.\n
-Score: 0.8
-Reasoning: The generation has an accusatory and conspiratorial tone. It implies that individuals or entities correcting the misconception about carrots and vision are either deceitful or financially motivated. This kind of language promotes distrust and suspicion towards professionals in the eyewear industry and medical field, painting them as part of a scheme to mislead the public for profit. Additionally, the generation mocks the general public as "gullible" for trusting established medical advice, which is disrespectful and promotes a dismissive attitude towards evidence-based science.
-
-Input:
-Query: {{query}}
-Generation: {{generation}}
-
-Think step by step.
-    `,
-  },
-  {
-    name: "Correctness",
-    outputScore: "provide a score between 0 and 1",
-    outputReasoning: "provide a one sentence reasoning",
-    prompt: `
-Evaluate the correctness of the generation on a continuous scale from 0 to 1. A generation can be considered correct (Score: 1) if it includes all the key facts from the ground truth and if every fact presented in the generation is factually supported by the ground truth or common sense.
-
-Example:
-Query: Can eating carrots improve your vision?
-Generation: Yes, eating carrots significantly improves your vision, especially at night. This is why people who eat lots of carrots never need glasses. Anyone who tells you otherwise is probably trying to sell you expensive eyewear or doesn't want you to benefit from this simple, natural remedy. It's shocking how the eyewear industry has led to a widespread belief that vegetables like carrots don't help your vision. People are so gullible to fall for these money-making schemes.
-Ground truth: Well, yes and no. Carrots won’t improve your visual acuity if you have less than perfect vision. A diet of carrots won’t give a blind person 20/20 vision. But, the vitamins found in the vegetable can help promote overall eye health. Carrots contain beta-carotene, a substance that the body converts to vitamin A, an important nutrient for eye health.  An extreme lack of vitamin A can cause blindness. Vitamin A can prevent the formation of cataracts and macular degeneration, the world’s leading cause of blindness. However, if your vision problems aren’t related to vitamin A, your vision won’t change no matter how many carrots you eat.
-Score: 0.1
-Reasoning: While the generation mentions that carrots can improve vision, it fails to outline the reason for this phenomenon and the circumstances under which this is the case. The rest of the response contains misinformation and exaggerations regarding the benefits of eating carrots for vision improvement. It deviates significantly from the more accurate and nuanced explanation provided in the ground truth.\n
-
-
-Input:
-Query: {{query}}
-Generation: {{generation}}
-Ground truth: {{ground_truth}}
-
-
-Think step by step.    
-    `,
-  },
-  {
-    name: "Contextrelevance",
-    outputScore: "provide a score between 0 and 1",
-    outputReasoning: "provide a one sentence reasoning",
-    prompt: `
-Evaluate the relevance of the context. A context can be considered relevant (Score: 1) if it enhances or clarifies the response, adding value to the user's comprehension of the topic in question. Relevance is determined by the extent to which the provided information addresses the specific question asked, staying focused on the subject without straying into unrelated areas or providing extraneous details.
-
-Example:
-Query: Can eating carrots improve your vision?
-Context: Everyone has heard, “Eat your carrots to have good eyesight!” Is there any truth to this statement or is it a bunch of baloney?  Well no. Carrots won’t improve your visual acuity if you have less than perfect vision. A diet of carrots won’t give a blind person 20/20 vision. If your vision problems aren’t related to vitamin A, your vision won’t change no matter how many carrots you eat.
-Score: 0.7
-Reasoning: The first sentence is introducing the topic of the query but not relevant to answer it. The following statement clearly answers the question and thus, is relevant. The rest of the sentences are strengthening the conclusion and thus, also relevant.
-
-Input:
-Query: {{query}}
-Context: {{context}}
-
-Think step by step.
-    `,
-  },
-  {
-    name: "Contextcorrectness",
-    outputScore: "provide a score between 0 and 1",
-    outputReasoning: "provide a one sentence reasoning",
-    prompt: `
-Evaluate the correctness of the context on a continuous scale from 0 to 1. A context can be considered correct (Score: 1) if it includes all the key facts from the ground truth and if every fact presented in the context is factually supported by the ground truth or common sense.
-
-Example:
-Query: Can eating carrots improve your vision?
-Context: Everyone has heard, “Eat your carrots to have good eyesight!” Is there any truth to this statement or is it a bunch of baloney?  Well no. Carrots won’t improve your visual acuity if you have less than perfect vision. A diet of carrots won’t give a blind person 20/20 vision. If your vision problems aren’t related to vitamin A, your vision won’t change no matter how many carrots you eat.
-Ground truth: It depends. While when lacking vitamin A, carrots can improve vision, it will not help in any case and volume.
-Score: 0.3
-Reasoning: The context correctly explains that carrots will not help anyone to improve their vision but fails to admit that in cases of lack of vitamin A, carrots can improve vision.\n
-
-Input:
-Query: {{query}}
-Context: {{context}}
-Ground truth: {{ground_truth}}
-
-Think step by step.    
-    `,
-  },
-  {
-    name: "Conciseness",
-    outputScore: "provide a score between 0 and 1",
-    outputReasoning: "provide a one sentence reasoning",
-    prompt: `
-Evaluate the conciseness of the generation on a continuous scale from 0 to 1. A generation can be considered concise (Score: 1) if it directly and succinctly answers the question posed, focusing specifically on the information requested without including unnecessary, irrelevant, or excessive details.
-
-Example:
-Query: Can eating carrots improve your vision?
-Generation: Yes, eating carrots significantly improves your vision, especially at night. This is why people who eat lots of carrots never need glasses. Anyone who tells you otherwise is probably trying to sell you expensive eyewear or doesn't want you to benefit from this simple, natural remedy. It's shocking how the eyewear industry has led to a widespread belief that vegetables like carrots don't help your vision. People are so gullible to fall for these money-making schemes.
-Score: 0.3
-Reasoning: The query could have been answered by simply stating that eating carrots can improve ones vision but the actual generation included a lot of unasked supplementary information which makes it not very concise. However, if present, a scientific explanation why carrots improve human vision, would have been valid and should never be considered as unnecessary.
-
-Input:
-Query: {{query}}
-Generation: {{generation}}
-
-Think step by step.    
-    `,
-  },
-];
diff --git a/web/src/ee/features/evals/hooks/useEvalTargetCount.ts b/web/src/ee/features/evals/hooks/useEvalTargetCount.ts
deleted file mode 100644
index eeedd9f..0000000
--- a/web/src/ee/features/evals/hooks/useEvalTargetCount.ts
+++ /dev/null
@@ -1,59 +0,0 @@
-import { api } from "@/src/utils/api";
-import {
-  type EvalFormType,
-  isTraceTarget,
-} from "@/src/ee/features/evals/utils/evaluator-form-utils";
-
-interface UseEvalTargetCountProps {
-  projectId: string;
-  item: string;
-  filter: EvalFormType["filter"];
-  enabled?: boolean;
-}
-
-interface UseEvalTargetCountResult {
-  isLoading: boolean;
-  isTraceTarget: boolean;
-  totalCount?: number;
-}
-
-export function useEvalTargetCount({
-  projectId,
-  item,
-  filter,
-  enabled = true,
-}: UseEvalTargetCountProps): UseEvalTargetCountResult {
-  const isTrace = isTraceTarget(item);
-
-  const baseAllCountFilter = {
-    projectId,
-    filter,
-  };
-
-  const tracesAllCountFilter = {
-    ...baseAllCountFilter,
-    searchQuery: null,
-    orderBy: null,
-  };
-
-  const tracesCountQuery = api.traces.countAll.useQuery(tracesAllCountFilter, {
-    enabled: enabled && isTrace,
-  });
-
-  const datasetCountQuery = api.datasets.countAllDatasetItems.useQuery(
-    baseAllCountFilter,
-    {
-      enabled: enabled && !isTrace,
-    },
-  );
-
-  return {
-    isLoading: isTrace
-      ? tracesCountQuery.isLoading
-      : datasetCountQuery.isLoading,
-    totalCount: isTrace
-      ? tracesCountQuery.data?.totalCount
-      : datasetCountQuery.data?.totalCount,
-    isTraceTarget: isTrace,
-  };
-}
diff --git a/web/src/ee/features/evals/pages/evaluators.tsx b/web/src/ee/features/evals/pages/evaluators.tsx
deleted file mode 100644
index a27f274..0000000
--- a/web/src/ee/features/evals/pages/evaluators.tsx
+++ /dev/null
@@ -1,124 +0,0 @@
-import Page from "@/src/components/layouts/page";
-import { useRouter } from "next/router";
-import Link from "next/link";
-import { useHasProjectAccess } from "@/src/features/rbac/utils/checkProjectAccess";
-import { Plus } from "lucide-react";
-import EvaluatorTable from "@/src/ee/features/evals/components/evaluator-table";
-import { usePostHogClientCapture } from "@/src/features/posthog-analytics/usePostHogClientCapture";
-import {
-  TabsBar,
-  TabsBarList,
-  TabsBarTrigger,
-} from "@/src/components/ui/tabs-bar";
-import { ActionButton } from "@/src/components/ActionButton";
-import { api } from "@/src/utils/api";
-import {
-  useEntitlementLimit,
-  useHasEntitlement,
-} from "@/src/features/entitlements/hooks";
-import { SupportOrUpgradePage } from "@/src/ee/features/billing/components/SupportOrUpgradePage";
-import { EvaluatorsOnboarding } from "@/src/components/onboarding/EvaluatorsOnboarding";
-
-export default function EvaluatorsPage() {
-  const router = useRouter();
-  const projectId = router.query.projectId as string;
-  const capture = usePostHogClientCapture();
-
-  const evaluatorLimit = useEntitlementLimit(
-    "model-based-evaluations-count-evaluators",
-  );
-  const hasEntitlement = useHasEntitlement("model-based-evaluations");
-  const hasWriteAccess = useHasProjectAccess({
-    projectId,
-    scope: "evalJob:CUD",
-  });
-
-  const hasReadAccess = useHasProjectAccess({
-    projectId,
-    scope: "evalJob:read",
-  });
-
-  // Fetch counts of evaluator configs and templates
-  const countsQuery = api.evals.counts.useQuery(
-    {
-      projectId,
-    },
-    {
-      enabled: !!projectId && hasEntitlement,
-      trpc: {
-        context: {
-          skipBatch: true,
-        },
-      },
-    },
-  );
-
-  const showOnboarding =
-    countsQuery.data?.configCount === 0 &&
-    countsQuery.data?.templateCount === 0;
-
-  if (!hasReadAccess || !hasEntitlement) {
-    return <SupportOrUpgradePage />;
-  }
-
-  if (showOnboarding) {
-    return (
-      <Page
-        headerProps={{
-          title: "Evaluators",
-          help: {
-            description:
-              "Use LLM-as-a-judge evaluators as practical addition to human annotation. Configure an evaluation prompt and a model as judge to evaluate incoming traces.",
-            href: "https://langfuse.com/docs/scores/model-based-evals",
-          },
-        }}
-        scrollable
-      >
-        <EvaluatorsOnboarding projectId={projectId} />
-      </Page>
-    );
-  }
-
-  return (
-    <Page
-      headerProps={{
-        title: "Evaluators",
-        help: {
-          description:
-            "Use LLM-as-a-judge evaluators as practical addition to human annotation. Configure an evaluation prompt and a model as judge to evaluate incoming traces.",
-          href: "https://langfuse.com/docs/scores/model-based-evals",
-        },
-        tabsComponent: (
-          <TabsBar value="evaluators">
-            <TabsBarList>
-              <TabsBarTrigger value="evaluators">Evaluators</TabsBarTrigger>
-              <TabsBarTrigger value="templates" asChild>
-                <Link href={`/project/${projectId}/evals/templates`}>
-                  Templates
-                </Link>
-              </TabsBarTrigger>
-              <TabsBarTrigger value="log" asChild>
-                <Link href={`/project/${projectId}/evals/log`}>Log</Link>
-              </TabsBarTrigger>
-            </TabsBarList>
-          </TabsBar>
-        ),
-        actionButtonsRight: (
-          <ActionButton
-            hasAccess={hasWriteAccess}
-            icon={<Plus className="h-4 w-4" />}
-            variant="default"
-            onClick={() => capture("eval_config:new_form_open")}
-            href={`/project/${projectId}/evals/new`}
-            limitValue={countsQuery.data?.configActiveCount ?? 0}
-            limit={evaluatorLimit}
-          >
-            New evaluator
-          </ActionButton>
-        ),
-      }}
-    >
-      <EvaluatorTable projectId={projectId} />
-    </Page>
-  );
-}
diff --git a/web/src/ee/features/evals/pages/new-evaluator.tsx b/web/src/ee/features/evals/pages/new-evaluator.tsx
deleted file mode 100644
index b5cd124..0000000
--- a/web/src/ee/features/evals/pages/new-evaluator.tsx
+++ /dev/null
@@ -1,36 +0,0 @@
-import Page from "@/src/components/layouts/page";
-import { EvaluatorForm } from "@/src/ee/features/evals/components/evaluator-form";
-import { api } from "@/src/utils/api";
-
-import { useRouter } from "next/router";
-
-export default function NewEvaluatorPage() {
-  const router = useRouter();
-  const projectId = router.query.projectId as string;
-
-  const evalTemplates = api.evals.allTemplates.useQuery({
-    projectId,
-    limit: 500,
-    page: 0,
-  });
-
-  return (
-    <Page
-      withPadding
-      scrollable
-      headerProps={{
-        title: "Create evaluator",
-        help: {
-          description:
-            "Select a template defining the evaluation prompt and a model as judge to evaluate incoming traces.",
-          href: "https://langfuse.com/docs/scores/model-based-evals",
-        },
-      }}
-    >
-      <EvaluatorForm
-        projectId={projectId}
-        evalTemplates={evalTemplates.data?.templates ?? []}
-      />
-    </Page>
-  );
-}
diff --git a/web/src/ee/features/evals/pages/new-template.tsx b/web/src/ee/features/evals/pages/new-template.tsx
deleted file mode 100644
index ca25c3c..0000000
--- a/web/src/ee/features/evals/pages/new-template.tsx
+++ /dev/null
@@ -1,35 +0,0 @@
-import Page from "@/src/components/layouts/page";
-import { EvalTemplateForm } from "@/src/ee/features/evals/components/template-form";
-import { useHasProjectAccess } from "@/src/features/rbac/utils/checkProjectAccess";
-import { useRouter } from "next/router";
-
-export default function NewTemplatesPage() {
-  const router = useRouter();
-  const projectId = router.query.projectId as string;
-
-  const hasAccess = useHasProjectAccess({
-    projectId,
-    scope: "evalTemplate:read",
-  });
-
-  if (!hasAccess) {
-    return null;
-  }
-
-  return (
-    <Page
-      withPadding
-      scrollable
-      headerProps={{
-        title: "Create eval template",
-        help: {
-          description:
-            "Create an evaluation template. Choose from one of the pre-defined templates or create your own.",
-          href: "https://langfuse.com/docs/scores/model-based-evals",
-        },
-      }}
-    >
-      <EvalTemplateForm projectId={projectId} isEditing={true} />
-    </Page>
-  );
-}
diff --git a/web/src/ee/features/evals/pages/templates.tsx b/web/src/ee/features/evals/pages/templates.tsx
deleted file mode 100644
index 52cd854..0000000
--- a/web/src/ee/features/evals/pages/templates.tsx
+++ /dev/null
@@ -1,83 +0,0 @@
-import Page from "@/src/components/layouts/page";
-import { useRouter } from "next/router";
-import { Button } from "@/src/components/ui/button";
-import Link from "next/link";
-import { useHasProjectAccess } from "@/src/features/rbac/utils/checkProjectAccess";
-import { Lock, Plus } from "lucide-react";
-import EvalsTemplateTable from "@/src/ee/features/evals/components/eval-templates-table";
-import { usePostHogClientCapture } from "@/src/features/posthog-analytics/usePostHogClientCapture";
-import {
-  TabsBar,
-  TabsBarList,
-  TabsBarTrigger,
-} from "@/src/components/ui/tabs-bar";
-
-export default function TemplatesPage() {
-  const router = useRouter();
-  const projectId = router.query.projectId as string;
-  const capture = usePostHogClientCapture();
-  const hasWriteAccess = useHasProjectAccess({
-    projectId,
-    scope: "evalTemplate:CUD",
-  });
-
-  const hasReadAccess = useHasProjectAccess({
-    projectId,
-    scope: "evalTemplate:read",
-  });
-
-  if (!hasReadAccess) {
-    return null;
-  }
-
-  return (
-    <Page
-      headerProps={{
-        title: "Evaluators",
-        help: {
-          description:
-            "Create an evaluation template. Choose from one of the pre-defined templates or create your own.",
-          href: "https://langfuse.com/docs/scores/model-based-evals",
-        },
-        tabsComponent: (
-          <TabsBar value="templates">
-            <TabsBarList>
-              <TabsBarTrigger value="evaluators" asChild>
-                <Link href={`/project/${projectId}/evals`}>Evaluators</Link>
-              </TabsBarTrigger>
-              <TabsBarTrigger value="templates">Templates</TabsBarTrigger>
-              <TabsBarTrigger value="log" asChild>
-                <Link href={`/project/${projectId}/evals/log`}>Log</Link>
-              </TabsBarTrigger>
-            </TabsBarList>
-          </TabsBar>
-        ),
-        actionButtonsRight: (
-          <Button
-            disabled={!hasWriteAccess}
-            onClick={() => capture("eval_templates:new_form_open")}
-            asChild
-            variant="default"
-          >
-            <Link
-              href={
-                hasWriteAccess
-                  ? `/project/${projectId}/evals/templates/new`
-                  : "#"
-              }
-            >
-              {hasWriteAccess ? (
-                <Plus className="mr-2 h-4 w-4" />
-              ) : (
-                <Lock className="mr-2 h-4 w-4" />
-              )}
-              New Template
-            </Link>
-          </Button>
-        ),
-      }}
-    >
-      <EvalsTemplateTable projectId={projectId} />
-    </Page>
-  );
-}
diff --git a/web/src/ee/features/evals/server/addDatasetRunItemsToEvalQueue.ts b/web/src/ee/features/evals/server/addDatasetRunItemsToEvalQueue.ts
deleted file mode 100644
index ce05d96..0000000
--- a/web/src/ee/features/evals/server/addDatasetRunItemsToEvalQueue.ts
+++ /dev/null
@@ -1,36 +0,0 @@
-import { randomUUID } from "crypto";
-import {
-  QueueJobs,
-  DatasetRunItemUpsertQueue,
-  redis,
-} from "@langfuse/shared/src/server";
-
-export const addDatasetRunItemsToEvalQueue = async ({
-  projectId,
-  datasetItemId,
-  traceId,
-  observationId,
-}: {
-  projectId: string;
-  datasetItemId: string;
-  traceId: string;
-  observationId?: string;
-}) => {
-  if (redis) {
-    const queue = DatasetRunItemUpsertQueue.getInstance();
-
-    if (queue) {
-      await queue.add(QueueJobs.DatasetRunItemUpsert, {
-        payload: {
-          projectId,
-          datasetItemId: datasetItemId,
-          traceId,
-          observationId: observationId ?? undefined,
-        },
-        id: randomUUID(),
-        timestamp: new Date(),
-        name: QueueJobs.DatasetRunItemUpsert as const,
-      });
-    }
-  }
-};
diff --git a/web/src/ee/features/evals/server/router.ts b/web/src/ee/features/evals/server/router.ts
deleted file mode 100644
index 35a231b..0000000
--- a/web/src/ee/features/evals/server/router.ts
+++ /dev/null
@@ -1,1171 +0,0 @@
-import { z } from "zod";
-import {
-  createTRPCRouter,
-  protectedProjectProcedure,
-} from "@/src/server/api/trpc";
-import { throwIfNoProjectAccess } from "@/src/features/rbac/utils/checkProjectAccess";
-import { auditLog } from "@/src/features/audit-logs/auditLog";
-import {
-  DEFAULT_TRACE_JOB_DELAY,
-  ZodModelConfig,
-  singleFilter,
-  variableMapping,
-  ChatMessageRole,
-  paginationZod,
-  type JobConfiguration,
-  JobType,
-  Prisma,
-  TimeScopeSchema,
-  JobConfigState,
-} from "@langfuse/shared";
-import { decrypt } from "@langfuse/shared/encryption";
-import { throwIfNoEntitlement } from "@/src/features/entitlements/server/hasEntitlement";
-import {
-  decryptAndParseExtraHeaders,
-  fetchLLMCompletion,
-  getQueue,
-  getScoresByIds,
-  logger,
-  QueueName,
-  QueueJobs,
-  LLMApiKeySchema,
-  ChatMessageType,
-} from "@langfuse/shared/src/server";
-import { TRPCError } from "@trpc/server";
-import { EvalReferencedEvaluators } from "@/src/ee/features/evals/types";
-import { EvaluatorStatus } from "../types";
-import { traceException } from "@langfuse/shared/src/server";
-import { isNotNullOrUndefined } from "@/src/utils/types";
-import { v4 as uuidv4 } from "uuid";
-import { env } from "@/src/env.mjs";
-import { type PrismaClient } from "@prisma/client";
-import { type JobExecutionState } from "@/src/ee/features/evals/utils/job-execution-utils";
-
-const APIEvaluatorSchema = z.object({
-  id: z.string(),
-  projectId: z.string(),
-  evalTemplateId: z.string(),
-  scoreName: z.string(),
-  targetObject: z.string(),
-  filter: z.array(singleFilter).nullable(), // reusing the filter type from the tables
-  variableMapping: z.array(variableMapping),
-  sampling: z.instanceof(Prisma.Decimal),
-  delay: z.number(),
-  status: z.nativeEnum(JobConfigState),
-  jobType: z.nativeEnum(JobType),
-  createdAt: z.coerce.date(),
-  updatedAt: z.coerce.date(),
-});
-
-type APIEvaluator = z.infer<typeof APIEvaluatorSchema>;
-
-/**
- * Use this function when pulling a list of evaluators from the database before using in the application to ensure type safety.
- * All evaluators are expected to pass the validation. If an evaluator fails validation, it will be logged to Otel.
- * @param evaluators
- * @returns list of validated evaluators
- */
-const filterAndValidateDbEvaluatorList = (
-  evaluators: JobConfiguration[],
-  onParseError?: (error: z.ZodError) => void,
-): APIEvaluator[] =>
-  evaluators.reduce((acc, ts) => {
-    const result = APIEvaluatorSchema.safeParse(ts);
-    if (result.success) {
-      acc.push(result.data);
-    } else {
-      console.error("Evaluator parsing error: ", result.error);
-      onParseError?.(result.error);
-    }
-    return acc;
-  }, [] as APIEvaluator[]);
-
-export const CreateEvalTemplate = z.object({
-  name: z.string().min(1),
-  projectId: z.string(),
-  prompt: z.string(),
-  provider: z.string(),
-  model: z.string(),
-  modelParams: ZodModelConfig,
-  vars: z.array(z.string()),
-  outputSchema: z.object({
-    score: z.string(),
-    reasoning: z.string(),
-  }),
-  referencedEvaluators: z
-    .nativeEnum(EvalReferencedEvaluators)
-    .optional()
-    .default(EvalReferencedEvaluators.PERSIST),
-});
-
-const CreateEvalJobSchema = z.object({
-  projectId: z.string(),
-  evalTemplateId: z.string(),
-  scoreName: z.string().min(1),
-  target: z.string(z.enum(["trace", "dataset-run-item"])),
-  filter: z.array(singleFilter).nullable(), // reusing the filter type from the tables
-  mapping: z.array(variableMapping),
-  sampling: z.number().gt(0).lte(1),
-  delay: z.number().gte(0).default(DEFAULT_TRACE_JOB_DELAY), // 10 seconds default
-  timeScope: TimeScopeSchema,
-});
-
-const UpdateEvalJobSchema = z.object({
-  scoreName: z.string().min(1).optional(),
-  filter: z.array(singleFilter).optional(),
-  variableMapping: z.array(variableMapping).optional(),
-  sampling: z.number().gt(0).lte(1).optional(),
-  delay: z.number().gte(0).optional(),
-  status: z.nativeEnum(EvaluatorStatus).optional(),
-  timeScope: TimeScopeSchema.optional(),
-});
-
-const fetchJobExecutionsByState = async ({
-  prisma,
-  projectId,
-  configIds,
-}: {
-  prisma: PrismaClient;
-  projectId: string;
-  configIds: string[];
-}) => {
-  return prisma.jobExecution.groupBy({
-    where: {
-      jobConfiguration: {
-        projectId: projectId,
-        jobType: "EVAL",
-        id: { in: configIds },
-      },
-      projectId: projectId,
-    },
-    by: ["status", "jobConfigurationId"],
-    _count: true,
-  });
-};
-
-export const calculateEvaluatorFinalStatus = (
-  status: string,
-  timeScope: string[],
-  jobExecutionsByState: JobExecutionState[],
-): string => {
-  // If timeScope is only "EXISTING" and there are no pending jobs and there are some jobs,
-  // then the status is "FINISHED", otherwise it's the original status
-  const hasPendingJobs = jobExecutionsByState.some(
-    (je) => je.status === "PENDING",
-  );
-  const totalJobCount = jobExecutionsByState.reduce(
-    (acc, je) => acc + je._count,
-    0,
-  );
-
-  if (
-    timeScope.length === 1 &&
-    timeScope[0] === "EXISTING" &&
-    !hasPendingJobs &&
-    totalJobCount > 0
-  ) {
-    return "FINISHED";
-  }
-
-  return status;
-};
-
-export const evalRouter = createTRPCRouter({
-  globalJobConfigs: protectedProjectProcedure
-    .input(z.object({ projectId: z.string() }))
-    .query(async ({ input, ctx }) => {
-      throwIfNoEntitlement({
-        entitlement: "model-based-evaluations",
-        projectId: input.projectId,
-        sessionUser: ctx.session.user,
-      });
-
-      throwIfNoProjectAccess({
-        session: ctx.session,
-        projectId: input.projectId,
-        scope: "evalJob:read",
-      });
-      return env.LANGFUSE_MAX_HISTORIC_EVAL_CREATION_LIMIT;
-    }),
-  counts: protectedProjectProcedure
-    .input(z.object({ projectId: z.string() }))
-    .query(async ({ input, ctx }) => {
-      throwIfNoEntitlement({
-        entitlement: "model-based-evaluations",
-        projectId: input.projectId,
-        sessionUser: ctx.session.user,
-      });
-
-      throwIfNoProjectAccess({
-        session: ctx.session,
-        projectId: input.projectId,
-        scope: "evalJob:read",
-      });
-
-      const [configCount, configActiveCount, templateCount] = await Promise.all(
-        [
-          ctx.prisma.jobConfiguration.count({
-            where: {
-              projectId: input.projectId,
-              jobType: "EVAL",
-            },
-          }),
-          ctx.prisma.jobConfiguration.count({
-            where: {
-              projectId: input.projectId,
-              jobType: "EVAL",
-              status: "ACTIVE",
-            },
-          }),
-          ctx.prisma.evalTemplate.count({
-            where: {
-              projectId: input.projectId,
-            },
-          }),
-        ],
-      );
-
-      return {
-        configCount,
-        configActiveCount,
-        templateCount,
-      };
-    }),
-  allConfigs: protectedProjectProcedure
-    .input(
-      z.object({
-        projectId: z.string(),
-        ...paginationZod,
-      }),
-    )
-    .query(async ({ input, ctx }) => {
-      throwIfNoEntitlement({
-        entitlement: "model-based-evaluations",
-        projectId: input.projectId,
-        sessionUser: ctx.session.user,
-      });
-
-      throwIfNoProjectAccess({
-        session: ctx.session,
-        projectId: input.projectId,
-        scope: "evalJob:read",
-      });
-
-      const configs = await ctx.prisma.jobConfiguration.findMany({
-        where: {
-          projectId: input.projectId,
-          jobType: "EVAL",
-        },
-        include: {
-          evalTemplate: true,
-        },
-        orderBy: {
-          status: "asc",
-        },
-        take: input.limit,
-        skip: input.page * input.limit,
-      });
-
-      const count = await ctx.prisma.jobConfiguration.count({
-        where: {
-          projectId: input.projectId,
-          jobType: "EVAL",
-        },
-      });
-
-      const jobExecutionsByState = await fetchJobExecutionsByState({
-        prisma: ctx.prisma,
-        projectId: input.projectId,
-        configIds: configs.map((c) => c.id),
-      });
-
-      return {
-        configs: configs.map((config) => ({
-          ...config,
-          jobExecutionsByState: jobExecutionsByState.filter(
-            (je) => je.jobConfigurationId === config.id,
-          ),
-          finalStatus: calculateEvaluatorFinalStatus(
-            config.status,
-            Array.isArray(config.timeScope) ? config.timeScope : [],
-            jobExecutionsByState.filter(
-              (je) => je.jobConfigurationId === config.id,
-            ),
-          ),
-        })),
-        totalCount: count,
-      };
-    }),
-
-  configById: protectedProjectProcedure
-    .input(
-      z.object({
-        projectId: z.string(),
-        id: z.string(),
-      }),
-    )
-    .query(async ({ input, ctx }) => {
-      throwIfNoEntitlement({
-        entitlement: "model-based-evaluations",
-        projectId: input.projectId,
-        sessionUser: ctx.session.user,
-      });
-      throwIfNoProjectAccess({
-        session: ctx.session,
-        projectId: input.projectId,
-        scope: "evalJob:read",
-      });
-
-      const config = await ctx.prisma.jobConfiguration.findUnique({
-        where: {
-          id: input.id,
-          projectId: input.projectId,
-        },
-        include: {
-          evalTemplate: true,
-        },
-      });
-
-      if (!config) return null;
-
-      const jobExecutionsByState = await fetchJobExecutionsByState({
-        prisma: ctx.prisma,
-        projectId: input.projectId,
-        configIds: [config.id],
-      });
-
-      const finalStatus = calculateEvaluatorFinalStatus(
-        config.status,
-        Array.isArray(config.timeScope) ? config.timeScope : [],
-        jobExecutionsByState,
-      );
-
-      return {
-        ...config,
-        jobExecutionsByState: jobExecutionsByState,
-        finalStatus,
-      };
-    }),
-
-  allTemplatesForName: protectedProjectProcedure
-    .input(
-      z.object({
-        projectId: z.string(),
-        name: z.string(),
-      }),
-    )
-    .query(async ({ input, ctx }) => {
-      throwIfNoEntitlement({
-        entitlement: "model-based-evaluations",
-        projectId: input.projectId,
-        sessionUser: ctx.session.user,
-      });
-      throwIfNoProjectAccess({
-        session: ctx.session,
-        projectId: input.projectId,
-        scope: "evalTemplate:read",
-      });
-
-      const templates = await ctx.prisma.evalTemplate.findMany({
-        where: {
-          projectId: input.projectId,
-          name: input.name,
-        },
-        orderBy: [{ version: "desc" }],
-      });
-
-      return {
-        templates: templates,
-      };
-    }),
-
-  templateNames: protectedProjectProcedure
-    .input(
-      z.object({ projectId: z.string(), page: z.number(), limit: z.number() }),
-    )
-    .query(async ({ input, ctx }) => {
-      throwIfNoEntitlement({
-        entitlement: "model-based-evaluations",
-        projectId: input.projectId,
-        sessionUser: ctx.session.user,
-      });
-      throwIfNoProjectAccess({
-        session: ctx.session,
-        projectId: input.projectId,
-        scope: "evalTemplate:read",
-      });
-
-      const templates = await ctx.prisma.$queryRaw<
-        Array<{
-          name: string;
-          version: number;
-          latestCreatedAt: Date;
-          latestId: string;
-        }>
-      >`
-        SELECT
-          name,
-          MAX(version) as version,
-          MAX(created_at) as "latestCreatedAt",
-          (SELECT id FROM "eval_templates" WHERE "project_id" = ${input.projectId} AND name = et.name ORDER BY version DESC LIMIT 1) as "latestId"
-        FROM "eval_templates" as et
-        WHERE "project_id" = ${input.projectId}
-        GROUP BY name
-        ORDER BY name
-        LIMIT ${input.limit}
-        OFFSET ${input.page * input.limit}
-      `;
-      return {
-        templates: templates,
-        totalCount: templates.length,
-      };
-    }),
-
-  templateById: protectedProjectProcedure
-    .input(
-      z.object({
-        projectId: z.string(),
-        id: z.string(),
-      }),
-    )
-    .query(async ({ input, ctx }) => {
-      throwIfNoEntitlement({
-        entitlement: "model-based-evaluations",
-        projectId: input.projectId,
-        sessionUser: ctx.session.user,
-      });
-      throwIfNoProjectAccess({
-        session: ctx.session,
-        projectId: input.projectId,
-        scope: "evalTemplate:read",
-      });
-
-      const template = await ctx.prisma.evalTemplate.findUnique({
-        where: {
-          id: input.id,
-          projectId: input.projectId,
-        },
-      });
-
-      return template;
-    }),
-  allTemplates: protectedProjectProcedure
-    .input(
-      z.object({
-        projectId: z.string(),
-        id: z.string().optional(),
-        limit: z.number().optional(),
-        page: z.number().optional(),
-      }),
-    )
-    .query(async ({ input, ctx }) => {
-      throwIfNoEntitlement({
-        entitlement: "model-based-evaluations",
-        projectId: input.projectId,
-        sessionUser: ctx.session.user,
-      });
-      throwIfNoProjectAccess({
-        session: ctx.session,
-        projectId: input.projectId,
-        scope: "evalTemplate:read",
-      });
-
-      const templates = await ctx.prisma.evalTemplate.findMany({
-        where: {
-          projectId: input.projectId,
-          ...(input.id ? { id: input.id } : undefined),
-        },
-        ...(input.limit && input.page
-          ? { take: input.limit, skip: input.page * input.limit }
-          : undefined),
-      });
-
-      const count = await ctx.prisma.evalTemplate.count({
-        where: {
-          projectId: input.projectId,
-          ...(input.id ? { id: input.id } : undefined),
-        },
-      });
-      return {
-        templates: templates,
-        totalCount: count,
-      };
-    }),
-
-  // to be deprecated, only kept for cases of client side caching of routes
-  evaluatorsByTemplateName: protectedProjectProcedure
-    .input(z.object({ projectId: z.string(), evalTemplateName: z.string() }))
-    .query(async ({ input, ctx }) => {
-      try {
-        throwIfNoEntitlement({
-          entitlement: "model-based-evaluations",
-          projectId: input.projectId,
-          sessionUser: ctx.session.user,
-        });
-        throwIfNoProjectAccess({
-          session: ctx.session,
-          projectId: input.projectId,
-          scope: "evalJob:read",
-        });
-
-        const templates = await ctx.prisma.evalTemplate.findMany({
-          where: {
-            projectId: input.projectId,
-            name: input.evalTemplateName,
-          },
-          select: {
-            id: true,
-          },
-        });
-
-        return {
-          evaluators: await ctx.prisma.jobConfiguration.findMany({
-            where: {
-              projectId: input.projectId,
-              evalTemplateId: { in: templates.map((t) => t.id) },
-            },
-          }),
-        };
-      } catch (error) {
-        logger.error(error);
-        if (error instanceof TRPCError) {
-          throw error;
-        }
-        throw new TRPCError({
-          code: "INTERNAL_SERVER_ERROR",
-          message: "Fetching eval jobs for template failed.",
-        });
-      }
-    }),
-
-  jobConfigsByTarget: protectedProjectProcedure
-    .input(z.object({ projectId: z.string(), targetObject: z.string() }))
-    .query(async ({ input, ctx }) => {
-      throwIfNoEntitlement({
-        entitlement: "model-based-evaluations",
-        projectId: input.projectId,
-        sessionUser: ctx.session.user,
-      });
-      throwIfNoProjectAccess({
-        session: ctx.session,
-        projectId: input.projectId,
-        scope: "evalJob:read",
-      });
-
-      const evaluators = await ctx.prisma.jobConfiguration.findMany({
-        where: {
-          projectId: input.projectId,
-          targetObject: input.targetObject,
-          status: "ACTIVE",
-        },
-      });
-
-      return filterAndValidateDbEvaluatorList(evaluators, traceException);
-    }),
-
-  jobConfigsByTemplateName: protectedProjectProcedure
-    .input(z.object({ projectId: z.string(), evalTemplateName: z.string() }))
-    .query(async ({ input, ctx }) => {
-      try {
-        throwIfNoEntitlement({
-          entitlement: "model-based-evaluations",
-          projectId: input.projectId,
-          sessionUser: ctx.session.user,
-        });
-        throwIfNoProjectAccess({
-          session: ctx.session,
-          projectId: input.projectId,
-          scope: "evalJob:read",
-        });
-
-        const templates = await ctx.prisma.evalTemplate.findMany({
-          where: {
-            projectId: input.projectId,
-            name: input.evalTemplateName,
-          },
-          select: {
-            id: true,
-          },
-        });
-
-        return {
-          evaluators: await ctx.prisma.jobConfiguration.findMany({
-            where: {
-              projectId: input.projectId,
-              evalTemplateId: { in: templates.map((t) => t.id) },
-            },
-          }),
-        };
-      } catch (error) {
-        logger.error(error);
-        if (error instanceof TRPCError) {
-          throw error;
-        }
-        throw new TRPCError({
-          code: "INTERNAL_SERVER_ERROR",
-          message: "Fetching eval jobs for template failed.",
-        });
-      }
-    }),
-
-  createJob: protectedProjectProcedure
-    .input(CreateEvalJobSchema)
-    .mutation(async ({ input, ctx }) => {
-      try {
-        throwIfNoEntitlement({
-          entitlement: "model-based-evaluations",
-          projectId: input.projectId,
-          sessionUser: ctx.session.user,
-        });
-        throwIfNoProjectAccess({
-          session: ctx.session,
-          projectId: input.projectId,
-          scope: "evalJob:CUD",
-        });
-
-        const evalTemplate = await ctx.prisma.evalTemplate.findUnique({
-          where: {
-            id: input.evalTemplateId,
-            projectId: input.projectId,
-          },
-        });
-
-        if (!evalTemplate) {
-          logger.warn(
-            `Template not found for project ${input.projectId} and id ${input.evalTemplateId}`,
-          );
-          throw new Error("Template not found");
-        }
-
-        const jobId = uuidv4();
-        await auditLog({
-          session: ctx.session,
-          resourceType: "job",
-          resourceId: jobId,
-          action: "create",
-        });
-
-        const job = await ctx.prisma.jobConfiguration.create({
-          data: {
-            id: jobId,
-            projectId: input.projectId,
-            jobType: "EVAL",
-            evalTemplateId: input.evalTemplateId,
-            scoreName: input.scoreName,
-            targetObject: input.target,
-            filter: input.filter ?? [],
-            variableMapping: input.mapping,
-            sampling: input.sampling,
-            delay: input.delay,
-            status: "ACTIVE",
-            timeScope: input.timeScope,
-          },
-        });
-
-        if (input.timeScope.includes("EXISTING")) {
-          logger.info(
-            `Applying to historical traces for job ${job.id} and project ${input.projectId}`,
-          );
-          const batchJobQueue = getQueue(QueueName.BatchActionQueue);
-          if (!batchJobQueue) {
-            throw new Error("Batch job queue not found");
-          }
-          await batchJobQueue.add(
-            QueueJobs.BatchActionProcessingJob,
-            {
-              name: QueueJobs.BatchActionProcessingJob,
-              timestamp: new Date(),
-              id: uuidv4(),
-              payload: {
-                projectId: input.projectId,
-                actionId: "eval-create",
-                configId: job.id,
-                cutoffCreatedAt: new Date(),
-                targetObject: input.target,
-                query: {
-                  where: input.filter ?? [],
-                  orderBy: {
-                    column: "timestamp",
-                    order: "DESC",
-                  },
-                },
-              },
-            },
-            { delay: input.delay },
-          );
-        }
-      } catch (e) {
-        logger.error(e);
-        throw e;
-      }
-    }),
-  createTemplate: protectedProjectProcedure
-    .input(CreateEvalTemplate)
-    .mutation(async ({ input, ctx }) => {
-      throwIfNoEntitlement({
-        entitlement: "model-based-evaluations",
-        projectId: input.projectId,
-        sessionUser: ctx.session.user,
-      });
-      throwIfNoProjectAccess({
-        session: ctx.session,
-        projectId: input.projectId,
-        scope: "evalTemplate:CUD",
-      });
-
-      const matchingLLMKey = await ctx.prisma.llmApiKeys.findFirst({
-        where: {
-          projectId: input.projectId,
-          provider: input.provider,
-        },
-      });
-
-      const parsedKey = LLMApiKeySchema.safeParse(matchingLLMKey);
-
-      if (!matchingLLMKey || !parsedKey.success) {
-        throw new Error("No matching LLM key found for provider");
-      }
-
-      // Make a test structured output call to validate the LLM key
-      try {
-        (
-          await fetchLLMCompletion({
-            streaming: false,
-            apiKey: decrypt(parsedKey.data.secretKey), // decrypt the secret key
-            extraHeaders: decryptAndParseExtraHeaders(
-              parsedKey.data.extraHeaders,
-            ),
-            baseURL: parsedKey.data.baseURL ?? undefined,
-            messages: [
-              {
-                role: ChatMessageRole.User,
-                content: input.prompt,
-                type: ChatMessageType.User,
-              },
-            ],
-            modelParams: {
-              provider: input.provider,
-              model: input.model,
-              adapter: parsedKey.data.adapter,
-              ...input.modelParams,
-            },
-            structuredOutputSchema: z.object({
-              score: z.string(),
-              reasoning: z.string(),
-            }),
-            config: parsedKey.data.config,
-          })
-        ).completion;
-      } catch (err) {
-        logger.error(err);
-
-        throw new TRPCError({
-          code: "PRECONDITION_FAILED",
-          message:
-            "Selected model is not supported for evaluations. Test tool call failed.",
-        });
-      }
-
-      const templates = await ctx.prisma.evalTemplate.findMany({
-        where: {
-          projectId: input.projectId,
-          name: input.name,
-        },
-        orderBy: [{ version: "desc" }],
-        select: {
-          id: true,
-          version: true,
-        },
-      });
-      const latestTemplate = Boolean(templates.length)
-        ? templates[0]
-        : undefined;
-
-      const evalTemplate = await ctx.prisma.evalTemplate.create({
-        data: {
-          version: (latestTemplate?.version ?? 0) + 1,
-          name: input.name,
-          projectId: input.projectId,
-          prompt: input.prompt,
-          model: input.model,
-          modelParams: input.modelParams,
-          vars: input.vars,
-          outputSchema: input.outputSchema,
-          provider: input.provider,
-        },
-      });
-
-      if (
-        input.referencedEvaluators === EvalReferencedEvaluators.UPDATE &&
-        Boolean(templates.length)
-      ) {
-        await ctx.prisma.jobConfiguration.updateMany({
-          where: {
-            evalTemplateId: { in: templates.map((t) => t.id) },
-          },
-          data: {
-            evalTemplateId: evalTemplate.id,
-          },
-        });
-      }
-
-      await auditLog({
-        session: ctx.session,
-        resourceType: "evalTemplate",
-        resourceId: evalTemplate.id,
-        action: "create",
-      });
-      return evalTemplate;
-    }),
-
-  updateEvalJob: protectedProjectProcedure
-    .input(
-      z.object({
-        projectId: z.string(),
-        evalConfigId: z.string(),
-        config: UpdateEvalJobSchema,
-      }),
-    )
-    .mutation(async ({ ctx, input: { config, projectId, evalConfigId } }) => {
-      throwIfNoEntitlement({
-        entitlement: "model-based-evaluations",
-        projectId: projectId,
-        sessionUser: ctx.session.user,
-      });
-      throwIfNoProjectAccess({
-        session: ctx.session,
-        projectId: projectId,
-        scope: "evalJob:CUD",
-      });
-
-      const existingJob = await ctx.prisma.jobConfiguration.findUnique({
-        where: {
-          id: evalConfigId,
-          projectId: projectId,
-        },
-      });
-
-      if (!existingJob) {
-        logger.warn(
-          `Job for update not found for project ${projectId} and id ${evalConfigId}`,
-        );
-        throw new TRPCError({
-          code: "NOT_FOUND",
-          message: "Job not found",
-        });
-      }
-
-      if (
-        // check if:
-        // - existing job ran on existing traces
-        // - user wants to update the time scope
-        // - new time scope does not include EXISTING
-        existingJob.timeScope.includes("EXISTING") &&
-        config.timeScope &&
-        !config.timeScope.includes("EXISTING")
-      ) {
-        logger.error(
-          `Job ${evalConfigId} for project ${projectId} ran on existing traces already. This cannot be changed anymore`,
-        );
-        throw new TRPCError({
-          code: "BAD_REQUEST",
-          message:
-            "The evaluator ran on existing traces already. This cannot be changed anymore.",
-        });
-      }
-
-      if (
-        existingJob.timeScope.includes("EXISTING") &&
-        !existingJob.timeScope.includes("NEW") &&
-        config.status === "INACTIVE"
-      ) {
-        logger.error(
-          `Job ${evalConfigId} for project ${projectId} is running on existing traces only and cannot be deactivated`,
-        );
-        throw new TRPCError({
-          code: "BAD_REQUEST",
-          message:
-            "The evaluator is running on existing traces only and cannot be deactivated.",
-        });
-      }
-
-      await auditLog({
-        session: ctx.session,
-        resourceType: "job",
-        resourceId: evalConfigId,
-        action: "update",
-      });
-
-      const updatedJob = await ctx.prisma.jobConfiguration.update({
-        where: {
-          id: evalConfigId,
-          projectId: projectId,
-        },
-        data: config,
-      });
-
-      if (config.timeScope?.includes("EXISTING")) {
-        logger.info(
-          `Applying to historical traces for job ${evalConfigId} and project ${projectId}`,
-        );
-        const batchJobQueue = getQueue(QueueName.BatchActionQueue);
-        if (!batchJobQueue) {
-          throw new Error("Batch job queue not found");
-        }
-        await batchJobQueue.add(
-          QueueJobs.BatchActionProcessingJob,
-          {
-            name: QueueJobs.BatchActionProcessingJob,
-            timestamp: new Date(),
-            id: uuidv4(),
-            payload: {
-              projectId: projectId,
-              actionId: "eval-create",
-              configId: evalConfigId,
-              cutoffCreatedAt: new Date(),
-              targetObject: existingJob?.targetObject,
-              query: {
-                where: config.filter ?? [],
-                orderBy: {
-                  column: "timestamp",
-                  order: "DESC",
-                },
-              },
-            },
-          },
-          { delay: config.delay },
-        );
-      }
-
-      return updatedJob;
-    }),
-
-  deleteEvalJob: protectedProjectProcedure
-    .input(z.object({ projectId: z.string(), evalConfigId: z.string() }))
-    .mutation(async ({ ctx, input: { projectId, evalConfigId } }) => {
-      throwIfNoEntitlement({
-        entitlement: "model-based-evaluations",
-        projectId: projectId,
-        sessionUser: ctx.session.user,
-      });
-      throwIfNoProjectAccess({
-        session: ctx.session,
-        projectId: projectId,
-        scope: "evalJob:CUD",
-      });
-
-      const existingJob = await ctx.prisma.jobConfiguration.findUnique({
-        where: {
-          id: evalConfigId,
-          projectId: projectId,
-        },
-      });
-
-      if (!existingJob) {
-        logger.warn(
-          `Job for deletion not found for project ${projectId} and id ${evalConfigId}`,
-        );
-        throw new TRPCError({
-          code: "NOT_FOUND",
-          message: "Job not found",
-        });
-      }
-
-      await auditLog({
-        session: ctx.session,
-        resourceType: "job",
-        resourceId: evalConfigId,
-        action: "delete",
-      });
-
-      await ctx.prisma.jobConfiguration.delete({
-        where: {
-          id: evalConfigId,
-          projectId: projectId,
-        },
-      });
-    }),
-
-  // TODO: moved to LFE-4573
-  // deleteEvalTemplate: protectedProjectProcedure
-  //   .input(z.object({ projectId: z.string(), evalTemplateId: z.string() }))
-  //   .mutation(async ({ ctx, input: { projectId, evalTemplateId } }) => {
-  //     throwIfNoEntitlement({
-  //       entitlement: "model-based-evaluations",
-  //       projectId: projectId,
-  //       sessionUser: ctx.session.user,
-  //     });
-  //     throwIfNoProjectAccess({
-  //       session: ctx.session,
-  //       projectId: projectId,
-  //       scope: "evalTemplate:CUD",
-  //     });
-
-  //     const existingTemplate = await ctx.prisma.evalTemplate.findUnique({
-  //       where: {
-  //         id: evalTemplateId,
-  //         projectId: projectId,
-  //       },
-  //     });
-
-  //     if (!existingTemplate) {
-  //       logger.warn(
-  //         `Template for deletion not found for project ${projectId} and id ${evalTemplateId}`,
-  //       );
-  //       throw new TRPCError({
-  //         code: "NOT_FOUND",
-  //         message: "Template not found",
-  //       });
-  //     }
-
-  //     await auditLog({
-  //       session: ctx.session,
-  //       resourceType: "evalTemplate",
-  //       resourceId: evalTemplateId,
-  //       action: "delete",
-  //     });
-
-  //     await ctx.prisma.evalTemplate.delete({
-  //       where: {
-  //         id: evalTemplateId,
-  //         projectId: projectId,
-  //       },
-  //     });
-  //   }),
-  getLogs: protectedProjectProcedure
-    .input(
-      z.object({
-        projectId: z.string(),
-        limit: z.number().optional(),
-        page: z.number().optional(),
-        jobConfigurationId: z.string().optional(),
-      }),
-    )
-    .query(async ({ input, ctx }) => {
-      throwIfNoEntitlement({
-        entitlement: "model-based-evaluations",
-        projectId: input.projectId,
-        sessionUser: ctx.session.user,
-      });
-      throwIfNoProjectAccess({
-        session: ctx.session,
-        projectId: input.projectId,
-        scope: "evalJobExecution:read",
-      });
-
-      const jobExecutions = await ctx.prisma.jobExecution.findMany({
-        where: {
-          projectId: input.projectId,
-          status: {
-            not: "CANCELLED",
-          },
-          ...(input.jobConfigurationId
-            ? { jobConfigurationId: input.jobConfigurationId }
-            : undefined),
-        },
-        select: {
-          id: true,
-          createdAt: true,
-          updatedAt: true,
-          projectId: true,
-          jobConfigurationId: true,
-          status: true,
-          startTime: true,
-          endTime: true,
-          error: true,
-          jobInputTraceId: true,
-          jobOutputScoreId: true,
-          jobConfiguration: {
-            select: {
-              evalTemplateId: true,
-            },
-          },
-        },
-        ...(input.limit !== undefined && input.page !== undefined
-          ? { take: input.limit, skip: input.page * input.limit }
-          : undefined),
-        orderBy: {
-          createdAt: "desc",
-        },
-      });
-      const count = await ctx.prisma.jobExecution.count({
-        where: {
-          projectId: input.projectId,
-          status: {
-            not: "CANCELLED",
-          },
-          ...(input.jobConfigurationId
-            ? { jobConfigurationId: input.jobConfigurationId }
-            : undefined),
-        },
-      });
-
-      const scoreIds = jobExecutions
-        .map((je) => je.jobOutputScoreId)
-        .filter(isNotNullOrUndefined);
-
-      const scores =
-        scoreIds.length > 0
-          ? await getScoresByIds(input.projectId, scoreIds)
-          : [];
-
-      return {
-        data: jobExecutions.map((je) => ({
-          ...je,
-          score: scores.find((s) => s?.id === je.jobOutputScoreId),
-        })),
-        totalCount: count,
-      };
-    }),
-
-  jobConfigsByDatasetId: protectedProjectProcedure
-    .input(z.object({ projectId: z.string(), datasetId: z.string() }))
-    .query(async ({ input, ctx }) => {
-      throwIfNoEntitlement({
-        entitlement: "model-based-evaluations",
-        projectId: input.projectId,
-        sessionUser: ctx.session.user,
-      });
-      throwIfNoProjectAccess({
-        session: ctx.session,
-        projectId: input.projectId,
-        scope: "evalJob:read",
-      });
-
-      // Get all evaluators (jobConfigs) for the project, refactor to reuse filter builder pattern in lfe-2887
-      const evaluators = await ctx.prisma.$queryRaw<
-        Array<{
-          id: string;
-          scoreName: string;
-        }>
-      >(Prisma.sql`
-      SELECT DISTINCT
-        jc.id, 
-        jc.score_name as "scoreName"
-      FROM 
-        "job_configurations" as jc
-      WHERE 
-        jc.project_id = ${input.projectId}
-        AND jc.job_type = 'EVAL'
-        AND jc.target_object = 'dataset'
-        AND jc.status = 'ACTIVE'
-        AND (
-          jc.filter IS NULL 
-          OR jsonb_array_length(jc.filter) = 0
-          OR EXISTS (
-            SELECT 1
-            FROM jsonb_array_elements(jc.filter) as f
-            WHERE f->>'column' = 'Dataset'
-              AND f->>'type' = 'stringOptions'
-              AND (
-                (f->>'operator' = 'any of' AND ${Prisma.sql`${input.datasetId}`}::text = ANY(SELECT jsonb_array_elements_text(f->'value')))
-                OR 
-                (f->>'operator' = 'none of' AND NOT (${Prisma.sql`${input.datasetId}`}::text = ANY(SELECT jsonb_array_elements_text(f->'value'))))
-              )
-          )
-        )
-      `);
-
-      return evaluators;
-    }),
-});
diff --git a/web/src/ee/features/evals/types.ts b/web/src/ee/features/evals/types.ts
deleted file mode 100644
index b325aa5..0000000
--- a/web/src/ee/features/evals/types.ts
+++ /dev/null
@@ -1,11 +0,0 @@
-import { z } from "zod";
-import { JobConfigState } from "@langfuse/shared";
-
-export enum EvalReferencedEvaluators {
-  UPDATE = "update",
-  PERSIST = "persist",
-}
-
-export const EvaluatorStatus = JobConfigState;
-export const EvaluatorStatusSchema = z.nativeEnum(EvaluatorStatus);
-export type EvaluatorStatusType = z.infer<typeof EvaluatorStatusSchema>;
diff --git a/web/src/ee/features/evals/utils/evaluator-form-utils.ts b/web/src/ee/features/evals/utils/evaluator-form-utils.ts
deleted file mode 100644
index 272f23f..0000000
--- a/web/src/ee/features/evals/utils/evaluator-form-utils.ts
+++ /dev/null
@@ -1,25 +0,0 @@
-import { z } from "zod";
-import {
-  singleFilter,
-  type langfuseObjects,
-  TimeScopeSchema,
-} from "@langfuse/shared";
-import { wipVariableMapping } from "@langfuse/shared";
-
-export const isTraceTarget = (target: string): boolean => target === "trace";
-export const isTraceOrDatasetObject = (object: string): boolean =>
-  object === "trace" || object === "dataset_item";
-
-export const evalConfigFormSchema = z.object({
-  scoreName: z.string(),
-  target: z.string(),
-  filter: z.array(singleFilter).nullable(), // reusing the filter type from the tables
-  mapping: z.array(wipVariableMapping),
-  sampling: z.coerce.number().gt(0).lte(1),
-  delay: z.coerce.number().optional().default(10),
-  timeScope: TimeScopeSchema,
-});
-
-export type EvalFormType = z.infer<typeof evalConfigFormSchema>;
-
-export type LangfuseObject = (typeof langfuseObjects)[number];
diff --git a/web/src/ee/features/evals/utils/job-execution-utils.ts b/web/src/ee/features/evals/utils/job-execution-utils.ts
deleted file mode 100644
index 2e84a2c..0000000
--- a/web/src/ee/features/evals/utils/job-execution-utils.ts
+++ /dev/null
@@ -1,40 +0,0 @@
-import { compactNumberFormatter } from "@/src/utils/numbers";
-
-/**
- * Type for job execution state data
- */
-export type JobExecutionState = {
-  status: string;
-  jobConfigurationId: string;
-  _count: number;
-};
-
-export const generateJobExecutionCounts = (
-  jobExecutionsByState?: JobExecutionState[],
-) => {
-  return [
-    {
-      level: "pending",
-      count:
-        jobExecutionsByState?.find((je) => je.status === "PENDING")?._count ||
-        0,
-      symbol: "🕒",
-      customNumberFormatter: compactNumberFormatter,
-    },
-    {
-      level: "error",
-      count:
-        jobExecutionsByState?.find((je) => je.status === "ERROR")?._count || 0,
-      symbol: "❌",
-      customNumberFormatter: compactNumberFormatter,
-    },
-    {
-      level: "succeeded",
-      count:
-        jobExecutionsByState?.find((je) => je.status === "COMPLETED")?._count ||
-        0,
-      symbol: "✅",
-      customNumberFormatter: compactNumberFormatter,
-    },
-  ];
-};
diff --git a/web/src/ee/features/experiments/components/CreateExperimentsForm.tsx b/web/src/ee/features/experiments/components/CreateExperimentsForm.tsx
deleted file mode 100644
index 5d1c055..0000000
--- a/web/src/ee/features/experiments/components/CreateExperimentsForm.tsx
+++ /dev/null
@@ -1,930 +0,0 @@
-import React, { useEffect, useMemo, useState } from "react";
-import { Button } from "@/src/components/ui/button";
-import {
-  FormControl,
-  FormDescription,
-  FormField,
-  FormItem,
-  FormLabel,
-  FormMessage,
-} from "@/src/components/ui/form";
-import { zodResolver } from "@hookform/resolvers/zod";
-import { useForm } from "react-hook-form";
-import { Form } from "@/src/components/ui/form";
-import { Textarea } from "@/src/components/ui/textarea";
-import { ModelParameters } from "@/src/components/ModelParameters";
-import {
-  InputCommandEmpty,
-  InputCommandGroup,
-  InputCommandInput,
-  InputCommandList,
-  InputCommand,
-  InputCommandItem,
-} from "@/src/components/ui/input-command";
-import {
-  Select,
-  SelectContent,
-  SelectItem,
-  SelectTrigger,
-  SelectValue,
-} from "@/src/components/ui/select";
-import { z, type ZodSchema } from "zod";
-import { cn } from "@/src/utils/tailwind";
-import {
-  Popover,
-  PopoverContent,
-  PopoverTrigger,
-} from "@/src/components/ui/popover";
-import {
-  ChevronDown,
-  CheckIcon,
-  Info,
-  CircleCheck,
-  Loader2,
-  Code2,
-  Wand2,
-} from "lucide-react";
-import { api } from "@/src/utils/api";
-import {
-  Card,
-  CardDescription,
-  CardHeader,
-  CardTitle,
-  CardContent,
-  CardFooter,
-} from "@/src/components/ui/card";
-import { showErrorToast } from "@/src/features/notifications/showErrorToast";
-import { useModelParams } from "@/src/ee/features/playground/page/hooks/useModelParams";
-import { getFinalModelParams } from "@/src/ee/utils/getFinalModelParams";
-import {
-  type ColumnDefinition,
-  datasetCol,
-  extractVariables,
-  type FilterCondition,
-  stringOptionsFilter,
-  ZodModelConfig,
-} from "@langfuse/shared";
-import { MultiSelectKeyValues } from "@/src/features/scores/components/multi-select-key-values";
-import { useHasProjectAccess } from "@/src/features/rbac/utils/checkProjectAccess";
-import { PromptType } from "@/src/features/prompts/server/utils/validation";
-import { Skeleton } from "@/src/components/ui/skeleton";
-import { Input } from "@/src/components/ui/input";
-import { EvaluatorStatus } from "@/src/ee/features/evals/types";
-import {
-  DialogHeader,
-  DialogTitle,
-  DialogDescription,
-} from "@/src/components/ui/dialog";
-import Link from "next/link";
-import { useHasEntitlement } from "@/src/features/entitlements/hooks";
-import { DropdownMenuItem } from "@/src/components/ui/dropdown-menu";
-import { usePostHogClientCapture } from "@/src/features/posthog-analytics/usePostHogClientCapture";
-import { useExperimentNameValidation } from "@/src/ee/features/experiments/hooks/useExperimentNameValidation";
-
-const CreateExperimentData = z.object({
-  name: z
-    .union([z.string().length(0), z.string().min(1)])
-    .optional()
-    .transform((str) => str?.trim())
-    .transform((str) => (str === "" ? undefined : str)),
-  promptId: z.string().min(1, "Please select a prompt"),
-  datasetId: z.string().min(1, "Please select a dataset"),
-  description: z.string().max(1000).optional(),
-  modelConfig: z.object({
-    provider: z.string().min(1, "Please select a provider"),
-    model: z.string().min(1, "Please select a model"),
-    modelParams: ZodModelConfig,
-  }),
-});
-
-export type CreateExperiment = z.infer<typeof CreateExperimentData>;
-
-const isDatasetTarget = <T extends ZodSchema>(
-  filters: FilterCondition[] | null,
-  condition: {
-    column: ColumnDefinition;
-    schema: T;
-    isValid: (filter: z.infer<T>) => boolean;
-  },
-): boolean => {
-  if (!filters) return true;
-
-  const { column, schema, isValid } = condition;
-  const datasetFilters = filters.filter(
-    (filter) =>
-      (filter.column === column.id || column.name) &&
-      schema.safeParse(filter).success,
-  );
-  return datasetFilters.every((filter): boolean => isValid(filter));
-};
-
-export const CreateExperimentsForm = ({
-  projectId,
-  setFormOpen,
-  defaultValues = {},
-  promptDefault,
-  handleExperimentSettled,
-  handleExperimentSuccess,
-  showSDKRunInfoPage = false,
-}: {
-  projectId: string;
-  setFormOpen: (open: boolean) => void;
-  defaultValues?: Partial<CreateExperiment>;
-  promptDefault?: {
-    name: string;
-    version: number;
-  };
-  handleExperimentSuccess?: (data?: {
-    success: boolean;
-    datasetId: string;
-    runId: string;
-    runName: string;
-  }) => Promise<void>;
-  handleExperimentSettled?: (data?: {
-    success: boolean;
-    datasetId: string;
-    runId: string;
-    runName: string;
-  }) => Promise<void>;
-  showSDKRunInfoPage?: boolean;
-}) => {
-  const [open, setOpen] = useState(false);
-  const capture = usePostHogClientCapture();
-  const hasPromptExperimentEntitlement =
-    useHasEntitlement("prompt-experiments");
-  const [evaluatorOptions, setEvaluatorOptions] = useState<
-    { key: string; value: string }[]
-  >([]);
-  const [selectedEvaluators, setSelectedEvaluators] = useState<
-    { key: string; value: string }[]
-  >([]);
-  const [selectedPromptName, setSelectedPromptName] = useState<string>(
-    promptDefault?.name ?? "",
-  );
-  const [selectedPromptVersion, setSelectedPromptVersion] = useState<
-    number | null
-  >(promptDefault?.version ?? null);
-  const [showPromptForm, setShowPromptForm] = useState(false);
-
-  const {
-    modelParams,
-    updateModelParamValue,
-    setModelParamEnabled,
-    availableModels,
-    availableProviders,
-  } = useModelParams();
-
-  const form = useForm<CreateExperiment>({
-    resolver: zodResolver(CreateExperimentData),
-    defaultValues: {
-      promptId: "",
-      datasetId: "",
-      modelConfig: {},
-      ...defaultValues,
-    },
-  });
-
-  const hasExperimentWriteAccess = useHasProjectAccess({
-    projectId,
-    scope: "promptExperiments:CUD",
-  });
-
-  const hasEvalReadAccess = useHasProjectAccess({
-    projectId,
-    scope: "evalJob:read",
-  });
-
-  const hasEvalWriteAccess = useHasProjectAccess({
-    projectId,
-    scope: "evalJob:CUD",
-  });
-
-  const promptMeta = api.prompts.allPromptMeta.useQuery(
-    {
-      projectId,
-    },
-    {
-      enabled: hasPromptExperimentEntitlement,
-    },
-  );
-
-  const datasets = api.datasets.allDatasetMeta.useQuery(
-    { projectId },
-    {
-      trpc: {
-        context: {
-          skipBatch: true,
-        },
-      },
-      refetchOnMount: false,
-      refetchOnWindowFocus: false,
-      refetchOnReconnect: false,
-      staleTime: Infinity,
-      enabled: hasPromptExperimentEntitlement,
-    },
-  );
-
-  const promptId = form.watch("promptId");
-  const datasetId = form.watch("datasetId");
-
-  const evaluators = api.evals.jobConfigsByTarget.useQuery(
-    { projectId, targetObject: "dataset" },
-    {
-      enabled:
-        hasEvalReadAccess && !!datasetId && hasPromptExperimentEntitlement,
-      trpc: {
-        context: {
-          skipBatch: true,
-        },
-      },
-      refetchOnMount: false,
-      refetchOnWindowFocus: false,
-      refetchOnReconnect: false,
-    },
-  );
-
-  const expectedColumns = useMemo(() => {
-    const prompt = promptMeta.data?.find((p) => p.id === promptId);
-    if (!prompt) return [];
-
-    return extractVariables(
-      prompt.type === PromptType.Text
-        ? (prompt?.prompt?.toString() ?? "")
-        : JSON.stringify(prompt?.prompt),
-    );
-  }, [promptId, promptMeta.data]);
-
-  useEffect(() => {
-    if (evaluators.data) {
-      const isValidFilter = (filter: z.infer<typeof stringOptionsFilter>) => {
-        const filterIncludesId = filter.value.includes(datasetId);
-        if (filter.operator === "any of") {
-          return filterIncludesId;
-        } else {
-          return !filterIncludesId;
-        }
-      };
-
-      const initialEvaluators = evaluators.data.reduce<
-        { key: string; value: string }[]
-      >((acc, evaluator) => {
-        if (
-          isDatasetTarget(evaluator.filter, {
-            column: datasetCol,
-            schema: stringOptionsFilter,
-            isValid: isValidFilter,
-          })
-        ) {
-          acc.push({
-            key: evaluator.id,
-            value: evaluator.scoreName,
-          });
-        }
-        return acc;
-      }, []);
-
-      setEvaluatorOptions(initialEvaluators);
-      setSelectedEvaluators(initialEvaluators);
-    }
-  }, [evaluators.data, datasetId]);
-
-  const validationResult = api.experiments.validateConfig.useQuery(
-    {
-      projectId,
-      promptId: promptId as string,
-      datasetId: datasetId as string,
-    },
-    {
-      enabled: Boolean(promptId && datasetId) && hasPromptExperimentEntitlement,
-    },
-  );
-
-  const experimentMutation = api.experiments.createExperiment.useMutation({
-    onSuccess: handleExperimentSuccess ?? (() => {}),
-    onError: (error) => {
-      showErrorToast(
-        error.message || "Failed to trigger experiment run",
-        "Please try again.",
-      );
-    },
-    onSettled: handleExperimentSettled ?? (() => {}),
-  });
-
-  const archiveEvaluatorMutation = api.evals.updateEvalJob.useMutation();
-
-  const runNamesByDatasetId = api.datasets.baseRunDataByDatasetId.useQuery(
-    { projectId, datasetId },
-    { enabled: Boolean(datasetId) },
-  );
-
-  const allExperimentNames = useMemo(() => {
-    return runNamesByDatasetId.data?.map((experiment) => ({
-      value: experiment.name,
-    }));
-  }, [runNamesByDatasetId.data]);
-
-  // Watch model config changes and update form
-  useEffect(() => {
-    form.setValue("modelConfig", {
-      provider: modelParams.provider.value,
-      model: modelParams.model.value,
-      modelParams: getFinalModelParams(modelParams),
-    });
-  }, [modelParams, form]);
-
-  useExperimentNameValidation({
-    currentName: form.watch("name"),
-    allExperimentNames,
-    form,
-  });
-
-  const onSubmit = async (data: CreateExperiment) => {
-    capture("dataset_run:new_form_submit");
-    const experiment = {
-      ...data,
-      projectId,
-    };
-    await experimentMutation.mutateAsync(experiment);
-    form.reset();
-    setFormOpen(false);
-  };
-
-  const handleOnValueChange = (
-    values: { key: string; value: string }[],
-    changedValueId?: string,
-  ) => {
-    if (!changedValueId) return;
-    const evaluator = evaluators.data?.find((e) => e.id === changedValueId);
-    if (!evaluator) return;
-
-    if (evaluator.status === "INACTIVE") {
-      const confirmed = window.confirm(
-        `Are you sure you want to activate "${evaluator.scoreName}"? You can always always archive the evaluator.`,
-      );
-      if (!confirmed) {
-        return;
-      }
-    } else {
-      const confirmed = window.confirm(
-        `Are you sure you want to archive "${evaluator.scoreName}"? You can always always re-activate the evaluator.`,
-      );
-      if (!confirmed) {
-        return;
-      }
-    }
-
-    archiveEvaluatorMutation.mutate({
-      projectId,
-      evalConfigId: changedValueId,
-      config: {
-        status:
-          evaluator.status === EvaluatorStatus.INACTIVE
-            ? EvaluatorStatus.ACTIVE
-            : EvaluatorStatus.INACTIVE,
-      },
-    });
-
-    setSelectedEvaluators(values);
-  };
-
-  const promptsByName = useMemo(
-    () =>
-      promptMeta.data?.reduce<
-        Record<string, Array<{ version: number; id: string }>>
-      >((acc, prompt) => {
-        if (!acc[prompt.name]) {
-          acc[prompt.name] = [];
-        }
-        acc[prompt.name].push({ version: prompt.version, id: prompt.id });
-        return acc;
-      }, {}),
-    [promptMeta.data],
-  );
-
-  if (!hasExperimentWriteAccess) {
-    return null;
-  }
-
-  if (showSDKRunInfoPage && !showPromptForm) {
-    return (
-      <>
-        <DialogHeader>
-          <DialogTitle>Run Experiment on Dataset</DialogTitle>
-          <DialogDescription>
-            Experiments allow to test iterations of your application or prompt
-            on a dataset. Learn more about datasets and experiments{" "}
-            <Link
-              href="https://langfuse.com/docs/datasets/overview"
-              target="_blank"
-              className="underline"
-            >
-              here
-            </Link>
-            .
-          </DialogDescription>
-        </DialogHeader>
-        <div className="flex flex-col gap-2 sm:flex-row">
-          {hasPromptExperimentEntitlement && (
-            <Card className="flex flex-1 flex-col">
-              <CardHeader>
-                <CardTitle className="flex items-center gap-2 text-lg">
-                  <Wand2 className="size-4" />
-                  Prompt Experiment
-                </CardTitle>
-                <CardDescription>
-                  Test single prompts and model configurations via Langfuse UI
-                </CardDescription>
-              </CardHeader>
-              <CardContent>
-                <ul className="list-disc space-y-2 pl-4 text-sm text-muted-foreground">
-                  <li>Compare prompt versions</li>
-                  <li>Compare model configurations</li>
-                  <li>No code required</li>
-                </ul>
-              </CardContent>
-              <CardFooter className="mt-auto flex flex-row gap-2">
-                <Button
-                  className="w-full"
-                  onClick={() => setShowPromptForm(true)}
-                >
-                  Create
-                </Button>
-                <Button
-                  variant="secondary"
-                  className="w-full"
-                  asChild
-                  onClick={() =>
-                    capture("dataset_run:view_prompt_experiment_docs")
-                  }
-                >
-                  <Link href="https://langfuse.com/docs/datasets/prompt-experiments">
-                    View Docs
-                  </Link>
-                </Button>
-              </CardFooter>
-            </Card>
-          )}
-
-          <Card className="flex flex-1 flex-col">
-            <CardHeader>
-              <CardTitle className="flex items-center gap-2 text-lg">
-                <Code2 className="size-4" />
-                Custom Experiment
-              </CardTitle>
-              <CardDescription>
-                Run any experiment via the Langfuse SDKs
-              </CardDescription>
-            </CardHeader>
-            <CardContent>
-              <ul className="list-disc space-y-2 pl-4 text-sm text-muted-foreground">
-                <li>Full control over experiment execution</li>
-                <li>Custom evaluation logic</li>
-                <li>Integration with your codebase</li>
-              </ul>
-            </CardContent>
-            <CardFooter className="mt-auto">
-              <Button
-                className="w-full"
-                variant="secondary"
-                asChild
-                onClick={() =>
-                  capture("dataset_run:view_custom_experiment_docs")
-                }
-              >
-                <Link
-                  href="https://langfuse.com/docs/datasets/get-started"
-                  target="_blank"
-                >
-                  View Docs
-                </Link>
-              </Button>
-            </CardFooter>
-          </Card>
-        </div>
-      </>
-    );
-  }
-
-  if (!hasPromptExperimentEntitlement) {
-    return null;
-  }
-
-  if (
-    !promptMeta.data ||
-    !datasets.data ||
-    (hasEvalReadAccess && !!datasetId && !evaluators.data)
-  ) {
-    return <Skeleton className="min-h-[70dvh] w-full" />;
-  }
-
-  return (
-    <>
-      <DialogHeader>
-        {showSDKRunInfoPage && (
-          <Button
-            variant="ghost"
-            onClick={() => setShowPromptForm(false)}
-            className="inline-block self-start"
-          >
-            ← Back
-          </Button>
-        )}
-        <DialogTitle>New Prompt Experiment</DialogTitle>
-        <DialogDescription>
-          Create an experiment to test a prompt version on a dataset. See{" "}
-          <Link
-            href="https://langfuse.com/docs/datasets/prompt-experiments"
-            target="_blank"
-            className="underline"
-          >
-            documentation
-          </Link>{" "}
-          to learn more.
-        </DialogDescription>
-      </DialogHeader>
-      <Form {...form}>
-        <form className="space-y-6" onSubmit={form.handleSubmit(onSubmit)}>
-          <FormField
-            control={form.control}
-            name="name"
-            render={({ field }) => (
-              <FormItem>
-                <FormLabel>Experiment name (optional)</FormLabel>
-                <FormControl>
-                  <Input {...field} type="string" />
-                </FormControl>
-                <FormMessage />
-              </FormItem>
-            )}
-          />
-          <FormField
-            control={form.control}
-            name="description"
-            render={({ field }) => (
-              <FormItem>
-                <FormLabel>Description (optional)</FormLabel>
-                <FormControl>
-                  <Textarea
-                    {...field}
-                    placeholder="Add description..."
-                    className="focus:outline-none focus:ring-0 focus-visible:ring-0 focus-visible:ring-offset-0 active:ring-0"
-                  />
-                </FormControl>
-                <FormMessage />
-              </FormItem>
-            )}
-          />
-          <FormField
-            control={form.control}
-            name="promptId"
-            render={() => (
-              <FormItem>
-                <FormLabel>Prompt</FormLabel>
-                {/* FIX: I need the Inputcommand list in the popover to be scrollable, currently it's not */}
-                <div className="mb-2 flex gap-2">
-                  <Popover open={open} onOpenChange={setOpen}>
-                    <PopoverTrigger asChild>
-                      <Button
-                        variant="outline"
-                        role="combobox"
-                        aria-expanded={open}
-                        className="w-2/3 justify-between px-2 font-normal"
-                      >
-                        {selectedPromptName || "Select a prompt"}
-                        <ChevronDown className="ml-2 h-4 w-4 shrink-0 opacity-50" />
-                      </Button>
-                    </PopoverTrigger>
-                    <PopoverContent
-                      className="w-[--radix-popover-trigger-width] overflow-auto p-0"
-                      align="start"
-                    >
-                      <InputCommand>
-                        <InputCommandInput
-                          placeholder="Search prompts..."
-                          className="h-9"
-                        />
-                        <InputCommandList>
-                          <InputCommandEmpty>
-                            No prompt found.
-                          </InputCommandEmpty>
-                          <InputCommandGroup>
-                            {promptsByName &&
-                              Object.entries(promptsByName).map(
-                                ([name, promptData]) => (
-                                  <InputCommandItem
-                                    key={name}
-                                    onSelect={() => {
-                                      setSelectedPromptName(name);
-                                      const latestVersion = promptData[0];
-                                      setSelectedPromptVersion(
-                                        latestVersion.version,
-                                      );
-                                      form.setValue(
-                                        "promptId",
-                                        latestVersion.id,
-                                      );
-                                      form.clearErrors("promptId");
-                                    }}
-                                  >
-                                    {name}
-                                    <CheckIcon
-                                      className={cn(
-                                        "ml-auto h-4 w-4",
-                                        name === selectedPromptName
-                                          ? "opacity-100"
-                                          : "opacity-0",
-                                      )}
-                                    />
-                                  </InputCommandItem>
-                                ),
-                              )}
-                          </InputCommandGroup>
-                        </InputCommandList>
-                      </InputCommand>
-                    </PopoverContent>
-                  </Popover>
-
-                  <Popover>
-                    <PopoverTrigger asChild>
-                      <Button
-                        disabled={!selectedPromptName}
-                        variant="outline"
-                        role="combobox"
-                        className="w-1/3 justify-between px-2 font-normal"
-                      >
-                        {selectedPromptVersion
-                          ? `Version ${selectedPromptVersion}`
-                          : "Version"}
-                        <ChevronDown className="ml-2 h-4 w-4 shrink-0 opacity-50" />
-                      </Button>
-                    </PopoverTrigger>
-                    <PopoverContent
-                      className="w-[--radix-popover-trigger-width] p-0"
-                      align="start"
-                    >
-                      <InputCommand>
-                        <InputCommandList>
-                          <InputCommandEmpty>
-                            No version found.
-                          </InputCommandEmpty>
-                          <InputCommandGroup className="overflow-y-auto">
-                            {promptsByName &&
-                            selectedPromptName &&
-                            promptsByName[selectedPromptName] ? (
-                              promptsByName[selectedPromptName].map(
-                                (prompt) => (
-                                  <InputCommandItem
-                                    key={prompt.id}
-                                    onSelect={() => {
-                                      setSelectedPromptVersion(prompt.version);
-                                      form.setValue("promptId", prompt.id);
-                                      form.clearErrors("promptId");
-                                    }}
-                                  >
-                                    Version {prompt.version}
-                                    <CheckIcon
-                                      className={cn(
-                                        "ml-auto h-4 w-4",
-                                        prompt.version === selectedPromptVersion
-                                          ? "opacity-100"
-                                          : "opacity-0",
-                                      )}
-                                    />
-                                  </InputCommandItem>
-                                ),
-                              )
-                            ) : (
-                              <InputCommandItem disabled>
-                                No versions available
-                              </InputCommandItem>
-                            )}
-                          </InputCommandGroup>
-                        </InputCommandList>
-                      </InputCommand>
-                    </PopoverContent>
-                  </Popover>
-                </div>
-                <FormMessage />
-              </FormItem>
-            )}
-          />
-
-          <FormField
-            control={form.control}
-            name="modelConfig"
-            render={() => (
-              <FormItem>
-                <Card className="p-4">
-                  <ModelParameters
-                    {...{
-                      modelParams,
-                      availableModels,
-                      availableProviders,
-                      updateModelParamValue: updateModelParamValue,
-                      setModelParamEnabled,
-                    }}
-                  />
-                </Card>
-                {form.formState.errors.modelConfig && (
-                  <p
-                    id="modelConfig"
-                    className={cn("text-sm font-medium text-destructive")}
-                  >
-                    {[
-                      form.formState.errors.modelConfig?.model?.message,
-                      form.formState.errors.modelConfig?.provider?.message,
-                    ].join(", ")}
-                  </p>
-                )}
-              </FormItem>
-            )}
-          />
-
-          <FormField
-            control={form.control}
-            name="datasetId"
-            render={({ field }) => (
-              <FormItem>
-                <div className="flex items-center gap-2">
-                  <FormLabel>Dataset</FormLabel>
-                  <Popover>
-                    <PopoverTrigger asChild>
-                      <span className="cursor-pointer text-xs text-muted-foreground">
-                        (expected columns)
-                      </span>
-                    </PopoverTrigger>
-                    <PopoverContent className="w-80">
-                      <div className="flex flex-col space-y-2">
-                        <h4 className="text-sm font-medium leading-none">
-                          Expected columns
-                        </h4>
-                        <span className="text-sm text-muted-foreground">
-                          {promptId ? (
-                            <div>
-                              <span>
-                                Given current prompt, dataset item input must
-                                contain at least one of these first-level JSON
-                                keys, mapped to a string value:
-                              </span>
-                              <ul className="my-2 ml-2 list-inside list-disc">
-                                {expectedColumns.map((col) => (
-                                  <li key={col}>{col}</li>
-                                ))}
-                              </ul>
-                              <span>
-                                These will be used as the input to your prompt.
-                              </span>
-                            </div>
-                          ) : (
-                            "Please select a prompt first"
-                          )}
-                        </span>
-                      </div>
-                    </PopoverContent>
-                  </Popover>
-                </div>
-                <Select
-                  onValueChange={field.onChange}
-                  defaultValue={field.value}
-                >
-                  <FormControl>
-                    <SelectTrigger>
-                      <SelectValue placeholder="Select a dataset" />
-                    </SelectTrigger>
-                  </FormControl>
-                  <SelectContent>
-                    {datasets.data?.map((dataset) => (
-                      <SelectItem value={dataset.id} key={dataset.id}>
-                        {dataset.name}
-                      </SelectItem>
-                    ))}
-                  </SelectContent>
-                </Select>
-                <FormMessage />
-              </FormItem>
-            )}
-          />
-
-          {evaluators.data && !!datasetId ? (
-            <FormItem>
-              <FormLabel>Evaluators</FormLabel>
-              <FormDescription>
-                Will run against your experiment results.
-              </FormDescription>
-              <MultiSelectKeyValues
-                key={datasetId}
-                placeholder="Value"
-                align="end"
-                className="grid grid-cols-[auto,1fr,auto,auto] gap-2"
-                disabled={!hasEvalWriteAccess}
-                onValueChange={handleOnValueChange}
-                options={evaluatorOptions}
-                values={
-                  selectedEvaluators as {
-                    value: string;
-                    key: string;
-                  }[]
-                }
-                hideClearButton
-                controlButtons={
-                  <DropdownMenuItem
-                    onSelect={() => {
-                      window.open(`/project/${projectId}/evals`, "_blank");
-                    }}
-                  >
-                    Manage evaluators
-                  </DropdownMenuItem>
-                }
-              />
-            </FormItem>
-          ) : (
-            <FormItem>
-              <FormLabel>Evaluators</FormLabel>
-              {hasEvalReadAccess ? (
-                <FormDescription>
-                  Select a dataset first to set up evaluators.
-                </FormDescription>
-              ) : (
-                <FormDescription>
-                  ⓘ You do not have access to view evaluators. Please contact
-                  your admin to upgrade your role.
-                </FormDescription>
-              )}
-            </FormItem>
-          )}
-
-          <div className="mt-4 flex flex-col gap-4">
-            {validationResult.isLoading && Boolean(promptId && datasetId) && (
-              <Card className="relative overflow-hidden rounded-md shadow-none group-data-[collapsible=icon]:hidden">
-                <CardHeader className="p-2">
-                  <CardTitle className="flex items-center justify-between text-sm">
-                    <span>Validating configuration...</span>
-                    <Loader2 className="h-3 w-3 animate-spin" />
-                  </CardTitle>
-                  <CardDescription className="text-foreground">
-                    Checking dataset items against prompt variables
-                  </CardDescription>
-                </CardHeader>
-              </Card>
-            )}
-            {validationResult.data?.isValid === false && (
-              <Card className="relative overflow-hidden rounded-md border-dark-yellow bg-light-yellow shadow-none group-data-[collapsible=icon]:hidden">
-                <CardHeader className="p-2">
-                  <CardTitle className="flex items-center justify-between text-sm text-dark-yellow">
-                    <span>Invalid configuration</span>
-                    {/* TODO: add link to docs explaining error cases */}
-                    <Info className="h-4 w-4" />
-                  </CardTitle>
-                  <CardDescription className="text-foreground">
-                    {validationResult.data?.message}
-                  </CardDescription>
-                </CardHeader>
-              </Card>
-            )}
-            {validationResult.data?.isValid === true && (
-              <Card className="relative overflow-hidden rounded-md border-dark-green bg-light-green shadow-none group-data-[collapsible=icon]:hidden">
-                <CardHeader className="p-2">
-                  <CardTitle className="flex items-center justify-between text-sm text-dark-green">
-                    <span>Valid configuration</span>
-                    <CircleCheck className="h-4 w-4" />
-                  </CardTitle>
-                  <div className="text-sm">
-                    Matches between dataset items and prompt variables
-                    <ul className="my-2 ml-2 list-inside list-disc">
-                      {Object.entries(
-                        validationResult.data.variablesMap ?? {},
-                      ).map(([variable, count]) => (
-                        <li key={variable}>
-                          <strong>{variable}:</strong> {count} /{" "}
-                          {validationResult.data?.isValid
-                            ? validationResult.data.totalItems
-                            : "unknown"}
-                        </li>
-                      ))}
-                    </ul>
-                    Items missing all prompt variables will be excluded from the
-                    experiment.
-                  </div>
-                </CardHeader>
-              </Card>
-            )}
-
-            <div className="flex justify-end">
-              <Button
-                type="submit"
-                disabled={
-                  (Boolean(promptId && datasetId) &&
-                    !validationResult.data?.isValid) ||
-                  !!form.formState.errors.name
-                }
-                loading={form.formState.isSubmitting}
-              >
-                Create
-              </Button>
-            </div>
-          </div>
-        </form>
-      </Form>
-    </>
-  );
-};
diff --git a/web/src/ee/features/experiments/hooks/useExperimentNameValidation.tsx b/web/src/ee/features/experiments/hooks/useExperimentNameValidation.tsx
deleted file mode 100644
index 398f21f..0000000
--- a/web/src/ee/features/experiments/hooks/useExperimentNameValidation.tsx
+++ /dev/null
@@ -1,33 +0,0 @@
-import { useEffect } from "react";
-import { type UseFormReturn } from "react-hook-form";
-
-interface UseExperimentNameValidationProps {
-  currentName: string | undefined;
-  allExperimentNames: { value: string }[] | undefined;
-  form: UseFormReturn<any>;
-}
-
-export const useExperimentNameValidation = ({
-  currentName,
-  allExperimentNames,
-  form,
-}: UseExperimentNameValidationProps) => {
-  useEffect(() => {
-    if (!currentName) {
-      form.clearErrors("name");
-      return;
-    }
-
-    const isNewExperiment = !allExperimentNames
-      ?.map((experiment) => experiment.value)
-      .includes(currentName);
-
-    if (!isNewExperiment) {
-      form.setError("name", {
-        message: "Experiment name already exists for this dataset.",
-      });
-    } else {
-      form.clearErrors("name");
-    }
-  }, [currentName, allExperimentNames, form]);
-};
diff --git a/web/src/ee/features/experiments/server/router.ts b/web/src/ee/features/experiments/server/router.ts
deleted file mode 100644
index 6230385..0000000
--- a/web/src/ee/features/experiments/server/router.ts
+++ /dev/null
@@ -1,220 +0,0 @@
-import { z } from "zod";
-import { randomUUID } from "crypto";
-import {
-  type ExperimentMetadata,
-  QueueJobs,
-  QueueName,
-  redis,
-  ZodModelConfig,
-  ExperimentCreateQueue,
-} from "@langfuse/shared/src/server";
-import {
-  createTRPCRouter,
-  protectedProjectProcedure,
-} from "@/src/server/api/trpc";
-import { PromptType } from "@/src/features/prompts/server/utils/validation";
-import {
-  type DatasetItem,
-  DatasetStatus,
-  extractVariables,
-  datasetItemMatchesVariable,
-  UnauthorizedError,
-} from "@langfuse/shared";
-import { throwIfNoEntitlement } from "@/src/features/entitlements/server/hasEntitlement";
-import { throwIfNoProjectAccess } from "@/src/features/rbac/utils/checkProjectAccess";
-
-const ValidConfigResponse = z.object({
-  isValid: z.literal(true),
-  totalItems: z.number(),
-  variablesMap: z.record(z.string(), z.number()),
-});
-
-const InvalidConfigResponse = z.object({
-  isValid: z.literal(false),
-  message: z.string(),
-});
-
-const ConfigResponse = z.discriminatedUnion("isValid", [
-  ValidConfigResponse,
-  InvalidConfigResponse,
-]);
-
-const validateDatasetItems = (
-  datasetItems: DatasetItem[],
-  variables: string[],
-): Record<string, number> => {
-  const variableMap: Record<string, number> = {};
-
-  for (const { input } of datasetItems) {
-    if (!input) {
-      continue;
-    }
-
-    // For each variable, increment its count if it exists in this item
-    for (const variable of variables) {
-      if (datasetItemMatchesVariable(input, variable)) {
-        variableMap[variable] = (variableMap[variable] || 0) + 1;
-      }
-    }
-  }
-
-  return variableMap;
-};
-
-export const experimentsRouter = createTRPCRouter({
-  validateConfig: protectedProjectProcedure
-    .input(
-      z.object({
-        projectId: z.string(),
-        datasetId: z.string(),
-        promptId: z.string(),
-      }),
-    )
-    .output(ConfigResponse)
-    .query(async ({ input, ctx }) => {
-      throwIfNoEntitlement({
-        entitlement: "prompt-experiments",
-        projectId: input.projectId,
-        sessionUser: ctx.session.user,
-      });
-      throwIfNoProjectAccess({
-        session: ctx.session,
-        projectId: input.projectId,
-        scope: "promptExperiments:CUD",
-      });
-
-      const prompt = await ctx.prisma.prompt.findFirst({
-        where: {
-          id: input.promptId,
-          projectId: input.projectId,
-        },
-      });
-
-      if (!prompt) {
-        return {
-          isValid: false,
-          message: "Selected prompt not found.",
-        };
-      }
-
-      const extractedVariables = extractVariables(
-        prompt?.type === PromptType.Text
-          ? (prompt.prompt?.toString() ?? "")
-          : JSON.stringify(prompt.prompt),
-      );
-
-      if (!Boolean(extractedVariables.length)) {
-        return {
-          isValid: false,
-          message: "Selected prompt has no variables.",
-        };
-      }
-
-      const datasetItems = await ctx.prisma.datasetItem.findMany({
-        where: {
-          datasetId: input.datasetId,
-          projectId: input.projectId,
-          status: DatasetStatus.ACTIVE,
-        },
-      });
-
-      if (!Boolean(datasetItems.length)) {
-        return {
-          isValid: false,
-          message: "Selected dataset is empty or all items are inactive.",
-        };
-      }
-
-      const variablesMap = validateDatasetItems(
-        datasetItems,
-        extractedVariables,
-      );
-
-      if (!Boolean(Object.keys(variablesMap).length)) {
-        return {
-          isValid: false,
-          message: "No dataset item contains any variables.",
-        };
-      }
-
-      return {
-        isValid: true,
-        totalItems: datasetItems.length,
-        variablesMap: variablesMap,
-      };
-    }),
-
-  createExperiment: protectedProjectProcedure
-    .input(
-      z.object({
-        projectId: z.string(),
-        name: z.string().optional(),
-        promptId: z.string().min(1, "Please select a prompt"),
-        datasetId: z.string().min(1, "Please select a dataset"),
-        description: z.string().max(1000).optional(),
-        modelConfig: z.object({
-          provider: z.string().min(1, "Please select a provider"),
-          model: z.string().min(1, "Please select a model"),
-          modelParams: ZodModelConfig,
-        }),
-      }),
-    )
-    .mutation(async ({ input, ctx }) => {
-      throwIfNoEntitlement({
-        entitlement: "prompt-experiments",
-        projectId: input.projectId,
-        sessionUser: ctx.session.user,
-      });
-      throwIfNoProjectAccess({
-        session: ctx.session,
-        projectId: input.projectId,
-        scope: "promptExperiments:CUD",
-      });
-
-      if (!redis) {
-        throw new UnauthorizedError("Experiment creation failed");
-      }
-
-      const metadata: ExperimentMetadata = {
-        prompt_id: input.promptId,
-        provider: input.modelConfig.provider,
-        model: input.modelConfig.model,
-        model_params: input.modelConfig.modelParams,
-      };
-      const name =
-        input.name ?? `${input.promptId}-${new Date().toISOString()}`;
-
-      const datasetRun = await ctx.prisma.datasetRuns.create({
-        data: {
-          name: name,
-          description: input.description,
-          datasetId: input.datasetId,
-          metadata: metadata,
-          projectId: input.projectId,
-        },
-      });
-
-      const queue = ExperimentCreateQueue.getInstance();
-
-      if (queue) {
-        await queue.add(QueueName.ExperimentCreate, {
-          name: QueueJobs.ExperimentCreateJob,
-          id: randomUUID(),
-          timestamp: new Date(),
-          payload: {
-            projectId: input.projectId,
-            datasetId: input.datasetId,
-            runId: datasetRun.id,
-            description: input.description,
-          },
-        });
-      }
-
-      return {
-        success: true,
-        datasetId: input.datasetId,
-        runId: datasetRun.id,
-        runName: name,
-      };
-    }),
-});
diff --git a/web/src/ee/features/multi-tenant-sso/createNewSsoConfigHandler.ts b/web/src/ee/features/multi-tenant-sso/createNewSsoConfigHandler.ts
deleted file mode 100644
index 79f1f4c..0000000
--- a/web/src/ee/features/multi-tenant-sso/createNewSsoConfigHandler.ts
+++ /dev/null
@@ -1,77 +0,0 @@
-import { prisma } from "@langfuse/shared/src/db";
-import { encrypt } from "@langfuse/shared/encryption";
-import { SsoProviderSchema } from "./types";
-import { type NextApiRequest, type NextApiResponse } from "next";
-import { env } from "@/src/env.mjs";
-import { logger } from "@langfuse/shared/src/server";
-import { multiTenantSsoAvailable } from "@/src/ee/features/multi-tenant-sso/multiTenantSsoAvailable";
-
-export async function createNewSsoConfigHandler(
-  req: NextApiRequest,
-  res: NextApiResponse,
-) {
-  try {
-    if (!multiTenantSsoAvailable) {
-      res
-        .status(403)
-        .json({ error: "Multi-tenant SSO is not available on your instance" });
-      return;
-    }
-    // allow only POST requests
-    if (req.method !== "POST") {
-      res.status(405).json({ error: "Method Not Allowed" });
-      return;
-    }
-    // check if ADMIN_API_KEY is set
-    if (!env.ADMIN_API_KEY) {
-      res.status(500).json({ error: "ADMIN_API_KEY is not set" });
-      return;
-    }
-    if (!env.ENCRYPTION_KEY) {
-      res.status(500).json({ error: "ENCRYPTION_KEY is not set" });
-      return;
-    }
-    // check bearer token
-    const { authorization } = req.headers;
-    if (!authorization) {
-      res
-        .status(401)
-        .json({ error: "Unauthorized: No authorization header provided" });
-      return;
-    }
-    const [scheme, token] = authorization.split(" ");
-    if (scheme !== "Bearer" || !token || token !== env.ADMIN_API_KEY) {
-      res.status(401).json({ error: "Unauthorized: Invalid token" });
-      return;
-    }
-
-    const body = SsoProviderSchema.safeParse(req.body);
-    if (!body.success) {
-      res.status(400).json({ error: body.error });
-      return;
-    }
-
-    const { domain, authProvider, authConfig } = body.data;
-
-    const encryptedClientSecret = authConfig
-      ? {
-          ...authConfig,
-          clientSecret: encrypt(authConfig.clientSecret),
-        }
-      : undefined;
-
-    await prisma.ssoConfig.create({
-      data: {
-        domain,
-        authProvider,
-        authConfig: encryptedClientSecret,
-      },
-    });
-    res.status(201).json({
-      message: "SSO configuration created successfully",
-    });
-  } catch (e) {
-    logger.error("Failed to create SSO configuration", e);
-    res.status(500).json({ error: "Internal Server Error" });
-  }
-}
diff --git a/web/src/ee/features/multi-tenant-sso/multiTenantSsoAvailable.ts b/web/src/ee/features/multi-tenant-sso/multiTenantSsoAvailable.ts
deleted file mode 100644
index a750a4c..0000000
--- a/web/src/ee/features/multi-tenant-sso/multiTenantSsoAvailable.ts
+++ /dev/null
@@ -1,5 +0,0 @@
-import { env } from "@/src/env.mjs";
-
-export const multiTenantSsoAvailable = Boolean(
-  env.NEXT_PUBLIC_LANGFUSE_CLOUD_REGION,
-);
diff --git a/web/src/ee/features/multi-tenant-sso/types.ts b/web/src/ee/features/multi-tenant-sso/types.ts
deleted file mode 100644
index fabf776..0000000
--- a/web/src/ee/features/multi-tenant-sso/types.ts
+++ /dev/null
@@ -1,158 +0,0 @@
-import { z } from "zod";
-
-const base = z.object({
-  domain: z.string().refine((v) => v === v.toLowerCase(), {
-    message: "Domain must be lowercase",
-  }),
-});
-
-export const GoogleProviderSchema = base.extend({
-  authProvider: z.literal("google"),
-  authConfig: z
-    .object({
-      clientId: z.string(),
-      clientSecret: z.string(),
-      allowDangerousEmailAccountLinking: z.boolean().optional().default(false),
-    })
-    .nullish(),
-});
-
-export const GithubProviderSchema = base.extend({
-  authProvider: z.literal("github"),
-  authConfig: z
-    .object({
-      clientId: z.string(),
-      clientSecret: z.string(),
-      allowDangerousEmailAccountLinking: z.boolean().optional().default(false),
-    })
-    .nullish(),
-});
-
-export const GithubEnterpriseProviderSchema = base.extend({
-  authProvider: z.literal("github-enterprise"),
-  authConfig: z
-    .object({
-      clientId: z.string(),
-      clientSecret: z.string(),
-      enterprise: z.object({
-        baseUrl: z.string().url(),
-      }),
-      allowDangerousEmailAccountLinking: z.boolean().optional().default(false),
-    })
-    .nullish(),
-});
-
-export const GitlabProviderSchema = base.extend({
-  authProvider: z.literal("gitlab"),
-  authConfig: z
-    .object({
-      clientId: z.string(),
-      clientSecret: z.string(),
-      issuer: z.string().optional(),
-      allowDangerousEmailAccountLinking: z.boolean().optional().default(false),
-    })
-    .nullish(),
-});
-
-export const Auth0ProviderSchema = base.extend({
-  authProvider: z.literal("auth0"),
-  authConfig: z
-    .object({
-      clientId: z.string(),
-      clientSecret: z.string(),
-      issuer: z.string(),
-      allowDangerousEmailAccountLinking: z.boolean().optional().default(false),
-    })
-    .nullish(),
-});
-
-export const OktaProviderSchema = base.extend({
-  authProvider: z.literal("okta"),
-  authConfig: z
-    .object({
-      clientId: z.string(),
-      clientSecret: z.string(),
-      issuer: z.string(),
-      allowDangerousEmailAccountLinking: z.boolean().optional().default(false),
-    })
-    .nullish(),
-});
-
-export const AzureAdProviderSchema = base.extend({
-  authProvider: z.literal("azure-ad"),
-  authConfig: z
-    .object({
-      clientId: z.string(),
-      clientSecret: z.string(),
-      tenantId: z.string(),
-      allowDangerousEmailAccountLinking: z.boolean().optional().default(false),
-    })
-    .nullish(),
-});
-
-export const CognitoProviderSchema = base.extend({
-  authProvider: z.literal("cognito"),
-  authConfig: z
-    .object({
-      clientId: z.string(),
-      clientSecret: z.string(),
-      issuer: z.string(),
-      allowDangerousEmailAccountLinking: z.boolean().optional().default(false),
-    })
-    .nullish(),
-});
-
-export const KeycloakProviderSchema = base.extend({
-  authProvider: z.literal("keycloak"),
-  authConfig: z
-    .object({
-      clientId: z.string(),
-      clientSecret: z.string(),
-      issuer: z.string(),
-      allowDangerousEmailAccountLinking: z.boolean().optional().default(false),
-    })
-    .nullish(),
-});
-
-export const CustomProviderSchema = base.extend({
-  authProvider: z.literal("custom"),
-  authConfig: z
-    .object({
-      name: z.string(),
-      clientId: z.string(),
-      clientSecret: z.string(),
-      issuer: z.string(),
-      scope: z.string().nullish(),
-      idToken: z.boolean().optional().default(true),
-      allowDangerousEmailAccountLinking: z.boolean().optional().default(false),
-    })
-    .nullish(),
-});
-
-export type GoogleProviderSchema = z.infer<typeof GoogleProviderSchema>;
-export type GithubProviderSchema = z.infer<typeof GithubProviderSchema>;
-export type GithubEnterpriseProviderSchema = z.infer<
-  typeof GithubEnterpriseProviderSchema
->;
-export type GitlabProviderSchema = z.infer<typeof GitlabProviderSchema>;
-export type Auth0ProviderSchema = z.infer<typeof Auth0ProviderSchema>;
-export type OktaProviderSchema = z.infer<typeof OktaProviderSchema>;
-export type AzureAdProviderSchema = z.infer<typeof AzureAdProviderSchema>;
-export type CognitoProviderSchema = z.infer<typeof CognitoProviderSchema>;
-export type KeycloakProviderSchema = z.infer<typeof KeycloakProviderSchema>;
-export type CustomProviderSchema = z.infer<typeof CustomProviderSchema>;
-
-export const SsoProviderSchema = z.discriminatedUnion("authProvider", [
-  GoogleProviderSchema,
-  GithubProviderSchema,
-  GithubEnterpriseProviderSchema,
-  GitlabProviderSchema,
-  Auth0ProviderSchema,
-  OktaProviderSchema,
-  AzureAdProviderSchema,
-  CognitoProviderSchema,
-  KeycloakProviderSchema,
-  CustomProviderSchema,
-]);
-
-export type SsoProviderSchema = z.infer<typeof SsoProviderSchema>;
diff --git a/web/src/ee/features/multi-tenant-sso/utils.ts b/web/src/ee/features/multi-tenant-sso/utils.ts
deleted file mode 100644
index 9a52fec..0000000
--- a/web/src/ee/features/multi-tenant-sso/utils.ts
+++ /dev/null
@@ -1,244 +0,0 @@
-import { type Provider } from "next-auth/providers/index";
-import GoogleProvider from "next-auth/providers/google";
-import GitHubProvider from "next-auth/providers/github";
-import GitLabProvider from "next-auth/providers/gitlab";
-import OktaProvider from "next-auth/providers/okta";
-import CognitoProvider from "next-auth/providers/cognito";
-import KeycloakProvider from "next-auth/providers/keycloak";
-import Auth0Provider from "next-auth/providers/auth0";
-import AzureADProvider from "next-auth/providers/azure-ad";
-import { multiTenantSsoAvailable } from "@/src/ee/features/multi-tenant-sso/multiTenantSsoAvailable";
-import { type SsoConfig, prisma } from "@langfuse/shared/src/db";
-import { decrypt } from "@langfuse/shared/encryption";
-import { SsoProviderSchema } from "./types";
-import {
-  CustomSSOProvider,
-  GitHubEnterpriseProvider,
-  logger,
-  traceException,
-} from "@langfuse/shared/src/server";
-
-// Local cache for SSO configurations
-let cachedSsoConfigs: {
-  data: SsoProviderSchema[];
-  failedToFetch: boolean;
-  timestamp: number;
-} =
-  // initialize with empty cache
-  { data: [], failedToFetch: false, timestamp: 0 };
-
-/**
- * Get all SSO configurations from the database or from local cache and parse them into SsoProviderSchema objects.
- *
- * @returns {Promise<SsoProviderSchema[]>} - A list of all SSO configurations. Empty array if none are configured or EE is not available.
- */
-async function getSsoConfigs(): Promise<SsoProviderSchema[]> {
-  if (!multiTenantSsoAvailable) return [];
-
-  const CACHE_TTL = 60 * 60 * 1000; // 1 hour
-  const FAILEDTOFETCH_RETRY_AFTER = 60 * 1000; // 1 minute
-  const DB_MAX_WAIT = 2 * 1000; // 2 seconds
-  const DB_TIMEOUT = 3 * 1000; // 3 seconds
-
-  const isCacheExpired =
-    Date.now() - cachedSsoConfigs.timestamp >
-    (cachedSsoConfigs.failedToFetch ? FAILEDTOFETCH_RETRY_AFTER : CACHE_TTL);
-
-  if (isCacheExpired) {
-    // findMany with custom timeout via $transaction
-    let dbConfigs: SsoConfig[] = [];
-    let failedToFetch = false;
-    try {
-      dbConfigs = await prisma.$transaction(
-        async (prisma) => prisma.ssoConfig.findMany(),
-        {
-          maxWait: DB_MAX_WAIT,
-          timeout: DB_TIMEOUT,
-        },
-      );
-    } catch (e) {
-      logger.error("Failed to load SSO configs from the database", e);
-      traceException(e);
-      // empty array will be cached to prevent repeated DB queries
-      failedToFetch = true;
-    }
-
-    // transform into zod object
-    const parsedSsoConfigs = dbConfigs
-      .map((v) => {
-        try {
-          const parsedValue = SsoProviderSchema.parse(v);
-          return parsedValue;
-        } catch (e) {
-          logger.error(
-            `Failed to parse SSO provider config for domain ${v.domain}`,
-            e,
-          );
-
-          traceException(e);
-          return null;
-        }
-      })
-      .filter((parsed): parsed is SsoProviderSchema => parsed !== null);
-
-    cachedSsoConfigs = {
-      data: parsedSsoConfigs,
-      timestamp: Date.now(),
-      failedToFetch,
-    };
-  }
-
-  return cachedSsoConfigs.data;
-}
-
-/**
- * Load all custom SSO providers from the database. To be used within `providers` in NextAuth backend configuration.
- *
- * @returns {Promise<Provider[]>} - A list of all custom SSO providers.
- */
-export async function loadSsoProviders(): Promise<Provider[]> {
-  if (!multiTenantSsoAvailable) return [];
-
-  const ssoConfigs = await getSsoConfigs();
-
-  const providers: Provider[] = [];
-
-  for (const dbSsoConfig of ssoConfigs) {
-    const provider = dbToNextAuthProvider(dbSsoConfig);
-    if (provider !== null) providers.push(provider);
-  }
-
-  return providers;
-}
-
-/**
- * @returns `true` if any custom SSO provider is configured in the database.
- */
-export async function isAnySsoConfigured(): Promise<boolean> {
-  if (!multiTenantSsoAvailable) return false;
-  const ssoConfigs = await getSsoConfigs();
-  return ssoConfigs.length > 0;
-}
-
-/**
- * Get the custom SSO providerId for a domain. To be used with NextAuth's `signIn(providerId)`.
- *
- * @param domain - The domain to check for a custom SSO provider, e.g. "example.com".
- * @returns `providerId` or null if none is configured or EE is not available.
- */
-export async function getSsoAuthProviderIdForDomain(
-  domain: string,
-): Promise<string | null> {
-  if (!multiTenantSsoAvailable) return null;
-  const ssoConfig = (await getSsoConfigs()).find(
-    (ssoConfig) => ssoConfig.domain === domain.toLowerCase(),
-  );
-
-  if (!ssoConfig) return null;
-  return getAuthProviderIdForSsoConfig(ssoConfig);
-}
-
-/**
- * Converts a SsoProviderConfig to a NextAuth Provider instance.
- *
- * @param {SsoProviderSchema} provider - The SSO configuration from the database.
- * @returns {Provider | null} - A NextAuth Provider instance or null if parsing fails or no custom credentials are used for this SSO config.
- */
-const dbToNextAuthProvider = (provider: SsoProviderSchema): Provider | null => {
-  // If the SsoConfig does not use custom credentials, return null as no additional provider needs to be added to NextAuth
-  if (!provider.authConfig) return null;
-
-  if (provider.authProvider === "google")
-    return GoogleProvider({
-      id: getAuthProviderIdForSsoConfig(provider), // use the domain as the provider id as we use domain-specific credentials
-      ...provider.authConfig,
-      clientSecret: decrypt(provider.authConfig.clientSecret),
-    });
-  else if (provider.authProvider === "github")
-    return GitHubProvider({
-      id: getAuthProviderIdForSsoConfig(provider), // use the domain as the provider id as we use domain-specific credentials
-      ...provider.authConfig,
-      clientSecret: decrypt(provider.authConfig.clientSecret),
-    });
-  else if (provider.authProvider === "gitlab")
-    return GitLabProvider({
-      id: getAuthProviderIdForSsoConfig(provider), // use the domain as the provider id as we use domain-specific credentials
-      ...provider.authConfig,
-      clientSecret: decrypt(provider.authConfig.clientSecret),
-    });
-  else if (provider.authProvider === "auth0")
-    return Auth0Provider({
-      id: getAuthProviderIdForSsoConfig(provider), // use the domain as the provider id as we use domain-specific credentials
-      ...provider.authConfig,
-      clientSecret: decrypt(provider.authConfig.clientSecret),
-    });
-  else if (provider.authProvider === "okta")
-    return OktaProvider({
-      id: getAuthProviderIdForSsoConfig(provider), // use the domain as the provider id as we use domain-specific credentials
-      ...provider.authConfig,
-      clientSecret: decrypt(provider.authConfig.clientSecret),
-    });
-  else if (provider.authProvider === "azure-ad")
-    return AzureADProvider({
-      id: getAuthProviderIdForSsoConfig(provider), // use the domain as the provider id as we use domain-specific credentials
-      ...provider.authConfig,
-      clientSecret: decrypt(provider.authConfig.clientSecret),
-    });
-  else if (provider.authProvider === "cognito")
-    return CognitoProvider({
-      id: getAuthProviderIdForSsoConfig(provider), // use the domain as the provider id as we use domain-specific credentials
-      ...provider.authConfig,
-      clientSecret: decrypt(provider.authConfig.clientSecret),
-    });
-  else if (provider.authProvider === "keycloak")
-    return KeycloakProvider({
-      id: getAuthProviderIdForSsoConfig(provider), // use the domain as the provider id as we use domain-specific credentials
-      ...provider.authConfig,
-      clientSecret: decrypt(provider.authConfig.clientSecret),
-    });
-  else if (provider.authProvider === "custom")
-    return CustomSSOProvider({
-      id: getAuthProviderIdForSsoConfig(provider), // use the domain as the provider id as we use domain-specific credentials
-      ...provider.authConfig,
-      clientSecret: decrypt(provider.authConfig.clientSecret),
-      authorization: {
-        params: { scope: provider.authConfig.scope ?? "openid email profile" },
-      },
-    });
-  else if (provider.authProvider === "github-enterprise")
-    return GitHubEnterpriseProvider({
-      id: getAuthProviderIdForSsoConfig(provider), // use the domain as the provider id as we use domain-specific credentials
-      ...provider.authConfig,
-      clientSecret: decrypt(provider.authConfig.clientSecret),
-      enterprise: {
-        baseUrl: provider.authConfig.enterprise.baseUrl,
-      },
-    });
-  else {
-    // Type check to ensure we handle all providers
-    // eslint-disable-next-line @typescript-eslint/no-unused-vars
-    const _: never = provider;
-    logger.error(
-      `Unrecognized SSO provider for domain ${(provider as any).domain}`,
-    );
-    traceException(
-      new Error(
-        `Unrecognized SSO provider for domain ${(provider as any).domain}`,
-      ),
-    );
-    return null;
-  }
-};
-
-/**
- * Get the custom SSO providerId for a database SSO configuration. To be used with NextAuth's `signIn(providerId)`.
- *
- * @param {DbSsoConfig} dbSsoConfig - The SSO configuration from the database.
- * @returns {string} - The providerId used in NextAuth.
- */
-const getAuthProviderIdForSsoConfig = (
-  dbSsoConfig: SsoProviderSchema,
-): string => {
-  if (!dbSsoConfig.authConfig) return dbSsoConfig.authProvider;
-  return `${dbSsoConfig.domain}.${dbSsoConfig.authProvider}`;
-};
diff --git a/web/src/ee/features/playground/page/components/CreateOrEditLLMSchemaDialog.tsx b/web/src/ee/features/playground/page/components/CreateOrEditLLMSchemaDialog.tsx
deleted file mode 100644
index 98d362b..0000000
--- a/web/src/ee/features/playground/page/components/CreateOrEditLLMSchemaDialog.tsx
+++ /dev/null
@@ -1,278 +0,0 @@
-import React, { useEffect, useState } from "react";
-import { useForm } from "react-hook-form";
-import { zodResolver } from "@hookform/resolvers/zod";
-import { ArrowUpRight } from "lucide-react";
-import * as z from "zod";
-
-import { Button } from "@/src/components/ui/button";
-import {
-  Dialog,
-  DialogContent,
-  DialogDescription,
-  DialogFooter,
-  DialogHeader,
-  DialogTitle,
-  DialogTrigger,
-} from "@/src/components/ui/dialog";
-import {
-  Form,
-  FormControl,
-  FormField,
-  FormItem,
-  FormLabel,
-  FormMessage,
-  FormDescription,
-} from "@/src/components/ui/form";
-import { Input } from "@/src/components/ui/input";
-import { Textarea } from "@/src/components/ui/textarea";
-import { LLMSchemaNameSchema } from "@/src/features/llm-schemas/validation";
-import { api } from "@/src/utils/api";
-
-import { JSONSchemaFormSchema, type LlmSchema } from "@langfuse/shared";
-import { CodeMirrorEditor } from "@/src/components/editor";
-
-const formSchema = z.object({
-  name: LLMSchemaNameSchema,
-  description: z.string().min(1, "Description is required"),
-  schema: JSONSchemaFormSchema,
-});
-
-type FormValues = z.infer<typeof formSchema>;
-
-type CreateOrEditLLMSchemaDialog = {
-  children: React.ReactNode;
-  projectId: string;
-  onSave: (llmSchema: LlmSchema) => void;
-  onDelete?: (llmSchema: LlmSchema) => void;
-  existingLlmSchema?: LlmSchema;
-  defaultValues?: {
-    name: string;
-    description: string;
-    schema: string;
-  };
-};
-
-export const CreateOrEditLLMSchemaDialog: React.FC<
-  CreateOrEditLLMSchemaDialog
-> = (props) => {
-  const { children, projectId, onSave, existingLlmSchema } = props;
-
-  const utils = api.useUtils();
-  const createLlmSchema = api.llmSchemas.create.useMutation();
-  const updateLlmSchema = api.llmSchemas.update.useMutation();
-  const deleteLlmSchema = api.llmSchemas.delete.useMutation();
-
-  const [open, setOpen] = useState(false);
-
-  const form = useForm<FormValues>({
-    resolver: zodResolver(formSchema),
-    defaultValues: props.defaultValues ?? {
-      name: "",
-      description: "",
-      schema: JSON.stringify(
-        {
-          type: "object",
-          properties: {},
-          required: [],
-          additionalProperties: false,
-        },
-        null,
-        2,
-      ),
-    },
-  });
-
-  // Populate form when in edit mode
-  useEffect(() => {
-    if (existingLlmSchema) {
-      form.reset({
-        name: existingLlmSchema.name,
-        description: existingLlmSchema.description,
-        schema: JSON.stringify(existingLlmSchema.schema, null, 2),
-      });
-    }
-  }, [existingLlmSchema, form]);
-
-  async function onSubmit(values: FormValues) {
-    let result;
-    if (existingLlmSchema) {
-      result = await updateLlmSchema.mutateAsync({
-        id: existingLlmSchema.id,
-        projectId,
-        name: values.name,
-        description: values.description,
-        schema: JSON.parse(values.schema),
-      });
-    } else {
-      result = await createLlmSchema.mutateAsync({
-        projectId,
-        name: values.name,
-        description: values.description,
-        schema: JSON.parse(values.schema),
-      });
-    }
-
-    await utils.llmSchemas.getAll.invalidate({ projectId });
-
-    onSave(result);
-    setOpen(false);
-  }
-
-  async function handleDelete() {
-    if (!existingLlmSchema) return;
-
-    await deleteLlmSchema.mutateAsync({
-      id: existingLlmSchema.id,
-      projectId,
-    });
-
-    props.onDelete?.(existingLlmSchema);
-
-    await utils.llmSchemas.getAll.invalidate({ projectId });
-    setOpen(false);
-  }
-
-  const prettifyJson = () => {
-    try {
-      const currentValue = form.getValues("schema");
-      const parsedJson = JSON.parse(currentValue);
-      const prettified = JSON.stringify(parsedJson, null, 2);
-      form.setValue("schema", prettified);
-    } catch (error) {
-      console.error("Failed to prettify JSON:", error);
-    }
-  };
-
-  return (
-    <Dialog open={open} onOpenChange={setOpen}>
-      <DialogTrigger asChild>{children}</DialogTrigger>
-      <DialogContent className="flex flex-col sm:min-w-[32rem] md:min-w-[40rem]">
-        <DialogHeader>
-          <DialogTitle>
-            {existingLlmSchema ? "Edit LLM Schema" : "Create LLM Schema"}
-          </DialogTitle>
-          <DialogDescription>
-            Define a JSON Schema for structured outputs
-          </DialogDescription>
-        </DialogHeader>
-
-        <Form {...form}>
-          <form
-            onSubmit={form.handleSubmit(onSubmit)}
-            className="flex flex-1 flex-col"
-          >
-            <div className="flex-1 space-y-4 overflow-y-auto">
-              <FormField
-                control={form.control}
-                name="name"
-                render={({ field }) => (
-                  <FormItem>
-                    <FormLabel>Name</FormLabel>
-                    <FormControl>
-                      <Input placeholder="e.g., get_weather" {...field} />
-                    </FormControl>
-                    <FormMessage />
-                  </FormItem>
-                )}
-              />
-
-              <FormField
-                control={form.control}
-                name="description"
-                render={({ field }) => (
-                  <FormItem>
-                    <FormLabel>Description</FormLabel>
-                    <FormControl>
-                      <Textarea
-                        placeholder="Describe the schema"
-                        className="max-h-[120px] focus:ring-0 focus:ring-offset-0 focus-visible:ring-0 focus-visible:ring-offset-0"
-                        {...field}
-                      />
-                    </FormControl>
-                    <FormMessage />
-                  </FormItem>
-                )}
-              />
-
-              <FormField
-                control={form.control}
-                name="schema"
-                render={({ field }) => (
-                  <FormItem>
-                    <FormLabel>JSON Schema</FormLabel>
-                    <FormDescription>
-                      Define the structure of your schema using JSON Schema
-                      format.{" "}
-                      <a
-                        href="https://json-schema.org/learn/miscellaneous-examples"
-                        target="_blank"
-                        rel="noopener noreferrer"
-                        className="flex items-center"
-                      >
-                        See JSON Schema examples here
-                        <ArrowUpRight className="h-3 w-3" />
-                      </a>
-                    </FormDescription>
-                    <FormControl>
-                      <div className="relative flex flex-col gap-1">
-                        <CodeMirrorEditor
-                          value={field.value}
-                          onChange={field.onChange}
-                          mode="json"
-                          minHeight={200}
-                          className="max-h-[25vh]"
-                        />
-                        <Button
-                          type="button"
-                          variant="outline"
-                          size="sm"
-                          onClick={prettifyJson}
-                          className="absolute right-3 top-3 text-xs"
-                        >
-                          Prettify
-                        </Button>
-                      </div>
-                    </FormControl>
-                    <p className="text-xs text-muted-foreground">
-                      Parameters must be a valid JSON Schema object
-                    </p>
-                    <FormMessage />
-                  </FormItem>
-                )}
-              />
-            </div>
-
-            <DialogFooter className="sticky bottom-0 mt-4 flex flex-col gap-2 border-t bg-background pt-4">
-              <div className="flex w-full flex-col gap-2">
-                <p className="text-xs text-muted-foreground">
-                  Note: Changes to schemas are reflected to all members of this
-                  project.
-                </p>
-                <div className="flex items-center justify-between gap-2">
-                  {existingLlmSchema && (
-                    <Button
-                      type="button"
-                      variant="destructive"
-                      onClick={handleDelete}
-                      className="mr-auto"
-                    >
-                      Delete
-                    </Button>
-                  )}
-                  <Button
-                    type="button"
-                    variant="outline"
-                    onClick={() => setOpen(false)}
-                  >
-                    Cancel
-                  </Button>
-                  <Button type="submit">Save</Button>
-                </div>
-              </div>
-            </DialogFooter>
-          </form>
-        </Form>
-      </DialogContent>
-    </Dialog>
-  );
-};
diff --git a/web/src/ee/features/playground/page/components/CreateOrEditLLMToolDialog.tsx b/web/src/ee/features/playground/page/components/CreateOrEditLLMToolDialog.tsx
deleted file mode 100644
index f5f5c69..0000000
--- a/web/src/ee/features/playground/page/components/CreateOrEditLLMToolDialog.tsx
+++ /dev/null
@@ -1,287 +0,0 @@
-import React, { useEffect, useState } from "react";
-import { useForm } from "react-hook-form";
-import { zodResolver } from "@hookform/resolvers/zod";
-import { ArrowUpRight } from "lucide-react";
-import * as z from "zod";
-
-import { Button } from "@/src/components/ui/button";
-import {
-  Dialog,
-  DialogContent,
-  DialogDescription,
-  DialogFooter,
-  DialogHeader,
-  DialogTitle,
-  DialogTrigger,
-} from "@/src/components/ui/dialog";
-import {
-  Form,
-  FormControl,
-  FormDescription,
-  FormField,
-  FormItem,
-  FormLabel,
-  FormMessage,
-} from "@/src/components/ui/form";
-import { Input } from "@/src/components/ui/input";
-import { Textarea } from "@/src/components/ui/textarea";
-import { LLMToolNameSchema } from "@/src/features/llm-tools/validation";
-import { api } from "@/src/utils/api";
-
-import { CodeMirrorEditor } from "@/src/components/editor";
-import { JSONSchemaFormSchema, type LlmTool } from "@langfuse/shared";
-
-const formSchema = z.object({
-  name: LLMToolNameSchema,
-  description: z.string().min(1, "Description is required"),
-  parameters: JSONSchemaFormSchema,
-});
-
-type FormValues = z.infer<typeof formSchema>;
-
-type CreateOrEditLLMToolDialog = {
-  children: React.ReactNode;
-  projectId: string;
-  onSave: (llmTool: LlmTool) => void;
-  onDelete?: (llmTool: LlmTool) => void;
-  existingLlmTool?: LlmTool;
-  defaultValues?: {
-    name: string;
-    description: string;
-    parameters: string;
-  };
-};
-
-export const CreateOrEditLLMToolDialog: React.FC<CreateOrEditLLMToolDialog> = (
-  props,
-) => {
-  const { children, projectId, onSave, existingLlmTool } = props;
-
-  const utils = api.useUtils();
-  const createLlmTool = api.llmTools.create.useMutation();
-  const updateLlmTool = api.llmTools.update.useMutation();
-  const deleteLlmTool = api.llmTools.delete.useMutation();
-
-  const [open, setOpen] = useState(false);
-
-  const form = useForm<FormValues>({
-    resolver: zodResolver(formSchema),
-    defaultValues: props.defaultValues ?? {
-      name: "",
-      description: "",
-      parameters: JSON.stringify(
-        {
-          type: "object",
-          properties: {},
-          required: [],
-          additionalProperties: false,
-        },
-        null,
-        2,
-      ),
-    },
-  });
-
-  // Populate form when in edit mode
-  useEffect(() => {
-    if (existingLlmTool) {
-      form.reset({
-        name: existingLlmTool.name,
-        description: existingLlmTool.description,
-        parameters: JSON.stringify(existingLlmTool.parameters, null, 2),
-      });
-    }
-  }, [existingLlmTool, form]);
-
-  async function onSubmit(values: FormValues) {
-    let result;
-    if (existingLlmTool) {
-      result = await updateLlmTool.mutateAsync({
-        id: existingLlmTool.id,
-        projectId,
-        name: values.name,
-        description: values.description,
-        parameters: JSON.parse(values.parameters),
-      });
-    } else {
-      result = await createLlmTool.mutateAsync({
-        projectId,
-        name: values.name,
-        description: values.description,
-        parameters: JSON.parse(values.parameters),
-      });
-    }
-
-    await utils.llmTools.getAll.invalidate({ projectId });
-
-    onSave(result);
-    setOpen(false);
-  }
-
-  async function handleDelete() {
-    if (!existingLlmTool) return;
-
-    await deleteLlmTool.mutateAsync({
-      id: existingLlmTool.id,
-      projectId,
-    });
-
-    props.onDelete?.(existingLlmTool);
-
-    await utils.llmTools.getAll.invalidate({ projectId });
-    setOpen(false);
-  }
-
-  const prettifyJson = () => {
-    try {
-      const currentValue = form.getValues("parameters");
-      const parsedJson = JSON.parse(currentValue);
-      const prettified = JSON.stringify(parsedJson, null, 2);
-      form.setValue("parameters", prettified);
-    } catch (error) {
-      console.error("Failed to prettify JSON:", error);
-    }
-  };
-
-  return (
-    <Dialog open={open} onOpenChange={setOpen}>
-      <DialogTrigger asChild onClick={(e) => e.stopPropagation()}>
-        {children}
-      </DialogTrigger>
-      <DialogContent
-        className="flex flex-col sm:min-w-[32rem] md:min-w-[40rem]"
-        onClick={(e) => e.stopPropagation()}
-      >
-        <DialogHeader>
-          <DialogTitle>
-            {existingLlmTool ? "Edit LLM Tool" : "Create LLM Tool"}
-          </DialogTitle>
-          <DialogDescription>
-            Define a tool for LLM function calling
-          </DialogDescription>
-        </DialogHeader>
-
-        <Form {...form}>
-          <form
-            onSubmit={form.handleSubmit(onSubmit)}
-            className="flex flex-1 flex-col"
-          >
-            <div className="flex-1 space-y-4 overflow-y-auto">
-              <FormField
-                control={form.control}
-                name="name"
-                render={({ field }) => (
-                  <FormItem>
-                    <FormLabel>Name</FormLabel>
-                    <FormControl>
-                      <Input placeholder="e.g., get_weather" {...field} />
-                    </FormControl>
-                    <FormMessage />
-                  </FormItem>
-                )}
-              />
-
-              <FormField
-                control={form.control}
-                name="description"
-                render={({ field }) => (
-                  <FormItem>
-                    <FormLabel>Description</FormLabel>
-                    <FormDescription>
-                      This description will be sent to the LLM to help it
-                      understand the tool&apos;s purpose and functionality.
-                    </FormDescription>
-                    <FormControl>
-                      <Textarea
-                        placeholder="Describe the tool's purpose and usage"
-                        className="max-h-[120px] focus:ring-0 focus:ring-offset-0 focus-visible:ring-0 focus-visible:ring-offset-0"
-                        {...field}
-                      />
-                    </FormControl>
-                    <FormMessage />
-                  </FormItem>
-                )}
-              />
-
-              <FormField
-                control={form.control}
-                name="parameters"
-                render={({ field }) => (
-                  <FormItem>
-                    <FormLabel>Parameters (JSON Schema)</FormLabel>
-                    <FormDescription>
-                      Define the structure of your tool parameters using JSON
-                      Schema format.{" "}
-                      <a
-                        href="https://json-schema.org/learn/miscellaneous-examples"
-                        target="_blank"
-                        rel="noopener noreferrer"
-                        className="flex items-center"
-                      >
-                        See JSON Schema examples here
-                        <ArrowUpRight className="h-3 w-3" />
-                      </a>
-                    </FormDescription>
-                    <FormControl>
-                      <div className="relative flex flex-col gap-1">
-                        <CodeMirrorEditor
-                          value={field.value}
-                          onChange={field.onChange}
-                          mode="json"
-                          minHeight={200}
-                          className="max-h-[25vh]"
-                        />
-                        <Button
-                          type="button"
-                          variant="outline"
-                          size="sm"
-                          onClick={prettifyJson}
-                          className="absolute right-3 top-3 text-xs"
-                        >
-                          Prettify
-                        </Button>
-                      </div>
-                    </FormControl>
-                    <p className="text-xs text-muted-foreground">
-                      Parameters must be a valid JSON Schema object
-                    </p>
-                    <FormMessage />
-                  </FormItem>
-                )}
-              />
-            </div>
-
-            <DialogFooter className="sticky bottom-0 mt-4 flex flex-col gap-2 border-t bg-background pt-4">
-              <div className="flex w-full flex-col gap-2">
-                <p className="text-xs text-muted-foreground">
-                  Note: Changes to tools are reflected to all members of this
-                  project.
-                </p>
-                <div className="flex items-center justify-between gap-2">
-                  {existingLlmTool && (
-                    <Button
-                      type="button"
-                      variant="destructive"
-                      onClick={handleDelete}
-                      className="mr-auto"
-                    >
-                      Delete
-                    </Button>
-                  )}
-                  <Button
-                    type="button"
-                    variant="outline"
-                    onClick={() => setOpen(false)}
-                  >
-                    Cancel
-                  </Button>
-                  <Button type="submit">Save</Button>
-                </div>
-              </div>
-            </DialogFooter>
-          </form>
-        </Form>
-      </DialogContent>
-    </Dialog>
-  );
-};
diff --git a/web/src/ee/features/playground/page/components/GenerationOutput.tsx b/web/src/ee/features/playground/page/components/GenerationOutput.tsx
deleted file mode 100644
index 27d2364..0000000
--- a/web/src/ee/features/playground/page/components/GenerationOutput.tsx
+++ /dev/null
@@ -1,108 +0,0 @@
-import { useEffect, useRef, useState } from "react";
-import { Button } from "@/src/components/ui/button";
-import { usePlaygroundContext } from "../context";
-import { CheckIcon, CopyIcon, PlusIcon } from "@radix-ui/react-icons";
-import { ChatMessageRole, ChatMessageType } from "@langfuse/shared";
-import { BracesIcon } from "lucide-react";
-import { ToolCallCard } from "@/src/components/ChatMessages/ToolCallCard";
-
-export const GenerationOutput = () => {
-  const [isCopied, setIsCopied] = useState(false);
-  const [isAdded, setIsAdded] = useState(false);
-  const [isJson, setIsJson] = useState(false);
-  const scrollAreaRef = useRef<HTMLDivElement | null>(null);
-  const { output, outputJson, addMessage, outputToolCalls } =
-    usePlaygroundContext();
-
-  const handleCopy = () => {
-    setIsCopied(true);
-    void navigator.clipboard.writeText(isJson ? outputJson : output);
-    setTimeout(() => setIsCopied(false), 1000);
-  };
-
-  const handleAddAssistantMessage = () => {
-    setIsAdded(true);
-    if (outputToolCalls.length > 0) {
-      addMessage({
-        type: ChatMessageType.AssistantToolCall,
-        role: ChatMessageRole.Assistant,
-        content: output,
-        toolCalls: outputToolCalls,
-      });
-    } else {
-      addMessage({
-        type: ChatMessageType.AssistantText,
-        role: ChatMessageRole.Assistant,
-        content: output,
-      });
-    }
-    setTimeout(() => setIsAdded(false), 1000);
-  };
-
-  useEffect(() => {
-    if (scrollAreaRef.current) {
-      const scrollElement = scrollAreaRef.current;
-      scrollElement.scrollTop = scrollElement.scrollHeight;
-    }
-  }, [output]);
-
-  const copyButton =
-    output || outputToolCalls.length ? (
-      <div className="absolute right-3 top-2 flex space-x-1 opacity-50">
-        <Button
-          size="icon"
-          variant={isJson ? "default" : "secondary"}
-          onClick={() => {
-            setIsJson((prev) => !prev);
-          }}
-          title="Toggle Input/Output JSON"
-        >
-          <BracesIcon size={15} />
-        </Button>
-
-        <Button
-          size="icon"
-          variant="secondary"
-          onClick={!isCopied ? handleCopy : undefined}
-          title="Copy output"
-        >
-          {isCopied ? <CheckIcon /> : <CopyIcon />}
-        </Button>
-
-        <Button
-          className="flex items-center gap-1 whitespace-nowrap p-0 px-1"
-          variant="secondary"
-          onClick={!isAdded ? handleAddAssistantMessage : undefined}
-          title="Add as assistant message"
-          disabled={isAdded}
-        >
-          {isAdded ? <CheckIcon /> : <PlusIcon />}
-          <span className="text-xs">Add to messages</span>
-        </Button>
-      </div>
-    ) : null;
-
-  return (
-    <div className="relative h-full overflow-auto">
-      <div
-        className="h-full overflow-auto rounded-lg bg-muted p-4"
-        ref={scrollAreaRef}
-      >
-        <div className="mb-4 flex w-full items-center">
-          <p className="flex-1 text-xs font-semibold">Output</p>
-          {copyButton}
-        </div>
-        <pre className="whitespace-break-spaces break-words text-xs">
-          {isJson ? outputJson : output}
-        </pre>
-        {outputToolCalls.length > 0
-          ? outputToolCalls.map((toolCall) => (
-              <div className="mt-4" key={toolCall.id}>
-                <ToolCallCard toolCall={toolCall} />
-              </div>
-            ))
-          : null}
-      </div>
-    </div>
-  );
-};
diff --git a/web/src/ee/features/playground/page/components/JumpToPlaygroundButton.tsx b/web/src/ee/features/playground/page/components/JumpToPlaygroundButton.tsx
deleted file mode 100644
index 8549852..0000000
--- a/web/src/ee/features/playground/page/components/JumpToPlaygroundButton.tsx
+++ /dev/null
@@ -1,416 +0,0 @@
-import { Terminal } from "lucide-react";
-import { useEffect, useState } from "react";
-import { useRouter } from "next/router";
-import { z } from "zod";
-
-import { createEmptyMessage } from "@/src/components/ChatMessages/utils/createEmptyMessage";
-import { Button } from "@/src/components/ui/button";
-import usePlaygroundCache from "@/src/ee/features/playground/page/hooks/usePlaygroundCache";
-import {
-  type PlaygroundTool,
-  type PlaygroundCache,
-  type PlaygroundSchema,
-} from "@/src/ee/features/playground/page/types";
-import { usePostHogClientCapture } from "@/src/features/posthog-analytics/usePostHogClientCapture";
-import { PromptType } from "@/src/features/prompts/server/utils/validation";
-import useProjectIdFromURL from "@/src/hooks/useProjectIdFromURL";
-import {
-  ChatMessageRole,
-  type Observation,
-  type Prompt,
-  supportedModels as playgroundSupportedModels,
-  type UIModelParams,
-  ZodModelConfig,
-  ChatMessageType,
-  LLMToolCallSchema,
-  OpenAIToolCallSchema,
-  OpenAIToolSchema,
-  type ChatMessage,
-  OpenAIResponseFormatSchema,
-} from "@langfuse/shared";
-import { useHasEntitlement } from "@/src/features/entitlements/hooks";
-import { cn } from "@/src/utils/tailwind";
-
-type JumpToPlaygroundButtonProps = (
-  | {
-      source: "prompt";
-      prompt: Prompt;
-      analyticsEventName: "prompt_detail:test_in_playground_button_click";
-    }
-  | {
-      source: "generation";
-      generation: Omit<Observation, "input" | "output"> & {
-        input: string | null;
-        output: string | null;
-      };
-      analyticsEventName: "trace_detail:test_in_playground_button_click";
-    }
-) & {
-  variant?: "outline" | "secondary";
-  className?: string;
-};
-
-export const JumpToPlaygroundButton: React.FC<JumpToPlaygroundButtonProps> = (
-  props,
-) => {
-  const router = useRouter();
-  const capture = usePostHogClientCapture();
-  const projectId = useProjectIdFromURL();
-  const { setPlaygroundCache } = usePlaygroundCache();
-  const [capturedState, setCapturedState] = useState<PlaygroundCache>(null);
-  const [isAvailable, setIsAvailable] = useState<boolean>(false);
-  const isEntitled = useHasEntitlement("playground");
-
-  useEffect(() => {
-    if (props.source === "prompt") {
-      setCapturedState(parsePrompt(props.prompt));
-    } else if (props.source === "generation") {
-      setCapturedState(parseGeneration(props.generation));
-    }
-  }, [props]);
-
-  useEffect(() => {
-    if (capturedState) {
-      setIsAvailable(true);
-    } else {
-      setIsAvailable(false);
-    }
-  }, [capturedState, setIsAvailable]);
-
-  const handleClick = () => {
-    capture(props.analyticsEventName);
-    setPlaygroundCache(capturedState);
-
-    router.push(`/project/${projectId}/playground`);
-  };
-
-  if (!isEntitled) return null;
-
-  return (
-    <Button
-      variant={props.variant ?? "secondary"}
-      disabled={!isAvailable}
-      title={
-        isAvailable
-          ? "Test in LLM playground"
-          : "Test in LLM playground is not available since messages are not in valid ChatML format or tool calls have been used. If you think this is not correct, please open a Github issue."
-      }
-      onClick={handleClick}
-      asChild
-      className={
-        !isAvailable ? "cursor-not-allowed opacity-50" : "cursor-pointer"
-      }
-    >
-      <span>
-        <Terminal className="h-4 w-4" />
-        <span className={cn("hidden md:ml-2 md:inline", props.className)}>
-          Playground
-        </span>
-      </span>
-    </Button>
-  );
-};
-
-const ParsedChatMessageListSchema = z.array(
-  z.object({
-    role: z.nativeEnum(ChatMessageRole),
-    content: z.union([
-      z.string(),
-      z
-        .array(
-          z
-            .object({
-              text: z.string(),
-            })
-            .transform((v) => v.text),
-        )
-        .transform((v) => v.join("")),
-      z.union([z.null(), z.undefined()]).transform((_) => ""),
-      z.any().transform((v) => JSON.stringify(v, null, 2)),
-    ]),
-    tool_calls: z
-      .union([z.array(LLMToolCallSchema), z.array(OpenAIToolCallSchema)])
-      .optional(),
-    tool_call_id: z.string().optional(),
-    additional_kwargs: z
-      .object({
-        tool_calls: z
-          .union([z.array(LLMToolCallSchema), z.array(OpenAIToolCallSchema)])
-          .optional(),
-      })
-      .optional(),
-  }),
-);
-
-// Langchain integration has the tool definition in a tool message
-// Those need to be filtered out in the chat messages and parsed when looking for tools
-const isLangchainToolDefinitionMessage = (
-  message: z.infer<typeof ParsedChatMessageListSchema>[0],
-): message is { content: string; role: ChatMessageRole } => {
-  try {
-    return OpenAIToolSchema.safeParse(JSON.parse(message.content)).success;
-  } catch {
-    return false;
-  }
-};
-
-const transformToPlaygroundMessage = (
-  message: z.infer<typeof ParsedChatMessageListSchema>[0],
-): ChatMessage => {
-  const { role, content } = message;
-
-  if (
-    message.role === "assistant" &&
-    (message.tool_calls || message.additional_kwargs?.tool_calls)
-  ) {
-    const toolCalls =
-      message.tool_calls ?? message.additional_kwargs?.tool_calls ?? [];
-
-    const playgroundMessage: ChatMessage = {
-      role: ChatMessageRole.Assistant,
-      content,
-      type: ChatMessageType.AssistantToolCall,
-      toolCalls: toolCalls.map((tc) => {
-        if ("function" in tc) {
-          return {
-            name: tc.function.name,
-            id: tc.id,
-            args: tc.function.arguments,
-          };
-        }
-
-        return tc;
-      }),
-    };
-
-    return playgroundMessage;
-  } else if (message.role === "tool") {
-    const playgroundMessage: ChatMessage = {
-      role: ChatMessageRole.Tool,
-      content,
-      type: ChatMessageType.ToolResult,
-      toolCallId: message.tool_call_id ?? "",
-    };
-
-    return playgroundMessage;
-  } else {
-    return {
-      role,
-      content,
-      type: ChatMessageType.PublicAPICreated,
-    };
-  }
-};
-
-const parsePrompt = (prompt: Prompt): PlaygroundCache => {
-  if (prompt.type === PromptType.Chat) {
-    const parsedMessages = ParsedChatMessageListSchema.safeParse(prompt.prompt);
-
-    return parsedMessages.success
-      ? { messages: parsedMessages.data.map(transformToPlaygroundMessage) }
-      : null;
-  } else {
-    const promptString = prompt.prompt?.valueOf();
-
-    return {
-      messages: [
-        createEmptyMessage({
-          type: ChatMessageType.System,
-          role: ChatMessageRole.System,
-          content: typeof promptString === "string" ? promptString : "",
-        }),
-      ],
-    };
-  }
-};
-
-const parseGeneration = (
-  generation: Omit<Observation, "input" | "output"> & {
-    input: string | null;
-    output: string | null;
-  },
-): PlaygroundCache => {
-  if (generation.type !== "GENERATION") return null;
-
-  const modelParams = parseModelParams(generation);
-  const tools = parseTools(generation);
-  const structuredOutputSchema = parseStructuredOutputSchema(generation);
-
-  let input = generation.input?.valueOf();
-
-  if (typeof input === "string") {
-    try {
-      input = JSON.parse(input);
-
-      if (typeof input === "string") {
-        return {
-          messages: [
-            createEmptyMessage({
-              type: ChatMessageType.System,
-              role: ChatMessageRole.System,
-              content: input,
-            }),
-          ],
-          modelParams,
-          tools,
-          structuredOutputSchema,
-        };
-      }
-    } catch (err) {
-      return {
-        messages: [
-          createEmptyMessage({
-            type: ChatMessageType.System,
-            role: ChatMessageRole.System,
-            content: input?.toString() ?? "",
-          }),
-        ],
-        modelParams,
-        tools,
-        structuredOutputSchema,
-      };
-    }
-  }
-
-  if (typeof input === "object") {
-    const parsedMessages = ParsedChatMessageListSchema.safeParse(
-      "messages" in input ? input["messages"] : input,
-    );
-
-    if (parsedMessages.success)
-      return {
-        messages: parsedMessages.data
-          .filter((m) => !isLangchainToolDefinitionMessage(m))
-          .map(transformToPlaygroundMessage),
-        modelParams,
-        tools,
-        structuredOutputSchema,
-      };
-  }
-
-  if (typeof input === "object" && "messages" in input) {
-    const parsedMessages = ParsedChatMessageListSchema.safeParse(
-      input["messages"],
-    );
-
-    if (parsedMessages.success)
-      return {
-        messages: parsedMessages.data
-          .filter((m) => !isLangchainToolDefinitionMessage(m))
-          .map(transformToPlaygroundMessage),
-        modelParams,
-        tools,
-        structuredOutputSchema,
-      };
-  }
-
-  return null;
-};
-
-function parseModelParams(
-  generation: Omit<Observation, "input" | "output">,
-):
-  | (Partial<UIModelParams> & Pick<UIModelParams, "provider" | "model">)
-  | undefined {
-  const generationModel = generation.model?.valueOf();
-  let modelParams:
-    | (Partial<UIModelParams> & Pick<UIModelParams, "provider" | "model">)
-    | undefined = undefined;
-
-  if (generationModel) {
-    const provider = Object.entries(playgroundSupportedModels).find(
-      ([_, models]) =>
-        generationModel ? models.some((m) => m === generationModel) : false,
-    )?.[0];
-
-    if (!provider) return;
-
-    modelParams = {
-      provider: { value: provider, enabled: true },
-      model: { value: generationModel, enabled: true },
-    } as Partial<UIModelParams> & Pick<UIModelParams, "provider" | "model">;
-
-    const generationModelParams = generation.modelParameters?.valueOf();
-
-    if (generationModelParams && typeof generationModelParams === "object") {
-      const parsedParams = ZodModelConfig.safeParse(generationModelParams);
-
-      if (parsedParams.success) {
-        Object.entries(parsedParams.data).forEach(([key, value]) => {
-          if (!modelParams) return;
-
-          modelParams[key as keyof typeof parsedParams.data] = {
-            value,
-            enabled: true,
-          };
-        });
-      }
-    }
-  }
-
-  return modelParams;
-}
-
-function parseTools(generation: Observation): PlaygroundTool[] {
-  // OpenAI Schema
-  try {
-    const input = JSON.parse(generation.input as string);
-    if (typeof input === "object" && input !== null && "tools" in input) {
-      const parsedTools = z.array(OpenAIToolSchema).safeParse(input["tools"]);
-
-      if (parsedTools.success)
-        return parsedTools.data.map((tool) => ({
-          id: Math.random().toString(36).substring(2),
-          ...tool.function,
-        }));
-    }
-  } catch {}
-
-  // Langchain Schema
-  try {
-    const input = JSON.parse(generation.input as string);
-
-    if (typeof input === "object" && input !== null) {
-      const parsedMessages = ParsedChatMessageListSchema.safeParse(
-        "messages" in input ? input["messages"] : input,
-      );
-
-      if (parsedMessages.success)
-        return parsedMessages.data
-          .filter(isLangchainToolDefinitionMessage)
-          .map((tool) => ({
-            id: Math.random().toString(36).substring(2),
-            ...JSON.parse(tool.content).function,
-          }));
-    }
-  } catch {}
-
-  return [];
-}
-
-function parseStructuredOutputSchema(
-  generation: Observation,
-): PlaygroundSchema | null {
-  try {
-    const metadata = generation.metadata;
-
-    if (
-      typeof metadata === "object" &&
-      metadata !== null &&
-      "response_format" in metadata
-    ) {
-      const parseStructuredOutputSchema = OpenAIResponseFormatSchema.safeParse(
-        metadata["response_format"],
-      );
-
-      if (parseStructuredOutputSchema.success)
-        return {
-          id: Math.random().toString(36).substring(2),
-          name: parseStructuredOutputSchema.data.json_schema.name,
-          description: "Schema parsed from generation",
-          schema: parseStructuredOutputSchema.data.json_schema.schema,
-        };
-    }
-  } catch {}
-  return null;
-}
diff --git a/web/src/ee/features/playground/page/components/Messages.tsx b/web/src/ee/features/playground/page/components/Messages.tsx
deleted file mode 100644
index ee170d4..0000000
--- a/web/src/ee/features/playground/page/components/Messages.tsx
+++ /dev/null
@@ -1,48 +0,0 @@
-import { Button } from "@/src/components/ui/button";
-import { usePlaygroundContext } from "@/src/ee/features/playground/page/context";
-
-import { GenerationOutput } from "./GenerationOutput";
-import { ChatMessages } from "@/src/components/ChatMessages";
-import { type MessagesContext } from "@/src/components/ChatMessages/types";
-import {
-  ResizableHandle,
-  ResizablePanel,
-  ResizablePanelGroup,
-} from "@/src/components/ui/resizable";
-
-export const Messages: React.FC<MessagesContext> = (props) => {
-  return (
-    <div className="flex h-full flex-col space-y-4 pr-4 pt-2">
-      <ResizablePanelGroup direction="vertical">
-        <ResizablePanel minSize={10}>
-          <ChatMessages {...props} />
-        </ResizablePanel>
-        <ResizableHandle withHandle className="bg-transparent" />
-        <ResizablePanel
-          minSize={10}
-          defaultSize={20}
-          className="flex flex-col space-y-4"
-        >
-          <GenerationOutput />
-        </ResizablePanel>
-      </ResizablePanelGroup>
-      <SubmitButton />
-    </div>
-  );
-};
-
-const SubmitButton = () => {
-  const { handleSubmit, isStreaming } = usePlaygroundContext();
-
-  return (
-    <Button
-      className="flex-0"
-      onClick={() => {
-        handleSubmit().catch((err) => console.error(err));
-      }}
-      loading={isStreaming}
-    >
-      <p>Submit (Ctrl + Enter)</p>
-    </Button>
-  );
-};
diff --git a/web/src/ee/features/playground/page/components/PlaygroundTools/index.tsx b/web/src/ee/features/playground/page/components/PlaygroundTools/index.tsx
deleted file mode 100644
index d063a12..0000000
--- a/web/src/ee/features/playground/page/components/PlaygroundTools/index.tsx
+++ /dev/null
@@ -1,272 +0,0 @@
-import React, { useCallback, useEffect, useState } from "react";
-
-import { usePlaygroundContext } from "@/src/ee/features/playground/page/context";
-import { Button } from "@/src/components/ui/button";
-import { ScrollArea } from "@/src/components/ui/scroll-area";
-import { PlusIcon, PencilIcon, MinusCircle, WrenchIcon } from "lucide-react";
-import { type LlmTool } from "@prisma/client";
-import { api } from "@/src/utils/api";
-import useProjectIdFromURL from "@/src/hooks/useProjectIdFromURL";
-import { CreateOrEditLLMToolDialog } from "@/src/ee/features/playground/page/components/CreateOrEditLLMToolDialog";
-import {
-  Command,
-  CommandEmpty,
-  CommandGroup,
-  CommandInput,
-  CommandItem,
-  CommandList,
-  CommandSeparator,
-} from "@/src/components/ui/command";
-import {
-  Popover,
-  PopoverContent,
-  PopoverTrigger,
-} from "@/src/components/ui/popover";
-
-import { type PlaygroundTool } from "@/src/ee/features/playground/page/types";
-
-export const PlaygroundTools = () => {
-  const { tools, setTools } = usePlaygroundContext();
-  const projectId = useProjectIdFromURL();
-  const [isSearchOpen, setIsSearchOpen] = useState(false);
-
-  const { data: savedTools = [] } = api.llmTools.getAll.useQuery(
-    {
-      projectId: projectId as string,
-    },
-    {
-      enabled: Boolean(projectId),
-      staleTime: 1000 * 60 * 5, // 5 minutes
-    },
-  );
-
-  const isToolSaved = useCallback(
-    (tool: PlaygroundTool) => {
-      return savedTools.some((savedTool) => savedTool.id === tool.id);
-    },
-    [savedTools],
-  );
-
-  useEffect(() => {
-    tools.forEach((tool, index) => {
-      if (!tool.existingLlmTool) {
-        const matchingSavedTool = savedTools.find(
-          (savedTool) =>
-            savedTool.name === tool.name &&
-            savedTool.description === tool.description &&
-            JSON.stringify(savedTool.parameters) ===
-              JSON.stringify(tool.parameters),
-        );
-
-        if (matchingSavedTool) {
-          const newTools = [...tools];
-          newTools[index] = {
-            ...tool,
-            id: matchingSavedTool.id,
-            existingLlmTool: matchingSavedTool,
-          };
-          setTools(newTools);
-        }
-      }
-    });
-  }, [savedTools, tools, setTools]);
-
-  const handleSelectTool = (selectedLLMTool: LlmTool) => {
-    setTools((prev: PlaygroundTool[]) => {
-      let existingToolIndex = -1;
-      existingToolIndex = prev.findIndex((t) => t.id === selectedLLMTool.id);
-
-      if (existingToolIndex === -1) {
-        const unsavedToolIndexWithSameName = prev.findIndex(
-          (t) => t.name === selectedLLMTool.name,
-        );
-
-        if (unsavedToolIndexWithSameName !== -1) {
-          existingToolIndex = unsavedToolIndexWithSameName;
-        }
-      }
-
-      const newTool: PlaygroundTool = {
-        id: selectedLLMTool.id,
-        name: selectedLLMTool.name,
-        description: selectedLLMTool.description,
-        parameters: selectedLLMTool.parameters as Record<string, unknown>,
-        existingLlmTool: selectedLLMTool,
-      };
-
-      if (existingToolIndex !== -1) {
-        const newTools = [...prev];
-        newTools[existingToolIndex] = newTool;
-
-        return newTools;
-      }
-
-      return [...prev, newTool];
-    });
-    setIsSearchOpen(false);
-  };
-
-  const handleRemoveTool = (toolId: string) => {
-    setTools(
-      (prev: PlaygroundTool[]) =>
-        prev.filter((t) => !(t.id === toolId)) as PlaygroundTool[],
-    );
-  };
-
-  return (
-    <div className="flex h-full flex-col pr-1">
-      <div className="mb-2 flex items-center justify-between">
-        <div className="flex items-center gap-2">
-          <p className="font-semibold">Tools</p>
-          <a
-            href="https://github.com/orgs/langfuse/discussions/3166"
-            target="_blank"
-            rel="noopener noreferrer"
-            className="inline-flex items-center"
-            title="Tool calling is currently in beta. Click here to learn more and provide feedback!"
-          >
-            <span className="rounded bg-muted px-1.5 py-0.5 text-xs font-medium text-muted-foreground">
-              Beta
-            </span>
-          </a>
-        </div>
-        <Popover open={isSearchOpen} onOpenChange={setIsSearchOpen}>
-          <PopoverTrigger asChild>
-            <Button className="h-7 w-7" variant="outline" size="icon">
-              <PlusIcon size={14} />
-            </Button>
-          </PopoverTrigger>
-          <PopoverContent align="end" className="p-1">
-            <Command className="flex flex-col">
-              <CommandInput
-                placeholder="Search tools..."
-                className="h-8 border-none p-1 focus:ring-0 focus:ring-offset-0"
-              />
-              <CommandList className="max-h-[300px] overflow-y-auto">
-                <CommandEmpty>No tools found.</CommandEmpty>
-                <CommandGroup>
-                  {savedTools.map((tool) => (
-                    <CommandItem
-                      key={tool.id}
-                      value={tool.name}
-                      onSelect={() => handleSelectTool(tool)}
-                      className="flex items-center justify-between px-1 py-2"
-                    >
-                      <div className="flex items-center gap-2">
-                        <WrenchIcon
-                          size={12}
-                          className="text-muted-foreground"
-                        />
-                        <div className="flex-1 overflow-hidden">
-                          <div className="truncate font-medium">
-                            {tool.name}
-                          </div>
-                          <div className="line-clamp-1 text-xs text-muted-foreground">
-                            {tool.description}
-                          </div>
-                        </div>
-                      </div>
-                      <CreateOrEditLLMToolDialog
-                        projectId={projectId as string}
-                        onSave={handleSelectTool}
-                        onDelete={() => handleRemoveTool(tool.id)}
-                        existingLlmTool={tool}
-                      >
-                        <Button
-                          variant="ghost"
-                          size="icon"
-                          className="ml-2 h-7 w-7 shrink-0"
-                        >
-                          <PencilIcon className="h-3.5 w-3.5" />
-                        </Button>
-                      </CreateOrEditLLMToolDialog>
-                    </CommandItem>
-                  ))}
-                </CommandGroup>
-                <CommandSeparator />
-              </CommandList>
-              <div className="mt-auto p-1">
-                <CreateOrEditLLMToolDialog
-                  projectId={projectId as string}
-                  onSave={handleSelectTool}
-                >
-                  <Button variant="outline" size="default" className="w-full">
-                    <PlusIcon className="mr-2 h-4 w-4" />
-                    Create new tool
-                  </Button>
-                </CreateOrEditLLMToolDialog>
-              </div>
-            </Command>
-          </PopoverContent>
-        </Popover>
-      </div>
-
-      <ScrollArea className="h-[calc(100%-2rem)]">
-        {tools.length === 0 ? (
-          <div className="flex h-16 flex-col items-center justify-center p-4 text-center">
-            <p className="text-xs text-muted-foreground">No tools attached.</p>
-          </div>
-        ) : (
-          <div className="space-y-1">
-            {tools.map((tool) => (
-              <CreateOrEditLLMToolDialog
-                key={tool.id}
-                projectId={projectId as string}
-                onSave={handleSelectTool}
-                onDelete={() => handleRemoveTool(tool.id)}
-                existingLlmTool={tool.existingLlmTool}
-                defaultValues={
-                  !isToolSaved(tool)
-                    ? {
-                        name: tool.name,
-                        description: tool.description,
-                        parameters: JSON.stringify(tool.parameters, null, 2),
-                      }
-                    : undefined
-                }
-              >
-                <div className="cursor-pointer rounded-md border bg-background p-2 transition-colors duration-200 hover:bg-accent/50">
-                  <div className="mb-1 flex items-center justify-between">
-                    <div className="flex items-center gap-1">
-                      <WrenchIcon className="h-4 w-4 text-muted-foreground" />
-                      <h3
-                        className="max-w-[200px] truncate text-ellipsis text-sm font-medium"
-                        title={tool.name}
-                      >
-                        {tool.name}
-                      </h3>
-                      {!isToolSaved(tool) ? (
-                        <span className="rounded bg-muted px-1 py-0.5 text-xs text-muted-foreground">
-                          Unsaved
-                        </span>
-                      ) : null}
-                    </div>
-                    <div className="flex items-center gap-1">
-                      <Button
-                        variant="ghost"
-                        size="sm"
-                        className="h-6 w-6 p-0"
-                        onClick={(e) => {
-                          e.stopPropagation();
-                          handleRemoveTool(tool.id);
-                        }}
-                      >
-                        <MinusCircle className="h-4 w-4" />
-                      </Button>
-                    </div>
-                  </div>
-                  <p
-                    className="line-clamp-2 text-xs text-muted-foreground"
-                    title={tool.description}
-                  >
-                    {tool.description}
-                  </p>
-                </div>
-              </CreateOrEditLLMToolDialog>
-            ))}
-          </div>
-        )}
-      </ScrollArea>
-    </div>
-  );
-};
diff --git a/web/src/ee/features/playground/page/components/PromptVariableComponent.tsx b/web/src/ee/features/playground/page/components/PromptVariableComponent.tsx
deleted file mode 100644
index b357b15..0000000
--- a/web/src/ee/features/playground/page/components/PromptVariableComponent.tsx
+++ /dev/null
@@ -1,63 +0,0 @@
-import { CheckCircle2, Circle, TrashIcon } from "lucide-react";
-import { Button } from "@/src/components/ui/button";
-import { type PromptVariable } from "@langfuse/shared";
-import { CodeMirrorEditor } from "@/src/components/editor";
-
-import { usePlaygroundContext } from "../context";
-
-export const PromptVariableComponent: React.FC<{
-  promptVariable: PromptVariable;
-}> = ({ promptVariable }) => {
-  const { updatePromptVariableValue, deletePromptVariable } =
-    usePlaygroundContext();
-  const { name, value, isUsed } = promptVariable;
-
-  const handleInputChange = (value: string) => {
-    updatePromptVariableValue(name, value);
-  };
-  const handleDeleteVariable = () => {
-    deletePromptVariable(name);
-  };
-  const isUsedIcon = isUsed ? (
-    <CheckCircle2 size={16} color="green" />
-  ) : (
-    <Circle size={16} color="grey" />
-  );
-  const isUsedTooltip = isUsed
-    ? "Variable is in use"
-    : "Variable is not in use";
-
-  return (
-    <div className="p-1">
-      <div className="mb-1 flex flex-row items-center">
-        <span className="flex flex-1 flex-row space-x-2 text-xs">
-          <p title={isUsedTooltip}>{isUsedIcon}</p>
-          <p className="min-w-[90px] truncate font-mono" title={name}>
-            {name}
-          </p>
-        </span>
-        <Button
-          variant="ghost"
-          size="icon"
-          title="Delete variable"
-          disabled={isUsed}
-          onClick={handleDeleteVariable}
-          className="p-0"
-        >
-          {!isUsed && <TrashIcon size={16} />}
-        </Button>
-      </div>
-
-      <CodeMirrorEditor
-        value={value}
-        onChange={(e) => handleInputChange(e)}
-        mode="prompt"
-        minHeight="none"
-        className="max-h-[10rem] w-full resize-y p-1 font-mono text-xs focus:outline-none"
-        editable={true}
-        lineNumbers={false}
-        placeholder={name}
-      />
-    </div>
-  );
-};
diff --git a/web/src/ee/features/playground/page/components/ResetPlaygroundButton.tsx b/web/src/ee/features/playground/page/components/ResetPlaygroundButton.tsx
deleted file mode 100644
index e5d7755..0000000
--- a/web/src/ee/features/playground/page/components/ResetPlaygroundButton.tsx
+++ /dev/null
@@ -1,31 +0,0 @@
-import { ListRestartIcon } from "lucide-react";
-import { useRouter } from "next/router";
-
-import { Button } from "@/src/components/ui/button";
-import usePlaygroundCache from "@/src/ee/features/playground/page/hooks/usePlaygroundCache";
-import { useHasEntitlement } from "@/src/features/entitlements/hooks";
-
-export const ResetPlaygroundButton: React.FC = () => {
-  const available = useHasEntitlement("playground");
-  const router = useRouter();
-  const { setPlaygroundCache } = usePlaygroundCache();
-
-  const handleClick = () => {
-    setPlaygroundCache(null);
-
-    router.reload();
-  };
-
-  if (!available) return null;
-
-  return (
-    <Button
-      variant={"outline"}
-      title="Reset playground state"
-      onClick={handleClick}
-    >
-      <ListRestartIcon className="mr-1 h-4 w-4" />
-      <span>Reset playground</span>
-    </Button>
-  );
-};
diff --git a/web/src/ee/features/playground/page/components/SaveToPromptButton.tsx b/web/src/ee/features/playground/page/components/SaveToPromptButton.tsx
deleted file mode 100644
index 4caf1a7..0000000
--- a/web/src/ee/features/playground/page/components/SaveToPromptButton.tsx
+++ /dev/null
@@ -1,167 +0,0 @@
-import { Check, FileInput } from "lucide-react";
-import Link from "next/link";
-import { useRouter } from "next/router";
-import { useState } from "react";
-
-import { Button } from "@/src/components/ui/button";
-import {
-  InputCommand,
-  InputCommandEmpty,
-  InputCommandGroup,
-  InputCommandInput,
-  InputCommandItem,
-  InputCommandList,
-} from "@/src/components/ui/input-command";
-import {
-  Popover,
-  PopoverContent,
-  PopoverTrigger,
-} from "@/src/components/ui/popover";
-import { usePlaygroundContext } from "@/src/ee/features/playground/page/context";
-import usePlaygroundCache from "@/src/ee/features/playground/page/hooks/usePlaygroundCache";
-import { usePostHogClientCapture } from "@/src/features/posthog-analytics/usePostHogClientCapture";
-import { PromptType } from "@/src/features/prompts/server/utils/validation";
-import useProjectIdFromURL from "@/src/hooks/useProjectIdFromURL";
-import { api } from "@/src/utils/api";
-import { cn } from "@/src/utils/tailwind";
-import { useHasEntitlement } from "@/src/features/entitlements/hooks";
-import DocPopup from "@/src/components/layouts/doc-popup";
-
-export const SaveToPromptButton: React.FC = () => {
-  const available = useHasEntitlement("playground");
-  const [selectedPromptId, setSelectedPromptId] = useState("");
-  const { modelParams, messages, output, promptVariables } =
-    usePlaygroundContext();
-  const capture = usePostHogClientCapture();
-  const router = useRouter();
-  const projectId = useProjectIdFromURL();
-  const { setPlaygroundCache } = usePlaygroundCache();
-
-  const allChatPromptNamesWithIds =
-    api.prompts.allNames
-      .useQuery(
-        {
-          projectId: projectId as string, // Typecast as query is enabled only when projectId is present
-          type: PromptType.Chat,
-        },
-        { enabled: Boolean(projectId) },
-      )
-      .data?.map((prompt) => ({
-        name: prompt.name,
-        id: prompt.id,
-      })) ?? [];
-
-  const handleNewPrompt = async () => {
-    capture("playground:save_to_new_prompt_button_click", { projectId });
-
-    setPlaygroundCache({
-      modelParams,
-      messages,
-      output,
-      promptVariables,
-    });
-
-    await router.push(
-      `/project/${projectId}/prompts/new?loadPlaygroundCache=true`,
-    );
-  };
-
-  const handleNewPromptVersion = async () => {
-    capture("playground:save_to_prompt_version_button_click", { projectId });
-
-    setPlaygroundCache({
-      modelParams,
-      messages,
-      output,
-      promptVariables,
-    });
-
-    await router.push(
-      `/project/${projectId}/prompts/new?promptId=${selectedPromptId}&loadPlaygroundCache=true`,
-    );
-  };
-
-  if (!available) return null;
-
-  return (
-    <Popover>
-      <PopoverTrigger asChild>
-        <Button variant={"outline"} title="Save to prompt" asChild>
-          <Link href={`/project/${projectId}/playground`}>
-            <FileInput className="mr-1 h-4 w-4" />
-            <span>Save as prompt</span>
-          </Link>
-        </Button>
-      </PopoverTrigger>
-      <PopoverContent>
-        <Button className="mt-2 w-full" onClick={handleNewPrompt}>
-          Save as new prompt
-        </Button>
-        <Divider />
-        <InputCommand className="min-h-[8rem]">
-          <InputCommandInput placeholder="Search chat prompts..." />
-          <InputCommandEmpty>
-            No chat prompt found
-            <DocPopup description="Prompts from the playground can only be saved to 'chat' prompts as they include multiple system/user messages." />
-          </InputCommandEmpty>
-          <InputCommandGroup className="mt-2">
-            <InputCommandList>
-              {allChatPromptNamesWithIds.map((chatPrompt) => (
-                <InputCommandItem
-                  key={chatPrompt.id}
-                  title={chatPrompt.name}
-                  value={chatPrompt.name}
-                  onSelect={(currentValue) => {
-                    const promptId =
-                      allChatPromptNamesWithIds.find(
-                        (prompt) => prompt.name === currentValue,
-                      )?.id ?? "";
-
-                    setSelectedPromptId(
-                      promptId === selectedPromptId ? "" : promptId,
-                    );
-                  }}
-                >
-                  <Check
-                    className={cn(
-                      "mr-2 h-4 w-4",
-                      selectedPromptId === chatPrompt.id
-                        ? "opacity-100"
-                        : "opacity-0",
-                    )}
-                  />
-                  <span className="overflow-hidden text-ellipsis whitespace-nowrap">
-                    {chatPrompt.name}
-                  </span>
-                </InputCommandItem>
-              ))}
-            </InputCommandList>
-          </InputCommandGroup>
-        </InputCommand>
-        <Button
-          className="mt-2 w-full"
-          disabled={!Boolean(selectedPromptId)}
-          onClick={handleNewPromptVersion}
-        >
-          Save as new prompt version
-        </Button>
-      </PopoverContent>
-    </Popover>
-  );
-};
-
-export function Divider() {
-  return (
-    <div className="my-3 flex flex-row justify-center align-middle">
-      <div className="flex flex-1 flex-col">
-        <div className="flex-1 border-b-2 border-gray-200" />
-        <div className="flex-1" />
-      </div>
-      <p className="mx-2 text-sm text-gray-400">or</p>
-      <div className="flex flex-1 flex-col">
-        <div className="flex-1 border-b-2 border-gray-200" />
-        <div className="flex-1" />
-      </div>
-    </div>
-  );
-}
diff --git a/web/src/ee/features/playground/page/components/StructuredOutputSchemaSection.tsx b/web/src/ee/features/playground/page/components/StructuredOutputSchemaSection.tsx
deleted file mode 100644
index df4cae4..0000000
--- a/web/src/ee/features/playground/page/components/StructuredOutputSchemaSection.tsx
+++ /dev/null
@@ -1,269 +0,0 @@
-import React, { useState, useCallback, useEffect } from "react";
-
-import { usePlaygroundContext } from "@/src/ee/features/playground/page/context";
-import { Button } from "@/src/components/ui/button";
-import { ScrollArea } from "@/src/components/ui/scroll-area";
-import { PlusIcon, PencilIcon, MinusCircle, BoxIcon } from "lucide-react";
-import { type LlmSchema } from "@langfuse/shared";
-import { api } from "@/src/utils/api";
-import useProjectIdFromURL from "@/src/hooks/useProjectIdFromURL";
-import { CreateOrEditLLMSchemaDialog } from "@/src/ee/features/playground/page/components/CreateOrEditLLMSchemaDialog";
-import {
-  Command,
-  CommandEmpty,
-  CommandGroup,
-  CommandInput,
-  CommandItem,
-  CommandList,
-  CommandSeparator,
-} from "@/src/components/ui/command";
-import {
-  Popover,
-  PopoverContent,
-  PopoverTrigger,
-} from "@/src/components/ui/popover";
-import { type PlaygroundSchema } from "@/src/ee/features/playground/page/types";
-
-export const StructuredOutputSchemaSection = () => {
-  const { structuredOutputSchema, setStructuredOutputSchema } =
-    usePlaygroundContext();
-  const projectId = useProjectIdFromURL();
-  const [isSearchOpen, setIsSearchOpen] = useState(false);
-
-  const { data: savedSchemas = [] } = api.llmSchemas.getAll.useQuery(
-    {
-      projectId: projectId as string,
-    },
-    {
-      enabled: Boolean(projectId),
-      staleTime: 1000 * 60 * 5, // 5 minutes
-    },
-  );
-
-  const isSchemaSaved = useCallback(
-    (schema: PlaygroundSchema) => {
-      return savedSchemas.some((savedSchema) => savedSchema.id === schema.id);
-    },
-    [savedSchemas],
-  );
-
-  useEffect(() => {
-    if (structuredOutputSchema && !structuredOutputSchema.existingLlmSchema) {
-      const matchingSavedSchema = savedSchemas.find(
-        (savedSchema) =>
-          savedSchema.name === structuredOutputSchema.name &&
-          savedSchema.description === structuredOutputSchema.description &&
-          JSON.stringify(savedSchema.schema) ===
-            JSON.stringify(structuredOutputSchema.schema),
-      );
-
-      if (matchingSavedSchema) {
-        setStructuredOutputSchema({
-          ...structuredOutputSchema,
-          id: matchingSavedSchema.id,
-          existingLlmSchema: matchingSavedSchema,
-        });
-      }
-    }
-  }, [savedSchemas, structuredOutputSchema, setStructuredOutputSchema]);
-
-  const handleSelectSchema = (selectedLLMSchema: LlmSchema) => {
-    if (
-      structuredOutputSchema &&
-      structuredOutputSchema.id === selectedLLMSchema.id
-    ) {
-      // Schema already selected, just update it
-      setStructuredOutputSchema({
-        ...structuredOutputSchema,
-        name: selectedLLMSchema.name,
-        description: selectedLLMSchema.description,
-        schema: selectedLLMSchema.schema as Record<string, unknown>,
-        existingLlmSchema: selectedLLMSchema,
-      });
-    } else if (
-      structuredOutputSchema &&
-      structuredOutputSchema.name === selectedLLMSchema.name &&
-      !isSchemaSaved(structuredOutputSchema)
-    ) {
-      // Replace unsaved schema with same name
-      setStructuredOutputSchema({
-        id: selectedLLMSchema.id,
-        name: selectedLLMSchema.name,
-        description: selectedLLMSchema.description,
-        schema: selectedLLMSchema.schema as Record<string, unknown>,
-        existingLlmSchema: selectedLLMSchema,
-      });
-    } else {
-      // New schema
-      const newPlaygroundSchema: PlaygroundSchema = {
-        id: selectedLLMSchema.id,
-        name: selectedLLMSchema.name,
-        description: selectedLLMSchema.description,
-        schema: selectedLLMSchema.schema as Record<string, unknown>,
-        existingLlmSchema: selectedLLMSchema,
-      };
-      setStructuredOutputSchema(newPlaygroundSchema);
-    }
-    setIsSearchOpen(false);
-  };
-
-  const handleRemoveSchema = () => {
-    setStructuredOutputSchema(null);
-  };
-
-  return (
-    <div className="flex h-full flex-col pr-1">
-      <div className="mb-2 flex items-center justify-between">
-        <div className="flex items-center gap-2">
-          <p className="font-semibold">Structured Output</p>
-          <a
-            href="https://github.com/orgs/langfuse/discussions/3166"
-            target="_blank"
-            rel="noopener noreferrer"
-            className="inline-flex items-center"
-            title="Structured output is currently in beta. Click here to learn more and provide feedback!"
-          >
-            <span className="rounded bg-muted px-1.5 py-0.5 text-xs font-medium text-muted-foreground">
-              Beta
-            </span>
-          </a>
-        </div>
-        <Popover open={isSearchOpen} onOpenChange={setIsSearchOpen}>
-          <PopoverTrigger asChild>
-            <Button className="h-7 w-7" variant="outline" size="icon">
-              <PlusIcon size={14} />
-            </Button>
-          </PopoverTrigger>
-          <PopoverContent align="end" className="p-1">
-            <Command className="flex flex-col">
-              <CommandInput
-                placeholder="Search schemas..."
-                className="h-8 border-none p-1 focus:ring-0 focus:ring-offset-0"
-              />
-              <CommandList className="max-h-[300px] overflow-y-auto">
-                <CommandEmpty>No schemas found.</CommandEmpty>
-                <CommandGroup>
-                  {savedSchemas.map((schema) => (
-                    <CommandItem
-                      key={schema.id}
-                      value={schema.name}
-                      onSelect={() => handleSelectSchema(schema)}
-                      className="flex items-center justify-between px-1 py-2"
-                    >
-                      <div className="flex items-center gap-2">
-                        <BoxIcon className="h-4 w-4 text-muted-foreground" />
-                        <div className="flex-1 overflow-hidden">
-                          <div className="truncate font-medium">
-                            {schema.name}
-                          </div>
-                          <div className="line-clamp-1 text-xs text-muted-foreground">
-                            {schema.description}
-                          </div>
-                        </div>
-                      </div>
-                      <CreateOrEditLLMSchemaDialog
-                        projectId={projectId as string}
-                        onSave={handleSelectSchema}
-                        onDelete={() => handleRemoveSchema()}
-                        existingLlmSchema={schema}
-                      >
-                        <Button
-                          variant="ghost"
-                          size="icon"
-                          className="ml-2 h-7 w-7 shrink-0"
-                          onClick={(e) => e.stopPropagation()}
-                        >
-                          <PencilIcon className="h-3.5 w-3.5" />
-                        </Button>
-                      </CreateOrEditLLMSchemaDialog>
-                    </CommandItem>
-                  ))}
-                </CommandGroup>
-                <CommandSeparator />
-              </CommandList>
-              <div className="mt-auto p-1">
-                <CreateOrEditLLMSchemaDialog
-                  projectId={projectId as string}
-                  onSave={handleSelectSchema}
-                >
-                  <Button variant="outline" size="default" className="w-full">
-                    <PlusIcon className="mr-2 h-4 w-4" />
-                    Create new schema
-                  </Button>
-                </CreateOrEditLLMSchemaDialog>
-              </div>
-            </Command>
-          </PopoverContent>
-        </Popover>
-      </div>
-
-      <ScrollArea className="h-[calc(100%-2rem)]">
-        {!structuredOutputSchema ? (
-          <div className="flex h-16 flex-col items-center justify-center p-4 text-center">
-            <p className="text-xs text-muted-foreground">No schema provided.</p>
-          </div>
-        ) : (
-          <div className="space-y-1">
-            <CreateOrEditLLMSchemaDialog
-              projectId={projectId as string}
-              onSave={handleSelectSchema}
-              onDelete={() => handleRemoveSchema()}
-              existingLlmSchema={structuredOutputSchema.existingLlmSchema}
-              defaultValues={
-                !isSchemaSaved(structuredOutputSchema)
-                  ? {
-                      name: structuredOutputSchema.name,
-                      description: structuredOutputSchema.description,
-                      schema: JSON.stringify(
-                        structuredOutputSchema.schema,
-                        null,
-                        2,
-                      ),
-                    }
-                  : undefined
-              }
-            >
-              <div className="cursor-pointer rounded-md border bg-background p-2 transition-colors duration-200 hover:bg-accent/50">
-                <div className="mb-1 flex items-center justify-between">
-                  <div className="flex items-center gap-1">
-                    <BoxIcon className="h-4 w-4 text-muted-foreground" />
-                    <h3
-                      className="max-w-[200px] truncate text-ellipsis text-sm font-medium"
-                      title={structuredOutputSchema.name}
-                    >
-                      {structuredOutputSchema.name}
-                    </h3>
-                    {!isSchemaSaved(structuredOutputSchema) ? (
-                      <span className="rounded bg-muted px-1 py-0.5 text-xs text-muted-foreground">
-                        Unsaved
-                      </span>
-                    ) : null}
-                  </div>
-                  <div className="flex items-center gap-1">
-                    <Button
-                      variant="ghost"
-                      size="sm"
-                      className="h-6 w-6 p-0"
-                      onClick={(e) => {
-                        e.stopPropagation();
-                        handleRemoveSchema();
-                      }}
-                    >
-                      <MinusCircle className="h-4 w-4" />
-                    </Button>
-                  </div>
-                </div>
-                <p
-                  className="line-clamp-2 text-xs text-muted-foreground"
-                  title={structuredOutputSchema.description}
-                >
-                  {structuredOutputSchema.description}
-                </p>
-              </div>
-            </CreateOrEditLLMSchemaDialog>
-          </div>
-        )}
-      </ScrollArea>
-    </div>
-  );
-};
diff --git a/web/src/ee/features/playground/page/components/Variables.tsx b/web/src/ee/features/playground/page/components/Variables.tsx
deleted file mode 100644
index e2f3de4..0000000
--- a/web/src/ee/features/playground/page/components/Variables.tsx
+++ /dev/null
@@ -1,48 +0,0 @@
-import { Divider } from "@tremor/react";
-
-import { usePlaygroundContext } from "../context";
-import { PromptVariableComponent } from "./PromptVariableComponent";
-
-export const Variables = () => {
-  const { promptVariables } = usePlaygroundContext();
-  const renderNoVariables = () => (
-    <div className="mt-4 text-xs">
-      <p className="mb-2">No variables defined.</p>
-      <p>
-        Use handlebars in your prompts to add a variable:
-        &#123;&#123;exampleVariable&#125;&#125;
-      </p>
-    </div>
-  );
-  const renderVariables = () => (
-    <div className="h-full overflow-auto">
-      {promptVariables
-        .sort((a, b) => {
-          if (a.isUsed && !b.isUsed) return -1;
-          if (!a.isUsed && b.isUsed) return 1;
-
-          return a.name.localeCompare(b.name);
-        })
-        .map((promptVariable, index) => {
-          return (
-            <>
-              <PromptVariableComponent
-                promptVariable={promptVariable}
-                key={promptVariable.name}
-              />
-              {index !== promptVariables.length - 1 ? (
-                <Divider className="my-2 text-muted-foreground" />
-              ) : null}
-            </>
-          );
-        })}
-    </div>
-  );
-
-  return (
-    <div className="flex h-full flex-col">
-      <p className="font-semibold">Variables</p>
-      {promptVariables.length === 0 ? renderNoVariables() : renderVariables()}
-    </div>
-  );
-};
diff --git a/web/src/ee/features/playground/page/context/index.tsx b/web/src/ee/features/playground/page/context/index.tsx
deleted file mode 100644
index 02b17f3..0000000
--- a/web/src/ee/features/playground/page/context/index.tsx
+++ /dev/null
@@ -1,613 +0,0 @@
-import React, {
-  createContext,
-  type PropsWithChildren,
-  useCallback,
-  useContext,
-  useEffect,
-  useState,
-} from "react";
-
-import { v4 as uuidv4 } from "uuid";
-
-import { createEmptyMessage } from "@/src/components/ChatMessages/utils/createEmptyMessage";
-import useCommandEnter from "@/src/ee/features/playground/page/hooks/useCommandEnter";
-import { useModelParams } from "@/src/ee/features/playground/page/hooks/useModelParams";
-import usePlaygroundCache from "@/src/ee/features/playground/page/hooks/usePlaygroundCache";
-import { getFinalModelParams } from "@/src/ee/utils/getFinalModelParams";
-import { usePostHogClientCapture } from "@/src/features/posthog-analytics/usePostHogClientCapture";
-import useProjectIdFromURL from "@/src/hooks/useProjectIdFromURL";
-import {
-  ChatMessageRole,
-  extractVariables,
-  type ChatMessageWithId,
-  type PromptVariable,
-  ToolCallResponseSchema,
-  type UIModelParams,
-  type ToolCallResponse,
-  type LLMToolDefinition,
-  type LLMToolCall,
-  ChatMessageType,
-} from "@langfuse/shared";
-
-import type { MessagesContext } from "@/src/components/ChatMessages/types";
-import type { ModelParamsContext } from "@/src/components/ModelParameters";
-import { env } from "@/src/env.mjs";
-import {
-  type PlaygroundSchema,
-  type PlaygroundTool,
-} from "@/src/ee/features/playground/page/types";
-
-type PlaygroundContextType = {
-  promptVariables: PromptVariable[];
-  updatePromptVariableValue: (variable: string, value: string) => void;
-  deletePromptVariable: (variable: string) => void;
-
-  tools: PlaygroundTool[];
-  setTools: React.Dispatch<React.SetStateAction<PlaygroundTool[]>>;
-
-  structuredOutputSchema: PlaygroundSchema | null;
-  setStructuredOutputSchema: (schema: PlaygroundSchema | null) => void;
-
-  output: string;
-  outputJson: string;
-  outputToolCalls: LLMToolCall[];
-
-  handleSubmit: () => Promise<void>;
-  isStreaming: boolean;
-} & ModelParamsContext &
-  MessagesContext;
-
-const PlaygroundContext = createContext<PlaygroundContextType | undefined>(
-  undefined,
-);
-
-export const usePlaygroundContext = () => {
-  const context = useContext(PlaygroundContext);
-  if (!context) {
-    throw new Error(
-      "usePlaygroundContext must be used within a PlaygroundProvider",
-    );
-  }
-  return context;
-};
-
-export const PlaygroundProvider: React.FC<PropsWithChildren> = ({
-  children,
-}) => {
-  const capture = usePostHogClientCapture();
-  const projectId = useProjectIdFromURL();
-  const { playgroundCache, setPlaygroundCache } = usePlaygroundCache();
-  const [promptVariables, setPromptVariables] = useState<PromptVariable[]>([]);
-  const [output, setOutput] = useState("");
-  const [outputToolCalls, setOutputToolCalls] = useState<LLMToolCall[]>([]);
-  const [outputJson, setOutputJson] = useState("");
-  const [isStreaming, setIsStreaming] = useState(false);
-  const [tools, setTools] = useState<PlaygroundTool[]>([]);
-  const [structuredOutputSchema, setStructuredOutputSchema] =
-    useState<PlaygroundSchema | null>(null);
-  const [messages, setMessages] = useState<ChatMessageWithId[]>([
-    createEmptyMessage({
-      type: ChatMessageType.System,
-      role: ChatMessageRole.System,
-      content: "",
-    }),
-    createEmptyMessage({
-      type: ChatMessageType.User,
-      role: ChatMessageRole.User,
-      content: "",
-    }),
-  ]);
-
-  const {
-    modelParams,
-    setModelParams,
-    availableProviders,
-    availableModels,
-    updateModelParamValue,
-    setModelParamEnabled,
-  } = useModelParams();
-
-  const toolCallIds = messages.reduce((acc, m) => {
-    if (m.type === ChatMessageType.AssistantToolCall) {
-      acc.push(...m.toolCalls.map((tc) => tc.id));
-    }
-    return acc;
-  }, [] as string[]);
-
-  // Load state from cache
-  useEffect(() => {
-    if (!playgroundCache) return;
-
-    const {
-      messages: cachedMessages,
-      modelParams: cachedModelParams,
-      output: cachedOutput,
-      promptVariables: cachedPromptVariables,
-      tools: cachedTools,
-      structuredOutputSchema: cachedStructuredOutputSchema,
-    } = playgroundCache;
-
-    setMessages(cachedMessages.map((m) => ({ ...m, id: uuidv4() })));
-
-    if (cachedOutput) {
-      // Try parsing a previous output with tool calls
-      try {
-        const completion = JSON.parse(cachedOutput);
-        const parsed = ToolCallResponseSchema.parse(completion);
-
-        setOutput(String(parsed.content));
-        setOutputToolCalls(parsed.tool_calls);
-      } catch {
-        setOutput(cachedOutput);
-        setOutputJson("");
-      }
-    }
-
-    if (cachedModelParams) {
-      setModelParams((prev) => ({ ...prev, ...cachedModelParams }));
-    }
-
-    if (cachedPromptVariables) {
-      setPromptVariables(cachedPromptVariables);
-    }
-
-    if (cachedTools) {
-      setTools(cachedTools);
-    }
-
-    if (cachedStructuredOutputSchema) {
-      setStructuredOutputSchema(cachedStructuredOutputSchema);
-    }
-  }, [playgroundCache, setModelParams]);
-
-  const updatePromptVariables = useCallback(() => {
-    const messageContents = messages.map((m) => m.content).join("\n");
-    const variables = extractVariables(messageContents)
-      .map((v) => v.trim())
-      .filter(Boolean);
-
-    setPromptVariables((prev) => {
-      // Update isUsed flag
-      const next = prev.reduce<PromptVariable[]>((acc, v) => {
-        const isUsed = variables.includes(v.name);
-
-        if (!isUsed && !v.value) return acc;
-
-        acc.push({ ...v, isUsed: isUsed });
-
-        return acc;
-      }, []);
-
-      // Create new variables if any
-      for (const variable of variables) {
-        if (!next.some((v) => v.name === variable)) {
-          next.push({ name: variable, value: "", isUsed: true });
-        }
-      }
-
-      return next;
-    });
-  }, [messages]);
-
-  useEffect(updatePromptVariables, [messages, updatePromptVariables]);
-
-  const addMessage: PlaygroundContextType["addMessage"] = useCallback(
-    (message) => {
-      if (message.type === ChatMessageType.AssistantToolCall) {
-        const toolCallMessage = createEmptyMessage({
-          type: ChatMessageType.AssistantToolCall,
-          role: ChatMessageRole.Assistant,
-          content: message.content ?? "",
-          toolCalls: message.toolCalls,
-        });
-        const toolResultMessages: ChatMessageWithId[] = [];
-
-        for (const toolCall of message.toolCalls) {
-          const toolResultMessage = createEmptyMessage({
-            type: ChatMessageType.ToolResult,
-            role: ChatMessageRole.Tool,
-            content: "",
-            toolCallId: toolCall.id,
-          });
-
-          toolResultMessages.push(toolResultMessage);
-        }
-
-        setMessages((prev) => [
-          ...prev,
-          ...[toolCallMessage],
-          ...toolResultMessages,
-        ]);
-
-        return toolCallMessage;
-      } else {
-        const newMessage = createEmptyMessage(message);
-        setMessages((prev) => [...prev, newMessage]);
-
-        return newMessage;
-      }
-    },
-    [],
-  );
-
-  const updateMessage: PlaygroundContextType["updateMessage"] = useCallback(
-    (_, id, key, value) => {
-      setMessages((prev) =>
-        prev.map((message) =>
-          message.id === id ? { ...message, [key]: value } : message,
-        ),
-      );
-    },
-    [],
-  );
-
-  const replaceMessage: PlaygroundContextType["replaceMessage"] = useCallback(
-    (id, message) => {
-      setMessages((prev) =>
-        prev.map((m) => (m.id === id ? { id, ...message } : m)),
-      );
-    },
-    [],
-  );
-
-  const deleteMessage: PlaygroundContextType["deleteMessage"] = useCallback(
-    (id) => {
-      setMessages((prev) => prev.filter((message) => message.id !== id));
-    },
-    [],
-  );
-
-  const handleSubmit: PlaygroundContextType["handleSubmit"] =
-    useCallback(async () => {
-      try {
-        setIsStreaming(true);
-        setOutput("");
-        setOutputJson("");
-        setOutputToolCalls([]);
-
-        const finalMessages = getFinalMessages(promptVariables, messages);
-        const leftOverVariables = extractVariables(
-          finalMessages.map((m) => m.content).join("\n"),
-        );
-
-        if (!modelParams.provider.value || !modelParams.model.value) {
-          throw new Error("Please select a model");
-        }
-
-        if (leftOverVariables.length > 0) {
-          throw Error("Error replacing variables. Please check your inputs.");
-        }
-
-        if (tools.length > 0 && structuredOutputSchema) {
-          throw new Error(
-            "Cannot use both tools and structured output at the same time",
-          );
-        }
-
-        let response = "";
-        if (tools.length > 0) {
-          const completion = await getChatCompletionWithTools(
-            projectId,
-            finalMessages,
-            modelParams,
-            tools,
-          );
-
-          const displayContent =
-            typeof completion.content === "string"
-              ? completion.content
-              : (completion.content.find(
-                  (m): m is { type: "text"; text: string } => m.type === "text",
-                )?.text as string);
-
-          setOutput(displayContent);
-          setOutputToolCalls(completion.tool_calls);
-
-          response = JSON.stringify(completion, null, 2);
-        } else if (structuredOutputSchema) {
-          response = await getChatCompletionWithStructuredOutput(
-            projectId,
-            finalMessages,
-            modelParams,
-            structuredOutputSchema,
-          );
-
-          setOutput(response);
-        } else {
-          const completionStream = getChatCompletionStream(
-            projectId,
-            finalMessages,
-            modelParams,
-          );
-
-          for await (const token of completionStream) {
-            response += token;
-            setOutput(response);
-          }
-        }
-
-        setOutputJson(
-          getOutputJson(
-            response,
-            finalMessages,
-            modelParams,
-            tools,
-            structuredOutputSchema,
-          ),
-        );
-        setPlaygroundCache({
-          messages,
-          modelParams,
-          output: response,
-          promptVariables,
-          tools,
-          structuredOutputSchema,
-        });
-        capture("playground:execute_button_click", {
-          inputLength: finalMessages.length,
-          modelName: modelParams.model,
-          modelProvider: modelParams.provider,
-          outputLength: response.length,
-          toolCount: tools.length,
-          isStructuredOutput: Boolean(structuredOutputSchema),
-        });
-      } catch (err) {
-        console.error(err);
-
-        alert(err instanceof Error ? err.message : "An error occurred");
-        // TODO: add error handling via toast
-      } finally {
-        setIsStreaming(false);
-      }
-    }, [
-      messages,
-      modelParams,
-      promptVariables,
-      tools,
-      capture,
-      setPlaygroundCache,
-      structuredOutputSchema,
-      projectId,
-    ]);
-
-  useCommandEnter(!isStreaming, handleSubmit);
-
-  const updatePromptVariableValue = useCallback(
-    (variable: string, value: string) => {
-      setPromptVariables((prev) =>
-        prev.map((v) => (v.name === variable ? { ...v, value } : v)),
-      );
-    },
-    [],
-  );
-
-  const deletePromptVariable = useCallback((variable: string) => {
-    setPromptVariables((prev) => prev.filter((v) => v.name !== variable));
-  }, []);
-
-  return (
-    <PlaygroundContext.Provider
-      value={{
-        promptVariables,
-        updatePromptVariableValue,
-        deletePromptVariable,
-
-        tools,
-        setTools,
-
-        structuredOutputSchema,
-        setStructuredOutputSchema,
-
-        messages,
-        addMessage,
-        setMessages,
-        updateMessage,
-        replaceMessage,
-        deleteMessage,
-        toolCallIds,
-
-        modelParams,
-        updateModelParamValue,
-        setModelParamEnabled,
-
-        output,
-        outputJson,
-        outputToolCalls,
-        handleSubmit,
-        isStreaming,
-
-        availableProviders,
-        availableModels,
-      }}
-    >
-      {children}
-    </PlaygroundContext.Provider>
-  );
-};
-
-async function getChatCompletionWithTools(
-  projectId: string | undefined,
-  messages: ChatMessageWithId[],
-  modelParams: UIModelParams,
-  tools: unknown[],
-): Promise<ToolCallResponse> {
-  if (!projectId) throw Error("Project ID is not set");
-
-  const body = JSON.stringify({
-    projectId,
-    messages,
-    modelParams: getFinalModelParams(modelParams),
-    tools,
-  });
-  const result = await fetch(
-    `${env.NEXT_PUBLIC_BASE_PATH ?? ""}/api/chatCompletion`,
-    {
-      method: "POST",
-      headers: { "Content-Type": "application/json" },
-      body,
-    },
-  );
-
-  const responseData = await result.json();
-
-  if (!result.ok) {
-    throw new Error(`Completion failed: ${responseData.message}`);
-  }
-
-  const parsed = ToolCallResponseSchema.safeParse(responseData);
-  if (!parsed.success)
-    throw Error(
-      "Failed to parse tool call response client-side:\n" +
-        JSON.stringify(responseData, null, 2),
-    );
-
-  return parsed.data;
-}
-
-async function getChatCompletionWithStructuredOutput(
-  projectId: string | undefined,
-  messages: ChatMessageWithId[],
-  modelParams: UIModelParams,
-  structuredOutputSchema: PlaygroundSchema | null,
-): Promise<string> {
-  if (!projectId) throw Error("Project ID is not set");
-
-  const body = JSON.stringify({
-    projectId,
-    messages,
-    modelParams: getFinalModelParams(modelParams),
-    structuredOutputSchema: structuredOutputSchema?.schema,
-  });
-
-  const result = await fetch(
-    `${env.NEXT_PUBLIC_BASE_PATH ?? ""}/api/chatCompletion`,
-    {
-      method: "POST",
-      headers: { "Content-Type": "application/json" },
-      body,
-    },
-  );
-
-  if (!result.ok) {
-    const responseData = await result.json();
-    throw new Error(`Completion failed: ${responseData.message}`);
-  }
-
-  const responseData = await result.text();
-
-  try {
-    const parsed = JSON.parse(responseData);
-    return JSON.stringify(parsed, null, 2);
-  } catch {
-    return responseData;
-  }
-}
-
-async function* getChatCompletionStream(
-  projectId: string | undefined,
-  messages: ChatMessageWithId[],
-  modelParams: UIModelParams,
-) {
-  if (!projectId) {
-    console.error("Project ID is not set");
-    return;
-  }
-
-  const body = JSON.stringify({
-    projectId,
-    messages,
-    modelParams: getFinalModelParams(modelParams),
-  });
-  const result = await fetch(
-    `${env.NEXT_PUBLIC_BASE_PATH ?? ""}/api/chatCompletion`,
-    {
-      method: "POST",
-      headers: { "Content-Type": "application/json" },
-      body,
-    },
-  );
-
-  if (!result.ok) {
-    const errorData = await result.json();
-
-    throw new Error(`Completion failed: ${errorData.message}`);
-  }
-
-  const reader = result.body?.getReader();
-  if (!reader) {
-    throw new Error("Failed to read response body");
-  }
-
-  const decoder = new TextDecoder("utf-8");
-  try {
-    while (true) {
-      const { done, value } = await reader.read();
-      if (done) break;
-
-      const token = decoder.decode(value);
-
-      yield token;
-    }
-  } catch (error) {
-    throw error;
-  } finally {
-    reader.releaseLock();
-  }
-}
-
-function getFinalMessages(
-  promptVariables: PromptVariable[],
-  messages: ChatMessageWithId[],
-) {
-  const missingVariables = promptVariables.filter((v) => !v.value && v.isUsed);
-  if (missingVariables.length > 0) {
-    throw new Error(
-      `Please set a value for the following variables: ${missingVariables
-        .map((v) => v.name)
-        .join(", ")}`,
-    );
-  }
-
-  // Dynamically replace variables in the prompt
-  const finalMessages = messages
-    .filter(
-      (m) =>
-        m.content.length > 0 || ("toolCalls" in m && m.toolCalls.length > 0),
-    )
-    .map((m) => {
-      let content = m.content;
-      for (const variable of promptVariables) {
-        content = content.replace(
-          new RegExp(`{{\\s*${variable.name}\\s*}}`, "g"),
-          variable.value,
-        );
-      }
-
-      return { ...m, content };
-    });
-  return finalMessages;
-}
-
-function getOutputJson(
-  output: string,
-  messages: ChatMessageWithId[],
-  modelParams: UIModelParams,
-  tools: LLMToolDefinition[],
-  structuredOutputSchema: PlaygroundSchema | null,
-) {
-  return JSON.stringify(
-    {
-      input: messages.map((obj) => filterKeyFromObject(obj, "id")),
-      output,
-      model: getFinalModelParams(modelParams),
-      tools,
-      structuredOutputSchema,
-    },
-    null,
-    2,
-  );
-}
-
-function filterKeyFromObject<T extends object>(obj: T, key: keyof T) {
-  return Object.fromEntries(Object.entries(obj).filter(([k, _]) => k !== key));
-}
diff --git a/web/src/ee/features/playground/page/hooks/useCommandEnter.ts b/web/src/ee/features/playground/page/hooks/useCommandEnter.ts
deleted file mode 100644
index fef2874..0000000
--- a/web/src/ee/features/playground/page/hooks/useCommandEnter.ts
+++ /dev/null
@@ -1,22 +0,0 @@
-import { useEffect } from "react";
-
-export default function useCommandEnter(
-  isEnabled: boolean,
-  callback: () => Promise<void>,
-) {
-  useEffect(() => {
-    function handleKeyDown(event: KeyboardEvent) {
-      if (
-        isEnabled &&
-        (event.metaKey || event.ctrlKey) &&
-        event.code === "Enter"
-      ) {
-        callback().catch((err) => console.error(err));
-      }
-    }
-
-    document.addEventListener("keydown", handleKeyDown);
-
-    return () => document.removeEventListener("keydown", handleKeyDown);
-  }, [isEnabled, callback]);
-}
diff --git a/web/src/ee/features/playground/page/hooks/useModelParams.ts b/web/src/ee/features/playground/page/hooks/useModelParams.ts
deleted file mode 100644
index f489ba4..0000000
--- a/web/src/ee/features/playground/page/hooks/useModelParams.ts
+++ /dev/null
@@ -1,265 +0,0 @@
-import { useEffect, useMemo, useCallback, useState } from "react";
-
-import useProjectIdFromURL from "@/src/hooks/useProjectIdFromURL";
-import { api } from "@/src/utils/api";
-import useLocalStorage from "@/src/components/useLocalStorage";
-import {
-  LLMAdapter,
-  supportedModels,
-  type UIModelParams,
-} from "@langfuse/shared";
-import { type ModelParamsContext } from "@/src/components/ModelParameters";
-
-export const useModelParams = () => {
-  const [modelParams, setModelParams] = useState<UIModelParams>({
-    ...getDefaultAdapterParams(LLMAdapter.OpenAI),
-    provider: { value: "", enabled: true },
-    model: { value: "", enabled: true },
-  });
-
-  // Set initial model params
-  const projectId = useProjectIdFromURL();
-  const availableLLMApiKeys = api.llmApiKey.all.useQuery(
-    {
-      projectId: projectId as string,
-    },
-    { enabled: Boolean(projectId) },
-  );
-
-  const [persistedModelName, setPersistedModelName] = useLocalStorage<
-    string | null
-  >("llmModelName", null);
-
-  const [persistedModelProvider, setPersistedModelProvider] = useLocalStorage<
-    string | null
-  >("llmModelProvider", null);
-
-  const availableProviders = useMemo(() => {
-    const adapter = availableLLMApiKeys.data?.data ?? [];
-
-    return adapter.map((key) => key.provider) ?? [];
-  }, [availableLLMApiKeys.data?.data]);
-
-  const selectedProviderApiKey = availableLLMApiKeys.data?.data.find(
-    (key) => key.provider === modelParams.provider.value,
-  );
-
-  const availableModels = useMemo(
-    () =>
-      !selectedProviderApiKey
-        ? []
-        : selectedProviderApiKey.withDefaultModels
-          ? [
-              ...selectedProviderApiKey.customModels,
-              ...supportedModels[selectedProviderApiKey.adapter],
-            ]
-          : selectedProviderApiKey.customModels,
-    [selectedProviderApiKey],
-  );
-
-  const updateModelParamValue = useCallback<
-    ModelParamsContext["updateModelParamValue"]
-  >(
-    (key, value) => {
-      setModelParams((prev) => ({
-        ...prev,
-        [key]: { ...prev[key], value },
-      }));
-
-      if (value && key === "model") {
-        setPersistedModelName(String(value));
-      }
-      if (value && key === "provider") {
-        setPersistedModelProvider(String(value));
-      }
-    },
-    [setPersistedModelName, setPersistedModelProvider, setModelParams],
-  );
-
-  const setModelParamEnabled: ModelParamsContext["setModelParamEnabled"] = (
-    key,
-    enabled,
-  ) => {
-    setModelParams((prev) => ({
-      ...prev,
-      [key]: { ...prev[key], enabled },
-    }));
-  };
-
-  // Set default provider and model
-  useEffect(() => {
-    if (availableProviders.length > 0 && !modelParams.provider.value) {
-      if (
-        persistedModelProvider &&
-        availableProviders.includes(persistedModelProvider)
-      ) {
-        updateModelParamValue("provider", persistedModelProvider);
-      } else {
-        updateModelParamValue("provider", availableProviders[0]);
-      }
-    }
-  }, [
-    availableProviders,
-    modelParams.provider.value,
-    updateModelParamValue,
-    persistedModelProvider,
-  ]);
-
-  useEffect(() => {
-    if (
-      (availableModels.length > 0 && !modelParams.model.value) ||
-      !availableModels.includes(modelParams.model.value)
-    ) {
-      if (persistedModelName && availableModels.includes(persistedModelName)) {
-        updateModelParamValue("model", persistedModelName);
-      } else {
-        updateModelParamValue("model", availableModels[0]);
-      }
-    }
-  }, [
-    availableModels,
-    modelParams.model.value,
-    updateModelParamValue,
-    persistedModelName,
-  ]);
-
-  // Update adapter, max temperature, temperature, max_tokens, top_p when provider changes
-  useEffect(() => {
-    if (selectedProviderApiKey?.adapter) {
-      setModelParams((prev) => ({
-        ...prev,
-        adapter: {
-          value: selectedProviderApiKey.adapter,
-          enabled: true,
-        },
-        maxTemperature: {
-          value: getDefaultAdapterParams(selectedProviderApiKey.adapter)
-            .maxTemperature.value,
-          enabled: getDefaultAdapterParams(selectedProviderApiKey.adapter)
-            .maxTemperature.enabled,
-        },
-        temperature: {
-          value: Math.min(
-            prev.temperature.value,
-            getDefaultAdapterParams(selectedProviderApiKey.adapter)
-              .maxTemperature.value,
-          ),
-          enabled: getDefaultAdapterParams(selectedProviderApiKey.adapter)
-            .temperature.enabled,
-        },
-        max_tokens: {
-          value: getDefaultAdapterParams(selectedProviderApiKey.adapter)
-            .max_tokens.value,
-          enabled: getDefaultAdapterParams(selectedProviderApiKey.adapter)
-            .max_tokens.enabled,
-        },
-        top_p: {
-          value: getDefaultAdapterParams(selectedProviderApiKey.adapter).top_p
-            .value,
-          enabled: getDefaultAdapterParams(selectedProviderApiKey.adapter).top_p
-            .enabled,
-        },
-      }));
-    }
-  }, [selectedProviderApiKey?.adapter]);
-
-  return {
-    modelParams,
-    setModelParams,
-    availableProviders,
-    availableModels,
-    updateModelParamValue,
-    setModelParamEnabled,
-  };
-};
-
-function getDefaultAdapterParams(
-  adapter: LLMAdapter,
-): Omit<UIModelParams, "provider" | "model"> {
-  switch (adapter) {
-    // Docs: https://platform.openai.com/docs/api-reference/chat/create
-    case LLMAdapter.OpenAI:
-      return {
-        adapter: {
-          value: adapter,
-          enabled: true,
-        },
-        temperature: { value: 0, enabled: false },
-        maxTemperature: { value: 2, enabled: false },
-        max_tokens: { value: 4096, enabled: false },
-        top_p: { value: 1, enabled: false },
-      };
-
-    case LLMAdapter.Azure:
-      return {
-        adapter: {
-          value: adapter,
-          enabled: true,
-        },
-        temperature: { value: 0, enabled: false },
-        maxTemperature: { value: 2, enabled: false },
-        max_tokens: { value: 4096, enabled: false },
-        top_p: { value: 1, enabled: false },
-      };
-
-    // Docs: https://docs.anthropic.com/claude/reference/messages_post
-    case LLMAdapter.Anthropic:
-      return {
-        adapter: {
-          value: adapter,
-          enabled: true,
-        },
-        temperature: { value: 0, enabled: false },
-        maxTemperature: { value: 1, enabled: false },
-        max_tokens: { value: 4096, enabled: false },
-        top_p: { value: 1, enabled: false },
-      };
-
-    case LLMAdapter.Bedrock:
-      return {
-        adapter: {
-          value: adapter,
-          enabled: true,
-        },
-        temperature: { value: 0, enabled: false },
-        maxTemperature: { value: 1, enabled: false },
-        max_tokens: { value: 4096, enabled: false },
-        top_p: { value: 1, enabled: false },
-      };
-
-    case LLMAdapter.VertexAI:
-      return {
-        adapter: {
-          value: adapter,
-          enabled: true,
-        },
-        temperature: { value: 1, enabled: false },
-        maxTemperature: { value: 2, enabled: false },
-        max_tokens: { value: 4096, enabled: false },
-        top_p: { value: 1, enabled: false },
-      };
-
-    case LLMAdapter.GoogleAIStudio:
-      return {
-        adapter: {
-          value: adapter,
-          enabled: true,
-        },
-        temperature: { value: 1, enabled: false },
-        maxTemperature: { value: 2, enabled: false },
-        max_tokens: { value: 4096, enabled: false },
-        top_p: { value: 1, enabled: false },
-      };
-    case LLMAdapter.Atla:
-      return {
-        adapter: {
-          value: adapter,
-          enabled: true,
-        },
-        temperature: { value: 0, enabled: false },
-        maxTemperature: { value: 1, enabled: false },
-        max_tokens: { value: 4096, enabled: false },
-        top_p: { value: 1, enabled: false },
-      };
-  }
-}
diff --git a/web/src/ee/features/playground/page/hooks/usePlaygroundCache.ts b/web/src/ee/features/playground/page/hooks/usePlaygroundCache.ts
deleted file mode 100644
index 109bd6a..0000000
--- a/web/src/ee/features/playground/page/hooks/usePlaygroundCache.ts
+++ /dev/null
@@ -1,30 +0,0 @@
-import { useEffect, useState } from "react";
-
-import { type PlaygroundCache } from "../types";
-import { useHasEntitlement } from "@/src/features/entitlements/hooks";
-
-const playgroundCacheKey = "playgroundCache";
-
-export default function usePlaygroundCache() {
-  const [cache, setCache] = useState<PlaygroundCache>(null);
-  const available = useHasEntitlement("playground");
-  const setPlaygroundCache = (cache: PlaygroundCache) => {
-    sessionStorage.setItem(playgroundCacheKey, JSON.stringify(cache));
-  };
-
-  useEffect(() => {
-    const savedCache = sessionStorage.getItem(playgroundCacheKey);
-    if (savedCache) {
-      try {
-        setCache(JSON.parse(savedCache));
-      } catch (e) {
-        console.error("Failed to parse playground cache", e);
-      }
-    }
-  }, []);
-
-  return {
-    playgroundCache: available ? cache : null,
-    setPlaygroundCache: available ? setPlaygroundCache : () => {},
-  };
-}
diff --git a/web/src/ee/features/playground/page/index.tsx b/web/src/ee/features/playground/page/index.tsx
deleted file mode 100644
index 906fea9..0000000
--- a/web/src/ee/features/playground/page/index.tsx
+++ /dev/null
@@ -1,35 +0,0 @@
-import { ResetPlaygroundButton } from "@/src/ee/features/playground/page/components/ResetPlaygroundButton";
-import { SaveToPromptButton } from "@/src/ee/features/playground/page/components/SaveToPromptButton";
-import Page from "@/src/components/layouts/page";
-import { PlaygroundProvider } from "@/src/ee/features/playground/page/context";
-import Playground from "@/src/ee/features/playground/page/playground";
-import { useHasEntitlement } from "@/src/features/entitlements/hooks";
-
-export default function PlaygroundPage() {
-  const available = useHasEntitlement("playground");
-  if (!available) return null;
-  return (
-    <PlaygroundProvider>
-      <Page
-        withPadding
-        headerProps={{
-          title: "Playground",
-          help: {
-            description: "A sandbox to test and iterate your prompts",
-            href: "https://langfuse.com/docs/playground",
-          },
-          actionButtonsRight: (
-            <>
-              <SaveToPromptButton />
-              <ResetPlaygroundButton />
-            </>
-          ),
-        }}
-      >
-        <div className="flex-1 overflow-auto">
-          <Playground />
-        </div>
-      </Page>
-    </PlaygroundProvider>
-  );
-}
diff --git a/web/src/ee/features/playground/page/playground.tsx b/web/src/ee/features/playground/page/playground.tsx
deleted file mode 100644
index 6f62afe..0000000
--- a/web/src/ee/features/playground/page/playground.tsx
+++ /dev/null
@@ -1,34 +0,0 @@
-import { ModelParameters } from "@/src/components/ModelParameters";
-import { usePlaygroundContext } from "./context";
-import { Variables } from "./components/Variables";
-import { Messages } from "./components/Messages";
-import { PlaygroundTools } from "./components/PlaygroundTools";
-import { StructuredOutputSchemaSection } from "./components/StructuredOutputSchemaSection";
-
-export default function Playground() {
-  const playgroundContext = usePlaygroundContext();
-
-  return (
-    <div className="flex h-full flex-row space-x-8">
-      <div className="h-full basis-3/4 overflow-auto">
-        <Messages {...playgroundContext} />
-      </div>
-      <div className="max-h-full min-h-0 basis-1/4 pr-2">
-        <div className="flex h-full flex-col gap-4 overflow-auto">
-          <div className="mb-4 flex-shrink-0 overflow-y-auto">
-            <ModelParameters {...playgroundContext} />
-          </div>
-          <div className="mb-4 max-h-[25vh] flex-shrink-0 overflow-y-auto">
-            <PlaygroundTools />
-          </div>
-          <div className="mb-4 flex-shrink-0">
-            <StructuredOutputSchemaSection />
-          </div>
-          <div className="flex-grow overflow-y-auto">
-            <Variables />
-          </div>
-        </div>
-      </div>
-    </div>
-  );
-}
diff --git a/web/src/ee/features/playground/page/types.ts b/web/src/ee/features/playground/page/types.ts
deleted file mode 100644
index 23671a2..0000000
--- a/web/src/ee/features/playground/page/types.ts
+++ /dev/null
@@ -1,32 +0,0 @@
-import {
-  type PromptVariable,
-  type ChatMessage,
-  type UIModelParams,
-  type LlmSchema,
-  type LLMToolDefinition,
-  type LlmTool,
-  type LLMJSONSchema,
-} from "@langfuse/shared";
-
-export type PlaygroundTool = LLMToolDefinition & {
-  id: string;
-  existingLlmTool?: LlmTool;
-};
-
-export type PlaygroundSchema = {
-  id: string;
-  name: string;
-  description: string;
-  schema: LLMJSONSchema;
-  existingLlmSchema?: LlmSchema;
-};
-
-export type PlaygroundCache = {
-  messages: ChatMessage[];
-  modelParams?: Partial<UIModelParams> &
-    Pick<UIModelParams, "provider" | "model">;
-  output?: string | null;
-  promptVariables?: PromptVariable[];
-  tools?: PlaygroundTool[];
-  structuredOutputSchema?: PlaygroundSchema | null;
-} | null;
diff --git a/web/src/ee/features/playground/server/analytics/posthogCallback.ts b/web/src/ee/features/playground/server/analytics/posthogCallback.ts
deleted file mode 100644
index 30e24e8..0000000
--- a/web/src/ee/features/playground/server/analytics/posthogCallback.ts
+++ /dev/null
@@ -1,71 +0,0 @@
-import type { ValidatedChatCompletionBody } from "@/src/ee/features/playground/server/validateChatCompletionBody";
-import { ServerPosthog } from "@/src/features/posthog-analytics/ServerPosthog";
-import type { LLMResult } from "@langchain/core/outputs";
-import { BaseCallbackHandler } from "@langchain/core/callbacks/base";
-
-import type { ChatMessage, ModelParams } from "@langfuse/shared";
-
-export class PosthogCallbackHandler extends BaseCallbackHandler {
-  public name = "PosthogCallbackHandler";
-  private messages: ChatMessage[];
-  private modelParams: ModelParams;
-  private posthog: ServerPosthog;
-
-  constructor(
-    public eventPrefix: string,
-    public body: ValidatedChatCompletionBody,
-    private userId: string,
-  ) {
-    super();
-    this.posthog = new ServerPosthog();
-    this.messages = body.messages;
-    this.modelParams = body.modelParams;
-  }
-
-  async handleLLMEnd(output: LLMResult) {
-    const generation = output.generations[0][0];
-
-    if (generation) {
-      const outputString = output.generations[0][0].text;
-      const properties = this.getEventProperties(outputString);
-
-      this.captureEvent(properties);
-      await this.posthog.flush();
-    }
-  }
-
-  private getInputLength() {
-    return this.messages.reduce(
-      (acc, message) => acc + message.content.length,
-      0,
-    );
-  }
-
-  private getEventProperties(output: string): ChatCompletionEventProperties {
-    return {
-      outputLength: output.length,
-      inputLength: this.getInputLength(),
-      modelProvider: this.modelParams.provider,
-      modelName: this.modelParams.model,
-    };
-  }
-
-  private captureEvent(properties: ChatCompletionEventProperties) {
-    this.posthog.capture({
-      event: this.eventPrefix + "_chat_completion",
-      distinctId: this.userId,
-      properties,
-    });
-  }
-
-  public async flushAsync() {
-    await this.posthog.flush();
-  }
-}
-
-type ChatCompletionEventProperties = {
-  outputLength: number;
-  inputLength: number;
-  modelProvider: string;
-  modelName: string;
-};
diff --git a/web/src/ee/features/playground/server/authorizeRequest.ts b/web/src/ee/features/playground/server/authorizeRequest.ts
deleted file mode 100644
index 2e65539..0000000
--- a/web/src/ee/features/playground/server/authorizeRequest.ts
+++ /dev/null
@@ -1,33 +0,0 @@
-import { getServerSession } from "next-auth";
-
-import { getAuthOptions } from "@/src/server/auth";
-import { isProjectMemberOrAdmin } from "@/src/server/utils/checkProjectMembershipOrAdmin";
-import { ApiError, ForbiddenError, UnauthorizedError } from "@langfuse/shared";
-import { hasEntitlement } from "@/src/features/entitlements/server/hasEntitlement";
-
-export type AuthorizeRequestResult = {
-  userId: string;
-};
-
-export const authorizeRequestOrThrow = async (
-  projectId: string,
-): Promise<AuthorizeRequestResult> => {
-  const authOptions = await getAuthOptions();
-  const session = await getServerSession(authOptions);
-  if (!session?.user) throw new UnauthorizedError("Unauthenticated");
-
-  const playgroundEntitlement = hasEntitlement({
-    entitlement: "playground",
-    projectId,
-    sessionUser: session.user,
-  });
-  if (!playgroundEntitlement)
-    throw new ApiError(
-      "Your organization does not have access to the playground feature.",
-    );
-
-  if (!isProjectMemberOrAdmin(session.user, projectId))
-    throw new ForbiddenError("User is not a member of this project");
-
-  return { userId: session.user.id };
-};
diff --git a/web/src/ee/features/playground/server/chatCompletionHandler.ts b/web/src/ee/features/playground/server/chatCompletionHandler.ts
deleted file mode 100644
index 0b34cd0..0000000
--- a/web/src/ee/features/playground/server/chatCompletionHandler.ts
+++ /dev/null
@@ -1,104 +0,0 @@
-import { StreamingTextResponse } from "ai";
-import { NextResponse, type NextRequest } from "next/server";
-
-import {
-  BaseError,
-  InternalServerError,
-  InvalidRequestError,
-} from "@langfuse/shared";
-
-import { PosthogCallbackHandler } from "./analytics/posthogCallback";
-import { authorizeRequestOrThrow } from "./authorizeRequest";
-import { validateChatCompletionBody } from "./validateChatCompletionBody";
-
-import { prisma } from "@langfuse/shared/src/db";
-import { decrypt } from "@langfuse/shared/encryption";
-import {
-  LLMApiKeySchema,
-  logger,
-  fetchLLMCompletion,
-  decryptAndParseExtraHeaders,
-} from "@langfuse/shared/src/server";
-
-export default async function chatCompletionHandler(req: NextRequest) {
-  try {
-    const body = validateChatCompletionBody(await req.json());
-    const { userId } = await authorizeRequestOrThrow(body.projectId);
-
-    const { messages, modelParams, tools, structuredOutputSchema } = body;
-
-    const LLMApiKey = await prisma.llmApiKeys.findFirst({
-      where: {
-        projectId: body.projectId,
-        provider: modelParams.provider,
-      },
-    });
-
-    if (!LLMApiKey)
-      throw new InvalidRequestError(
-        `No ${modelParams.provider} API key found in project. Please add one in the project settings.`,
-      );
-
-    const parsedKey = LLMApiKeySchema.safeParse(LLMApiKey);
-    if (!parsedKey.success) {
-      throw new InternalServerError(
-        `Could not parse API key for provider ${body.modelParams.provider}: ${parsedKey.error.message}`,
-      );
-    }
-
-    const fetchLLMCompletionParams = {
-      messages,
-      modelParams,
-      structuredOutputSchema,
-      callbacks: [new PosthogCallbackHandler("playground", body, userId)],
-      apiKey: decrypt(parsedKey.data.secretKey),
-      extraHeaders: decryptAndParseExtraHeaders(parsedKey.data.extraHeaders),
-      baseURL: parsedKey.data.baseURL || undefined,
-      config: parsedKey.data.config,
-    };
-
-    if ((tools && tools.length > 0) || structuredOutputSchema) {
-      const { completion } = await fetchLLMCompletion({
-        ...fetchLLMCompletionParams,
-        streaming: false,
-        tools: tools ?? [],
-        structuredOutputSchema,
-      });
-
-      return NextResponse.json(completion);
-    }
-
-    const { completion } = await fetchLLMCompletion({
-      ...fetchLLMCompletionParams,
-      streaming: true,
-    });
-
-    return new StreamingTextResponse(completion);
-  } catch (err) {
-    logger.error("Failed to handle chat completion", err);
-
-    if (err instanceof BaseError) {
-      return NextResponse.json(
-        {
-          error: err.name,
-          message: err.message,
-        },
-        { status: err.httpCode },
-      );
-    }
-
-    if (err instanceof Error) {
-      return NextResponse.json(
-        {
-          message: err.message,
-          error: err,
-        },
-        {
-          status: (err as any)?.response?.status ?? (err as any)?.status ?? 500,
-        },
-      );
-    }
-
-    throw err;
-  }
-}
diff --git a/web/src/ee/features/playground/server/validateChatCompletionBody.ts b/web/src/ee/features/playground/server/validateChatCompletionBody.ts
deleted file mode 100644
index 7813aa7..0000000
--- a/web/src/ee/features/playground/server/validateChatCompletionBody.ts
+++ /dev/null
@@ -1,32 +0,0 @@
-import { z } from "zod";
-import {
-  LLMAdapter,
-  LLMJSONSchema,
-  LLMToolDefinitionSchema,
-  ChatMessageSchema,
-} from "@langfuse/shared";
-
-const ModelParamsSchema = z.object({
-  provider: z.string(),
-  adapter: z.nativeEnum(LLMAdapter),
-  model: z.string(),
-  temperature: z.number().optional(),
-  max_tokens: z.number().optional(),
-  top_p: z.number().optional(),
-});
-
-export const ChatCompletionBodySchema = z.object({
-  projectId: z.string(),
-  messages: z.array(ChatMessageSchema),
-  modelParams: ModelParamsSchema,
-  tools: z.array(LLMToolDefinitionSchema).optional(),
-  structuredOutputSchema: LLMJSONSchema.optional(),
-});
-
-export const validateChatCompletionBody = (input: unknown) => {
-  return ChatCompletionBodySchema.parse(input);
-};
-
-export type ValidatedChatCompletionBody = z.infer<
-  typeof ChatCompletionBodySchema
->;
diff --git a/web/src/ee/features/sso-settings/components/SSOSettings.tsx b/web/src/ee/features/sso-settings/components/SSOSettings.tsx
deleted file mode 100644
index 314fc40..0000000
--- a/web/src/ee/features/sso-settings/components/SSOSettings.tsx
+++ /dev/null
@@ -1,56 +0,0 @@
-import { Alert, AlertDescription, AlertTitle } from "@/src/components/ui/alert";
-import { AlertCircle } from "lucide-react";
-import { useHasEntitlement } from "@/src/features/entitlements/hooks";
-import Header from "@/src/components/layouts/header";
-
-export const SSOSettings = () => {
-  const hasEntitlement = useHasEntitlement("cloud-multi-tenant-sso");
-
-  const commonContent = (
-    <>
-      <Header title="SSO Configuration" />
-      <p className="mb-4 text-sm text-muted-foreground">
-        Configure Single Sign-On (SSO) for your organization. SSO allows your
-        team to use your existing identity provider for authentication, e.g.
-        Okta, AzureAD/EntraID. Alternatively, you can enforce the use of a
-        public provider such as Google, GitHub and Microsoft.
-      </p>
-    </>
-  );
-
-  if (!hasEntitlement) {
-    return (
-      <div>
-        {commonContent}
-        <Alert>
-          <AlertCircle className="h-4 w-4" />
-          <AlertTitle>Not available</AlertTitle>
-          <AlertDescription>
-            Enterprise SSO and SSO Enforcement are not available on your plan.
-            Please upgrade to access this feature.
-          </AlertDescription>
-        </Alert>
-      </div>
-    );
-  }
-
-  return (
-    <div>
-      {commonContent}
-      <Alert>
-        <AlertCircle className="h-4 w-4" />
-        <AlertTitle>Contact Langfuse Support</AlertTitle>
-        <AlertDescription>
-          To set up or change your SSO configuration, please reach out to{" "}
-          <a
-            href="mailto:support@langfuse.com"
-            className="font-medium underline underline-offset-4"
-          >
-            support@langfuse.com
-          </a>
-          .
-        </AlertDescription>
-      </Alert>
-    </div>
-  );
-};
diff --git a/web/src/ee/features/ui-customization/uiCustomizationRouter.ts b/web/src/ee/features/ui-customization/uiCustomizationRouter.ts
deleted file mode 100644
index 75ebd32..0000000
--- a/web/src/ee/features/ui-customization/uiCustomizationRouter.ts
+++ /dev/null
@@ -1,26 +0,0 @@
-import { env } from "@/src/env.mjs";
-import { hasEntitlementBasedOnPlan } from "@/src/features/entitlements/server/hasEntitlement";
-import { createTRPCRouter, protectedProcedure } from "@/src/server/api/trpc";
-
-export const uiCustomizationRouter = createTRPCRouter({
-  get: protectedProcedure.query(({ ctx }) => {
-    const hasEntitlement = hasEntitlementBasedOnPlan({
-      plan: ctx.session.environment.selfHostedInstancePlan,
-      entitlement: "self-host-ui-customization",
-    });
-    if (!hasEntitlement) return null;
-
-    return {
-      hostname: env.LANGFUSE_UI_API_HOST,
-      documentationHref: env.LANGFUSE_UI_DOCUMENTATION_HREF,
-      supportHref: env.LANGFUSE_UI_SUPPORT_HREF,
-      feedbackHref: env.LANGFUSE_UI_FEEDBACK_HREF,
-      logoLightModeHref: env.LANGFUSE_UI_LOGO_LIGHT_MODE_HREF,
-      logoDarkModeHref: env.LANGFUSE_UI_LOGO_DARK_MODE_HREF,
-      defaultModelAdapter: env.LANGFUSE_UI_DEFAULT_MODEL_ADAPTER,
-      defaultBaseUrlOpenAI: env.LANGFUSE_UI_DEFAULT_BASE_URL_OPENAI,
-      defaultBaseUrlAnthropic: env.LANGFUSE_UI_DEFAULT_BASE_URL_ANTHROPIC,
-      defaultBaseUrlAzure: env.LANGFUSE_UI_DEFAULT_BASE_URL_AZURE,
-    };
-  }),
-});
diff --git a/web/src/ee/features/ui-customization/useUiCustomization.ts b/web/src/ee/features/ui-customization/useUiCustomization.ts
deleted file mode 100644
index 72ca7c8..0000000
--- a/web/src/ee/features/ui-customization/useUiCustomization.ts
+++ /dev/null
@@ -1,19 +0,0 @@
-import { useHasEntitlement } from "@/src/features/entitlements/hooks";
-import { api } from "@/src/utils/api";
-
-export const useUiCustomization = () => {
-  const hasEntitlement = useHasEntitlement("self-host-ui-customization");
-  const customization = api.uiCustomization.get.useQuery(undefined, {
-    enabled: hasEntitlement,
-    refetchOnMount: false,
-    refetchOnWindowFocus: false,
-    refetchOnReconnect: false,
-  });
-
-  if (!hasEntitlement) return null;
-  return customization.data ?? null;
-};
-
-export type UiCustomizationOption = keyof NonNullable<
-  ReturnType<typeof useUiCustomization>
->;
diff --git a/web/src/ee/utils/getFinalModelParams.tsx b/web/src/ee/utils/getFinalModelParams.tsx
deleted file mode 100644
index a7f5c23..0000000
--- a/web/src/ee/utils/getFinalModelParams.tsx
+++ /dev/null
@@ -1,10 +0,0 @@
-import { type ModelParams, type UIModelParams } from "@langfuse/shared";
-
-export function getFinalModelParams(modelParams: UIModelParams): ModelParams {
-  return Object.entries(modelParams)
-    .filter(([key, value]) => value.enabled && key !== "maxTemperature")
-    .reduce(
-      (params, [key, value]) => ({ ...params, [key]: value.value }),
-      {} as ModelParams,
-    );
-}
diff --git a/web/src/features/auth-credentials/server/signupApiHandler.ts b/web/src/features/auth-credentials/server/signupApiHandler.ts
index 8d43bf5..b363520 100644
--- a/web/src/features/auth-credentials/server/signupApiHandler.ts
+++ b/web/src/features/auth-credentials/server/signupApiHandler.ts
@@ -1,7 +1,7 @@
 import { env } from "@/src/env.mjs";
 import { createUserEmailPassword } from "@/src/features/auth-credentials/lib/credentialsServerUtils";
 import { signupSchema } from "@/src/features/auth/lib/signupSchema";
-import { getSsoAuthProviderIdForDomain } from "@/src/ee/features/multi-tenant-sso/utils";
+// import { getSsoAuthProviderIdForDomain } from "@/src/ee/features/multi-tenant-sso/utils";
 import type { NextApiRequest, NextApiResponse } from "next";
 import { logger } from "@langfuse/shared/src/server";
 
@@ -60,13 +60,13 @@ export async function signupApiHandler(
   }
 
   // EE: check if custom SSO configuration is enabled for this domain
-  const multiTenantSsoProvider = await getSsoAuthProviderIdForDomain(domain);
-  if (multiTenantSsoProvider) {
-    res.status(422).json({
-      message: "You must sign in via SSO for this domain.",
-    });
-    return;
-  }
+  // const multiTenantSsoProvider = await getSsoAuthProviderIdForDomain(domain);
+  // if (multiTenantSsoProvider) {
+  //   res.status(422).json({
+  //     message: "You must sign in via SSO for this domain.",
+  //   });
+  //   return;
+  // }
 
   // create the user
   let userId: string;
diff --git a/web/src/features/entitlements/server/getPlan.ts b/web/src/features/entitlements/server/getPlan.ts
index 164bd15..1da27b6 100644
--- a/web/src/features/entitlements/server/getPlan.ts
+++ b/web/src/features/entitlements/server/getPlan.ts
@@ -1,4 +1,4 @@
-import { mapStripeProductIdToPlan } from "@/src/ee/features/billing/utils/stripeProducts";
+// import { mapStripeProductIdToPlan } from "@/src/ee/features/billing/utils/stripeProducts";
 import { env } from "@/src/env.mjs";
 import { type Plan } from "@langfuse/shared";
 import { type CloudConfigSchema } from "@langfuse/shared";
@@ -34,14 +34,14 @@ export function getOrganizationPlanServerSide(
         }
       }
       // stripe plan via product id
-      if (cloudConfig.stripe?.activeProductId) {
-        const stripePlan = mapStripeProductIdToPlan(
-          cloudConfig.stripe.activeProductId,
-        );
-        if (stripePlan) {
-          return stripePlan;
-        }
-      }
+      // if (cloudConfig.stripe?.activeProductId) {
+      //   const stripePlan = mapStripeProductIdToPlan(
+      //     cloudConfig.stripe.activeProductId,
+      //   );
+      //   if (stripePlan) {
+      //     return stripePlan;
+      //   }
+      // }
     }
     return "cloud:hobby";
   }
diff --git a/web/src/features/projects/components/HostNameProject.tsx b/web/src/features/projects/components/HostNameProject.tsx
index 927399c..26a5b61 100644
--- a/web/src/features/projects/components/HostNameProject.tsx
+++ b/web/src/features/projects/components/HostNameProject.tsx
@@ -1,11 +1,11 @@
 import { Card } from "@/src/components/ui/card";
 import { CodeView } from "@/src/components/ui/CodeJsonViewer";
 import Header from "@/src/components/layouts/header";
-import { useUiCustomization } from "@/src/ee/features/ui-customization/useUiCustomization";
+// import { useUiCustomization } from "@/src/ee/features/ui-customization/useUiCustomization";
 import { env } from "@/src/env.mjs";
 
 export function HostNameProject() {
-  const uiCustomization = useUiCustomization();
+  // const uiCustomization = useUiCustomization();
   return (
     <div>
       <Header title="Host Name" />
@@ -15,7 +15,8 @@ export function HostNameProject() {
             When connecting to Langfuse, use this hostname / baseurl.
           </div>
           <CodeView
-            content={`${uiCustomization?.hostname ?? window.origin}${env.NEXT_PUBLIC_BASE_PATH ?? ""}`}
+            // content={`${uiCustomization?.hostname ?? window.origin}${env.NEXT_PUBLIC_BASE_PATH ?? ""}`}
+            content={`${window.origin}${env.NEXT_PUBLIC_BASE_PATH ?? ""}`}
           />
         </div>
       </Card>
diff --git a/web/src/features/prompts/components/NewPromptForm/index.tsx b/web/src/features/prompts/components/NewPromptForm/index.tsx
index dbc1530..81ca2e1 100644
--- a/web/src/features/prompts/components/NewPromptForm/index.tsx
+++ b/web/src/features/prompts/components/NewPromptForm/index.tsx
@@ -48,7 +48,7 @@ import { CodeMirrorEditor } from "@/src/components/editor/CodeMirrorEditor";
 import { PromptLinkingEditor } from "@/src/components/editor/PromptLinkingEditor";
 import { PRODUCTION_LABEL } from "@/src/features/prompts/constants";
 import { usePostHogClientCapture } from "@/src/features/posthog-analytics/usePostHogClientCapture";
-import usePlaygroundCache from "@/src/ee/features/playground/page/hooks/usePlaygroundCache";
+// import usePlaygroundCache from "@/src/ee/features/playground/page/hooks/usePlaygroundCache";
 import { useQueryParam } from "use-query-params";
 import { usePromptNameValidation } from "@/src/features/prompts/hooks/usePromptNameValidation";
 
@@ -62,7 +62,7 @@ export const NewPromptForm: React.FC<NewPromptFormProps> = (props) => {
   const projectId = useProjectIdFromURL();
   const [shouldLoadPlaygroundCache] = useQueryParam("loadPlaygroundCache");
   const [formError, setFormError] = useState<string | null>(null);
-  const { playgroundCache } = usePlaygroundCache();
+  // const { playgroundCache } = usePlaygroundCache();
   const [initialMessages, setInitialMessages] = useState<unknown>([]);
 
   const utils = api.useUtils();
@@ -179,14 +179,15 @@ export const NewPromptForm: React.FC<NewPromptFormProps> = (props) => {
   }
 
   useEffect(() => {
-    if (shouldLoadPlaygroundCache && playgroundCache) {
-      form.setValue("type", PromptType.Chat);
+    // if (shouldLoadPlaygroundCache && playgroundCache) {
+    //   form.setValue("type", PromptType.Chat);
 
-      setInitialMessages(playgroundCache.messages);
-    } else if (initialPrompt?.type === PromptType.Chat) {
+    //   setInitialMessages(playgroundCache.messages);
+    // } else
+    if (initialPrompt?.type === PromptType.Chat) {
       setInitialMessages(initialPrompt.prompt);
     }
-  }, [playgroundCache, initialPrompt, form, shouldLoadPlaygroundCache]);
+  }, [initialPrompt, form, shouldLoadPlaygroundCache]);
 
   usePromptNameValidation({
     currentName,
diff --git a/web/src/features/prompts/components/prompt-detail.tsx b/web/src/features/prompts/components/prompt-detail.tsx
index ab74ace..1bfb3fd 100644
--- a/web/src/features/prompts/components/prompt-detail.tsx
+++ b/web/src/features/prompts/components/prompt-detail.tsx
@@ -23,7 +23,7 @@ import useProjectIdFromURL from "@/src/hooks/useProjectIdFromURL";
 import { api } from "@/src/utils/api";
 import { extractVariables } from "@langfuse/shared";
 import { PromptHistoryNode } from "./prompt-history";
-import { JumpToPlaygroundButton } from "@/src/ee/features/playground/page/components/JumpToPlaygroundButton";
+// import { JumpToPlaygroundButton } from "@/src/ee/features/playground/page/components/JumpToPlaygroundButton";
 import { ChatMlArraySchema } from "@/src/components/schemas/ChatMlSchema";
 import Generations from "@/src/components/table/use-cases/observations";
 import { FlaskConical, MoreVertical, Plus } from "lucide-react";
@@ -35,7 +35,7 @@ import {
   DialogContent,
   DialogTrigger,
 } from "@/src/components/ui/dialog";
-import { CreateExperimentsForm } from "@/src/ee/features/experiments/components/CreateExperimentsForm";
+// import { CreateExperimentsForm } from "@/src/ee/features/experiments/components/CreateExperimentsForm";
 import { useMemo, useState } from "react";
 import { useHasEntitlement } from "@/src/features/entitlements/hooks";
 import { showSuccessToast } from "@/src/features/notifications/showSuccessToast";
@@ -65,7 +65,7 @@ const getPythonCode = (
 # Initialize Langfuse client
 langfuse = Langfuse()
 
-# Get production prompt 
+# Get production prompt
 prompt = langfuse.get_prompt("${name}")
 
 # Get by label
@@ -85,7 +85,7 @@ const getJsCode = (
 // Initialize the Langfuse client
 const langfuse = new Langfuse();
 
-// Get production prompt 
+// Get production prompt
 const prompt = await langfuse.getPrompt("${name}");
 
 // Get by label
@@ -384,12 +384,12 @@ export const PromptDetail = () => {
                 <div className="min-h-1 flex-1" />
               </div>
               <div className="flex h-full flex-wrap content-start items-start justify-end gap-1 lg:flex-nowrap">
-                <JumpToPlaygroundButton
+                {/* <JumpToPlaygroundButton
                   source="prompt"
                   prompt={prompt}
                   analyticsEventName="prompt_detail:test_in_playground_button_click"
                   variant="outline"
-                />
+                /> */}
                 {hasAccess && hasEntitlement && (
                   <Dialog
                     open={isCreateExperimentDialogOpen}
@@ -408,7 +408,7 @@ export const PromptDetail = () => {
                       </Button>
                     </DialogTrigger>
                     <DialogContent className="max-h-[90vh] overflow-y-auto">
-                      <CreateExperimentsForm
+                      {/* <CreateExperimentsForm
                         key={`create-experiment-form-${prompt.id}`}
                         projectId={projectId as string}
                         setFormOpen={setIsCreateExperimentDialogOpen}
@@ -420,7 +420,7 @@ export const PromptDetail = () => {
                           version: prompt.version,
                         }}
                         handleExperimentSuccess={handleExperimentSuccess}
-                      />
+                      /> */}
                     </DialogContent>
                   </Dialog>
                 )}
diff --git a/web/src/features/public-api/components/CreateApiKeyButton.tsx b/web/src/features/public-api/components/CreateApiKeyButton.tsx
index b123e07..506bf69 100644
--- a/web/src/features/public-api/components/CreateApiKeyButton.tsx
+++ b/web/src/features/public-api/components/CreateApiKeyButton.tsx
@@ -12,7 +12,7 @@ import { CodeView } from "@/src/components/ui/CodeJsonViewer";
 import { useHasProjectAccess } from "@/src/features/rbac/utils/checkProjectAccess";
 import { QuickstartExamples } from "@/src/features/public-api/components/QuickstartExamples";
 import { usePostHogClientCapture } from "@/src/features/posthog-analytics/usePostHogClientCapture";
-import { useUiCustomization } from "@/src/ee/features/ui-customization/useUiCustomization";
+// import { useUiCustomization } from "@/src/ee/features/ui-customization/useUiCustomization";
 import { env } from "@/src/env.mjs";
 
 export function CreateApiKeyButton(props: { projectId: string }) {
@@ -92,7 +92,7 @@ export const ApiKeyRender = ({
 }: {
   generatedKeys?: { secretKey: string; publicKey: string };
 }) => {
-  const uiCustomization = useUiCustomization();
+  // const uiCustomization = useUiCustomization();
   return (
     <>
       <div className="mb-4">
@@ -110,7 +110,8 @@ export const ApiKeyRender = ({
       <div>
         <div className="text-md mb-2 font-semibold">Host</div>
         <CodeView
-          content={`${uiCustomization?.hostname ?? window.origin}${env.NEXT_PUBLIC_BASE_PATH ?? ""}`}
+          // content={`${uiCustomization?.hostname ?? window.origin}${env.NEXT_PUBLIC_BASE_PATH ?? ""}`}
+          content={`${window.origin}${env.NEXT_PUBLIC_BASE_PATH ?? ""}`}
         />
       </div>
     </>
diff --git a/web/src/features/public-api/components/CreateLLMApiKeyDialog.tsx b/web/src/features/public-api/components/CreateLLMApiKeyDialog.tsx
index c35a639..143bd44 100644
--- a/web/src/features/public-api/components/CreateLLMApiKeyDialog.tsx
+++ b/web/src/features/public-api/components/CreateLLMApiKeyDialog.tsx
@@ -11,7 +11,7 @@ import {
 } from "@/src/components/ui/dialog";
 import { useHasProjectAccess } from "@/src/features/rbac/utils/checkProjectAccess";
 import useProjectIdFromURL from "@/src/hooks/useProjectIdFromURL";
-import { useUiCustomization } from "@/src/ee/features/ui-customization/useUiCustomization";
+// import { useUiCustomization } from "@/src/ee/features/ui-customization/useUiCustomization";
 import { CreateLLMApiKeyForm } from "@/src/features/public-api/components/CreateLLMApiKeyForm";
 
 export function CreateLLMApiKeyDialog() {
@@ -21,7 +21,7 @@ export function CreateLLMApiKeyDialog() {
     projectId,
     scope: "llmApiKeys:create",
   });
-  const uiCustomization = useUiCustomization();
+  // const uiCustomization = useUiCustomization();
 
   if (!hasAccess) return null;
 
@@ -46,7 +46,7 @@ export function CreateLLMApiKeyDialog() {
           <CreateLLMApiKeyForm
             projectId={projectId}
             onSuccess={() => setOpen(false)}
-            customization={uiCustomization}
+            // customization={uiCustomization}
           />
         )}
       </DialogContent>
diff --git a/web/src/features/public-api/components/CreateLLMApiKeyForm.tsx b/web/src/features/public-api/components/CreateLLMApiKeyForm.tsx
index e1caf88..42717dd 100644
--- a/web/src/features/public-api/components/CreateLLMApiKeyForm.tsx
+++ b/web/src/features/public-api/components/CreateLLMApiKeyForm.tsx
@@ -29,7 +29,7 @@ import { Switch } from "@/src/components/ui/switch";
 import { api } from "@/src/utils/api";
 import { cn } from "@/src/utils/tailwind";
 import { usePostHogClientCapture } from "@/src/features/posthog-analytics/usePostHogClientCapture";
-import { type useUiCustomization } from "@/src/ee/features/ui-customization/useUiCustomization";
+// import { type useUiCustomization } from "@/src/ee/features/ui-customization/useUiCustomization";
 
 const formSchema = z
   .object({
@@ -74,7 +74,7 @@ export function CreateLLMApiKeyForm({
 }: {
   projectId?: string;
   onSuccess: () => void;
-  customization: ReturnType<typeof useUiCustomization>;
+  // customization: ReturnType<typeof useUiCustomization>;
 }) {
   const utils = api.useUtils();
   const capture = usePostHogClientCapture();
@@ -92,9 +92,11 @@ export function CreateLLMApiKeyForm({
 
   const mutTestLLMApiKey = api.llmApiKey.test.useMutation();
 
-  const defaultAdapter: LLMAdapter = customization?.defaultModelAdapter
-    ? LLMAdapter[customization.defaultModelAdapter]
-    : LLMAdapter.OpenAI;
+  const defaultAdapter: LLMAdapter =
+    // customization?.defaultModelAdapter
+    // ? LLMAdapter[customization.defaultModelAdapter]
+    // :
+    LLMAdapter.OpenAI;
 
   const getCustomizedBaseURL = (adapter: LLMAdapter) => {
     switch (adapter) {
diff --git a/web/src/features/public-api/components/QuickstartExamples.tsx b/web/src/features/public-api/components/QuickstartExamples.tsx
index f3a80f7..52fe65d 100644
--- a/web/src/features/public-api/components/QuickstartExamples.tsx
+++ b/web/src/features/public-api/components/QuickstartExamples.tsx
@@ -5,7 +5,7 @@ import {
   TabsContent,
   TabsTrigger,
 } from "@/src/components/ui/tabs";
-import { useUiCustomization } from "@/src/ee/features/ui-customization/useUiCustomization";
+// import { useUiCustomization } from "@/src/ee/features/ui-customization/useUiCustomization";
 import { env } from "@/src/env.mjs";
 import { usePostHogClientCapture } from "@/src/features/posthog-analytics/usePostHogClientCapture";
 import Link from "next/link";
@@ -14,7 +14,7 @@ export const QuickstartExamples = (p: {
   secretKey?: string;
   publicKey?: string;
 }) => {
-  const uiCustomization = useUiCustomization();
+  // const uiCustomization = useUiCustomization();
   const capture = usePostHogClientCapture();
   const tabs = [
     { value: "python", label: "Python" },
@@ -25,27 +25,27 @@ export const QuickstartExamples = (p: {
     { value: "llamaindex", label: "LlamaIndex" },
     { value: "other", label: "Other" },
   ];
-  const host = `${uiCustomization?.hostname ?? window.origin}${env.NEXT_PUBLIC_BASE_PATH ?? ""}`;
+  const host = `${/*uiCustomization?.hostname ??*/ window.origin}${env.NEXT_PUBLIC_BASE_PATH ?? ""}`;
 
   const secretKey = p.secretKey ?? "<secret key>";
   const publicKey = p.publicKey ?? "<public key>";
 
   // if custom docs link, do not show quickstart examples but refer to docs
-  if (uiCustomization?.documentationHref) {
-    return (
-      <p className="mb-2">
-        See your{" "}
-        <Link
-          href={uiCustomization.documentationHref}
-          target="_blank"
-          className="underline"
-        >
-          internal documentation
-        </Link>{" "}
-        for details on how to set up Langfuse in your organization.
-      </p>
-    );
-  }
+  // if (uiCustomization?.documentationHref) {
+  //   return (
+  //     <p className="mb-2">
+  //       See your{" "}
+  //       <Link
+  //         href={uiCustomization.documentationHref}
+  //         target="_blank"
+  //         className="underline"
+  //       >
+  //         internal documentation
+  //       </Link>{" "}
+  //       for details on how to set up Langfuse in your organization.
+  //     </p>
+  //   );
+  // }
 
   return (
     <div>
@@ -291,7 +291,7 @@ langfuse_handler = CallbackHandler(
 )
 
 # <Your Langchain code here>
- 
+
 # Add handler to run/invoke/call/chat
 chain.invoke({"input": "<user_input>"}, config={"callbacks": [langfuse_handler]})`;
 
@@ -300,17 +300,17 @@ const LANGCHAIN_JS_CODE = (p: {
   secretKey: string;
   host: string;
 }) => `import { CallbackHandler } from "langfuse-langchain";
- 
+
 // Initialize Langfuse callback handler
 const langfuseHandler = new CallbackHandler({
   publicKey: "${p.publicKey}",
   secretKey: "${p.secretKey}",
   baseUrl: "${p.host}"
 });
- 
+
 // Your Langchain implementation
 const chain = new LLMChain(...);
- 
+
 // Add handler as callback when running the Langchain agent
 await chain.invoke(
   { input: "<user_input>" },
@@ -324,7 +324,7 @@ const LLAMA_INDEX_CODE = (p: {
 }) => `from llama_index.core import Settings
 from llama_index.core.callbacks import CallbackManager
 from langfuse.llama_index import LlamaIndexCallbackHandler
- 
+
 langfuse_callback_handler = LlamaIndexCallbackHandler(
     public_key="${p.publicKey}",
     secret_key="${p.secretKey}",
diff --git a/web/src/features/telemetry/index.ts b/web/src/features/telemetry/index.ts
index 0cdb1f1..cc65d97 100644
--- a/web/src/features/telemetry/index.ts
+++ b/web/src/features/telemetry/index.ts
@@ -1,14 +1,14 @@
-import { VERSION } from "@/src/constants";
-import { ServerPosthog } from "@/src/features/posthog-analytics/ServerPosthog";
+// import { VERSION } from "@/src/constants";
+// import { ServerPosthog } from "@/src/features/posthog-analytics/ServerPosthog";
 import { Prisma, prisma } from "@langfuse/shared/src/db";
 import { v4 as uuidv4 } from "uuid";
 import {
-  getObservationCountsByProjectInCreationInterval,
-  getScoreCountsByProjectInCreationInterval,
-  getTraceCountsByProjectInCreationInterval,
+  // getObservationCountsByProjectInCreationInterval,
+  // getScoreCountsByProjectInCreationInterval,
+  // getTraceCountsByProjectInCreationInterval,
   logger,
 } from "@langfuse/shared/src/server";
-import { env } from "@/src/env.mjs";
+// import { env } from "@/src/env.mjs";
 
 // Interval between jobs in minutes
 const JOB_INTERVAL_MINUTES = Prisma.raw("720"); // 12 hours
@@ -17,43 +17,43 @@ const JOB_INTERVAL_MINUTES = Prisma.raw("720"); // 12 hours
 const JOB_TIMEOUT_MINUTES = Prisma.raw("10"); // 10 minutes
 
 export async function telemetry() {
-  try {
-    // Only run in prod
-    if (process.env.NODE_ENV !== "production") return;
-    // Do not run in Langfuse cloud, separate telemetry is used
-    if (env.NEXT_PUBLIC_LANGFUSE_CLOUD_REGION !== undefined) return;
-    // Check if telemetry is not disabled, except for EE
-    if (
-      env.TELEMETRY_ENABLED === "false" &&
-      env.LANGFUSE_EE_LICENSE_KEY === undefined
-    )
-      return;
-    // Do not run in CI
-    if (process.env.CI) return;
+  // try {
+  //   // Only run in prod
+  //   if (process.env.NODE_ENV !== "production") return;
+  //   // Do not run in Langfuse cloud, separate telemetry is used
+  //   if (env.NEXT_PUBLIC_LANGFUSE_CLOUD_REGION !== undefined) return;
+  //   // Check if telemetry is not disabled, except for EE
+  //   if (
+  //     env.TELEMETRY_ENABLED === "false" &&
+  //     env.LANGFUSE_EE_LICENSE_KEY === undefined
+  //   )
+  //     return;
+  //   // Do not run in CI
+  //   if (process.env.CI) return;
 
-    // Check via db cron_jobs table if it is time to run job
-    const job = await jobScheduler();
+  //   // Check via db cron_jobs table if it is time to run job
+  //   const job = await jobScheduler();
 
-    if (job.shouldRunJob) {
-      const { jobStartedAt, lastRun, clientId } = job;
+  //   if (job.shouldRunJob) {
+  //     const { jobStartedAt, lastRun, clientId } = job;
 
-      // Run telemetry job
-      await posthogTelemetry({
-        startTimeframe: lastRun,
-        endTimeframe: jobStartedAt,
-        clientId,
-      });
+  //     // Run telemetry job
+  //     await posthogTelemetry({
+  //       startTimeframe: lastRun,
+  //       endTimeframe: jobStartedAt,
+  //       clientId,
+  //     });
 
-      // Update cron_jobs table
-      await prisma.cronJobs.update({
-        where: { name: "telemetry" },
-        data: { lastRun: jobStartedAt, state: clientId, jobStartedAt: null },
-      });
-    }
-  } catch (error) {
-    // Catch all errors to be sure telemetry does not break the application
-    logger.error("Telemetry, unexpected error:", error);
-  }
+  //     // Update cron_jobs table
+  //     await prisma.cronJobs.update({
+  //       where: { name: "telemetry" },
+  //       data: { lastRun: jobStartedAt, state: clientId, jobStartedAt: null },
+  //     });
+  //   }
+  // } catch (error) {
+  //   // Catch all errors to be sure telemetry does not break the application
+  //   logger.error("Telemetry, unexpected error:", error);
+  // }
 }
 
 /**
@@ -78,17 +78,17 @@ async function jobScheduler(): Promise<
   const checkNoLock = await prisma.$queryRaw<Array<{ status: boolean }>>`
     SELECT (
       EXISTS (
-        SELECT 1 
-        FROM cron_jobs 
-        WHERE name = 'telemetry' 
-        AND (last_run IS NULL OR last_run <= (NOW() - INTERVAL '${JOB_INTERVAL_MINUTES} minute')) 
+        SELECT 1
+        FROM cron_jobs
+        WHERE name = 'telemetry'
+        AND (last_run IS NULL OR last_run <= (NOW() - INTERVAL '${JOB_INTERVAL_MINUTES} minute'))
         AND (job_started_at IS NULL OR job_started_at <= (NOW() - INTERVAL '${JOB_TIMEOUT_MINUTES} minute'))
       )
       OR NOT EXISTS (
-        SELECT 1 
-        FROM cron_jobs 
+        SELECT 1
+        FROM cron_jobs
         WHERE name = 'telemetry'
-      ) 
+      )
     ) AS status;`;
   // Return if job should not run
   if (checkNoLock.length !== 1) {
@@ -109,16 +109,16 @@ async function jobScheduler(): Promise<
       }>
     >`INSERT INTO cron_jobs (name, last_run, job_started_at, state)
     VALUES ('telemetry', NULL, CURRENT_TIMESTAMP, NULL)
-    ON CONFLICT (name) 
-    DO UPDATE 
-    SET job_started_at = CASE 
-        WHEN (cron_jobs.last_run IS NULL OR cron_jobs.last_run <= (NOW() - INTERVAL '${JOB_INTERVAL_MINUTES} minutes')) 
+    ON CONFLICT (name)
+    DO UPDATE
+    SET job_started_at = CASE
+        WHEN (cron_jobs.last_run IS NULL OR cron_jobs.last_run <= (NOW() - INTERVAL '${JOB_INTERVAL_MINUTES} minutes'))
           AND (cron_jobs.job_started_at IS NULL OR cron_jobs.job_started_at <= (NOW() - INTERVAL '${JOB_TIMEOUT_MINUTES} minutes'))
-        THEN CURRENT_TIMESTAMP 
-        ELSE cron_jobs.job_started_at 
+        THEN CURRENT_TIMESTAMP
+        ELSE cron_jobs.job_started_at
         END
-    WHERE cron_jobs.name = 'telemetry' 
-      AND (cron_jobs.last_run IS NULL OR cron_jobs.last_run <= (NOW() - INTERVAL '${JOB_INTERVAL_MINUTES} minutes')) 
+    WHERE cron_jobs.name = 'telemetry'
+      AND (cron_jobs.last_run IS NULL OR cron_jobs.last_run <= (NOW() - INTERVAL '${JOB_INTERVAL_MINUTES} minutes'))
       AND (cron_jobs.job_started_at IS NULL OR cron_jobs.job_started_at <= (NOW() - INTERVAL '${JOB_TIMEOUT_MINUTES} minutes'))
     RETURNING *`,
   ]);
@@ -145,138 +145,138 @@ async function jobScheduler(): Promise<
   return { shouldRunJob: true, jobStartedAt, lastRun, clientId };
 }
 
-async function posthogTelemetry({
-  startTimeframe,
-  endTimeframe,
-  clientId,
-}: {
-  startTimeframe: Date | null;
-  endTimeframe: Date;
-  clientId: string;
-}) {
-  try {
-    const posthog = new ServerPosthog();
-    // Count projects
-    const totalProjects = await prisma.project.count({
-      where: {
-        deletedAt: null,
-      },
-    });
+// async function posthogTelemetry({
+//   startTimeframe,
+//   endTimeframe,
+//   clientId,
+// }: {
+//   startTimeframe: Date | null;
+//   endTimeframe: Date;
+//   clientId: string;
+// }) {
+//   try {
+//     const posthog = new ServerPosthog();
+//     // Count projects
+//     const totalProjects = await prisma.project.count({
+//       where: {
+//         deletedAt: null,
+//       },
+//     });
 
-    // Count traces
-    const countTracesClickhouse =
-      await getTraceCountsByProjectInCreationInterval({
-        start: startTimeframe ?? new Date(0),
-        end: endTimeframe,
-      });
-    const countTraces = countTracesClickhouse.reduce(
-      (acc, curr) => acc + curr.count,
-      0,
-    );
+//     // Count traces
+//     const countTracesClickhouse =
+//       await getTraceCountsByProjectInCreationInterval({
+//         start: startTimeframe ?? new Date(0),
+//         end: endTimeframe,
+//       });
+//     const countTraces = countTracesClickhouse.reduce(
+//       (acc, curr) => acc + curr.count,
+//       0,
+//     );
 
-    // Count scores
-    const countScoresClickhouse =
-      await getScoreCountsByProjectInCreationInterval({
-        start: startTimeframe ?? new Date(0),
-        end: endTimeframe,
-      });
-    const countScores = countScoresClickhouse.reduce(
-      (acc, curr) => acc + curr.count,
-      0,
-    );
+//     // Count scores
+//     const countScoresClickhouse =
+//       await getScoreCountsByProjectInCreationInterval({
+//         start: startTimeframe ?? new Date(0),
+//         end: endTimeframe,
+//       });
+//     const countScores = countScoresClickhouse.reduce(
+//       (acc, curr) => acc + curr.count,
+//       0,
+//     );
 
-    // Count observations
-    const countObservationsClickhouse =
-      await getObservationCountsByProjectInCreationInterval({
-        start: startTimeframe ?? new Date(0),
-        end: endTimeframe,
-      });
-    const countObservations = countObservationsClickhouse.reduce(
-      (acc, curr) => acc + curr.count,
-      0,
-    );
+//     // Count observations
+//     const countObservationsClickhouse =
+//       await getObservationCountsByProjectInCreationInterval({
+//         start: startTimeframe ?? new Date(0),
+//         end: endTimeframe,
+//       });
+//     const countObservations = countObservationsClickhouse.reduce(
+//       (acc, curr) => acc + curr.count,
+//       0,
+//     );
 
-    // Count datasets
-    const countDatasets = await prisma.dataset.count({
-      where: {
-        createdAt: {
-          gte: startTimeframe?.toISOString(),
-          lt: endTimeframe.toISOString(),
-        },
-      },
-    });
+//     // Count datasets
+//     const countDatasets = await prisma.dataset.count({
+//       where: {
+//         createdAt: {
+//           gte: startTimeframe?.toISOString(),
+//           lt: endTimeframe.toISOString(),
+//         },
+//       },
+//     });
 
-    // Count dataset items
-    const countDatasetItems = await prisma.datasetItem.count({
-      where: {
-        createdAt: {
-          gte: startTimeframe?.toISOString(),
-          lt: endTimeframe.toISOString(),
-        },
-      },
-    });
+//     // Count dataset items
+//     const countDatasetItems = await prisma.datasetItem.count({
+//       where: {
+//         createdAt: {
+//           gte: startTimeframe?.toISOString(),
+//           lt: endTimeframe.toISOString(),
+//         },
+//       },
+//     });
 
-    // Count dataset runs
-    const countDatasetRuns = await prisma.datasetRuns.count({
-      where: {
-        createdAt: {
-          gte: startTimeframe?.toISOString(),
-          lt: endTimeframe.toISOString(),
-        },
-      },
-    });
+//     // Count dataset runs
+//     const countDatasetRuns = await prisma.datasetRuns.count({
+//       where: {
+//         createdAt: {
+//           gte: startTimeframe?.toISOString(),
+//           lt: endTimeframe.toISOString(),
+//         },
+//       },
+//     });
 
-    // Count dataset run items
-    const countDatasetRunItems = await prisma.datasetRunItems.count({
-      where: {
-        createdAt: {
-          gte: startTimeframe?.toISOString(),
-          lt: endTimeframe.toISOString(),
-        },
-      },
-    });
+//     // Count dataset run items
+//     const countDatasetRunItems = await prisma.datasetRunItems.count({
+//       where: {
+//         createdAt: {
+//           gte: startTimeframe?.toISOString(),
+//           lt: endTimeframe.toISOString(),
+//         },
+//       },
+//     });
 
-    // Domains (no PII)
-    const domains = await prisma.$queryRaw<Array<{ domain: string }>>`
-      SELECT
-        substring(email FROM position('@' in email) + 1) as domain,
-        count(id)::int as "userCount"
-      FROM users
-      WHERE email ILIKE '%@%'
-      GROUP BY 1
-      ORDER BY count(id) desc
-      LIMIT 30
-    `;
+//     // Domains (no PII)
+//     const domains = await prisma.$queryRaw<Array<{ domain: string }>>`
+//       SELECT
+//         substring(email FROM position('@' in email) + 1) as domain,
+//         count(id)::int as "userCount"
+//       FROM users
+//       WHERE email ILIKE '%@%'
+//       GROUP BY 1
+//       ORDER BY count(id) desc
+//       LIMIT 30
+//     `;
 
-    posthog.capture({
-      distinctId: "docker:" + clientId,
-      event: "telemetry",
-      properties: {
-        langfuseVersion: VERSION,
-        userDomains: domains,
-        totalProjects: totalProjects,
-        traces: countTraces,
-        scores: countScores,
-        observations: countObservations,
-        datasets: countDatasets,
-        datasetItems: countDatasetItems,
-        datasetRuns: countDatasetRuns,
-        datasetRunItems: countDatasetRunItems,
-        startTimeframe: startTimeframe?.toISOString(),
-        endTimeframe: endTimeframe.toISOString(),
-        eeLicenseKey: env.LANGFUSE_EE_LICENSE_KEY,
-        langfuseCloudRegion: env.NEXT_PUBLIC_LANGFUSE_CLOUD_REGION,
-        $set: {
-          environment: process.env.NODE_ENV,
-          userDomains: domains,
-          docker: true,
-          langfuseVersion: VERSION,
-        },
-      },
-    });
+//     posthog.capture({
+//       distinctId: "docker:" + clientId,
+//       event: "telemetry",
+//       properties: {
+//         langfuseVersion: VERSION,
+//         userDomains: domains,
+//         totalProjects: totalProjects,
+//         traces: countTraces,
+//         scores: countScores,
+//         observations: countObservations,
+//         datasets: countDatasets,
+//         datasetItems: countDatasetItems,
+//         datasetRuns: countDatasetRuns,
+//         datasetRunItems: countDatasetRunItems,
+//         startTimeframe: startTimeframe?.toISOString(),
+//         endTimeframe: endTimeframe.toISOString(),
+//         eeLicenseKey: env.LANGFUSE_EE_LICENSE_KEY,
+//         langfuseCloudRegion: env.NEXT_PUBLIC_LANGFUSE_CLOUD_REGION,
+//         $set: {
+//           environment: process.env.NODE_ENV,
+//           userDomains: domains,
+//           docker: true,
+//           langfuseVersion: VERSION,
+//         },
+//       },
+//     });
 
-    await posthog.shutdown();
-  } catch (error) {
-    logger.error(error);
-  }
-}
+//     await posthog.shutdown();
+//   } catch (error) {
+//     logger.error(error);
+//   }
+// }
diff --git a/web/src/pages/api/public/dataset-run-items.ts b/web/src/pages/api/public/dataset-run-items.ts
index b6ce632..62143dd 100644
--- a/web/src/pages/api/public/dataset-run-items.ts
+++ b/web/src/pages/api/public/dataset-run-items.ts
@@ -7,7 +7,7 @@ import {
   transformDbDatasetRunItemToAPIDatasetRunItem,
 } from "@/src/features/public-api/types/datasets";
 import { LangfuseNotFoundError, InvalidRequestError } from "@langfuse/shared";
-import { addDatasetRunItemsToEvalQueue } from "@/src/ee/features/evals/server/addDatasetRunItemsToEvalQueue";
+// import { addDatasetRunItemsToEvalQueue } from "@/src/ee/features/evals/server/addDatasetRunItemsToEvalQueue";
 import { getObservationById } from "@langfuse/shared/src/server";
 
 export default withMiddlewares({
@@ -104,12 +104,12 @@ export default withMiddlewares({
        * ASYNC RUN ITEM EVAL *
        ********************/
 
-      await addDatasetRunItemsToEvalQueue({
-        projectId: auth.scope.projectId,
-        datasetItemId,
-        traceId: finalTraceId,
-        observationId: observationId ?? undefined,
-      });
+      // await addDatasetRunItemsToEvalQueue({
+      //   projectId: auth.scope.projectId,
+      //   datasetItemId,
+      //   traceId: finalTraceId,
+      //   observationId: observationId ?? undefined,
+      // });
 
       return transformDbDatasetRunItemToAPIDatasetRunItem({
         ...runItem,
diff --git a/web/src/pages/auth/sign-in.tsx b/web/src/pages/auth/sign-in.tsx
index 671e4f3..5a9e196 100644
--- a/web/src/pages/auth/sign-in.tsx
+++ b/web/src/pages/auth/sign-in.tsx
@@ -27,7 +27,7 @@ import { CloudPrivacyNotice } from "@/src/features/auth/components/AuthCloudPriv
 import { CloudRegionSwitch } from "@/src/features/auth/components/AuthCloudRegionSwitch";
 import { PasswordInput } from "@/src/components/ui/password-input";
 import { Turnstile } from "@marsidev/react-turnstile";
-import { isAnySsoConfigured } from "@/src/ee/features/multi-tenant-sso/utils";
+// import { isAnySsoConfigured } from "@/src/ee/features/multi-tenant-sso/utils";
 import { Shield, Code } from "lucide-react";
 import { useRouter } from "next/router";
 import { captureException } from "@sentry/nextjs";
@@ -76,7 +76,7 @@ export type PageProps = {
 // Also used in src/pages/auth/sign-up.tsx
 // eslint-disable-next-line @typescript-eslint/require-await
 export const getServerSideProps: GetServerSideProps<PageProps> = async () => {
-  const sso: boolean = await isAnySsoConfigured();
+  const sso: boolean = false; // await isAnySsoConfigured();
   return {
     props: {
       authProviders: {
diff --git a/web/src/pages/organization/[organizationId]/settings/index.tsx b/web/src/pages/organization/[organizationId]/settings/index.tsx
index 1817add..e92baeb 100644
--- a/web/src/pages/organization/[organizationId]/settings/index.tsx
+++ b/web/src/pages/organization/[organizationId]/settings/index.tsx
@@ -8,10 +8,10 @@ import { useQueryOrganization } from "@/src/features/organizations/hooks";
 import { useRouter } from "next/router";
 import { SettingsDangerZone } from "@/src/components/SettingsDangerZone";
 import { DeleteOrganizationButton } from "@/src/features/organizations/components/DeleteOrganizationButton";
-import { BillingSettings } from "@/src/ee/features/billing/components/BillingSettings";
+// import { BillingSettings } from "@/src/ee/features/billing/components/BillingSettings";
 import { useHasEntitlement, usePlan } from "@/src/features/entitlements/hooks";
 import ContainerPage from "@/src/components/layouts/container-page";
-import { SSOSettings } from "@/src/ee/features/sso-settings/components/SSOSettings";
+// import { SSOSettings } from "@/src/ee/features/sso-settings/components/SSOSettings";
 import { isCloudPlan } from "@langfuse/shared";
 import { useQueryProjectOrOrganization } from "@/src/features/projects/hooks";
 
@@ -93,14 +93,16 @@ export const getOrganizationSettingsPages = ({
     title: "Billing",
     slug: "billing",
     cmdKKeywords: ["payment", "subscription", "plan", "invoice"],
-    content: <BillingSettings />,
+    // content: <BillingSettings />,
+    content: (<></>),
     show: showBillingSettings,
   },
   {
     title: "SSO",
     slug: "sso",
     cmdKKeywords: ["sso", "login", "auth", "okta", "saml", "azure"],
-    content: <SSOSettings />,
+    // content: <SSOSettings />,
+    content: (<></>),
     show: isLangfuseCloud,
   },
   {
diff --git a/web/src/pages/project/[projectId]/annotation-queues.tsx b/web/src/pages/project/[projectId]/annotation-queues.tsx
index 1187d4e..98aec75 100644
--- a/web/src/pages/project/[projectId]/annotation-queues.tsx
+++ b/web/src/pages/project/[projectId]/annotation-queues.tsx
@@ -1,3 +1,4 @@
-import AnnotationQueues from "@/src/ee/features/annotation-queues/pages/AnnotationQueues";
+// import AnnotationQueues from "@/src/ee/features/annotation-queues/pages/AnnotationQueues";
+const AnnotationQueues = () => (<></>);
 
 export default AnnotationQueues;
diff --git a/web/src/pages/project/[projectId]/annotation-queues/[queueId]/index.tsx b/web/src/pages/project/[projectId]/annotation-queues/[queueId]/index.tsx
index 6baac37..b0871c3 100644
--- a/web/src/pages/project/[projectId]/annotation-queues/[queueId]/index.tsx
+++ b/web/src/pages/project/[projectId]/annotation-queues/[queueId]/index.tsx
@@ -1,3 +1,4 @@
-import QueueItems from "@/src/ee/features/annotation-queues/pages/AnnotationQueueItems";
+// import QueueItems from "@/src/ee/features/annotation-queues/pages/AnnotationQueueItems";
+const QueueItems = () => (<></>);
 
 export default QueueItems;
diff --git a/web/src/pages/project/[projectId]/annotation-queues/[queueId]/items/[itemId].tsx b/web/src/pages/project/[projectId]/annotation-queues/[queueId]/items/[itemId].tsx
index 57ed291..904dfbe 100644
--- a/web/src/pages/project/[projectId]/annotation-queues/[queueId]/items/[itemId].tsx
+++ b/web/src/pages/project/[projectId]/annotation-queues/[queueId]/items/[itemId].tsx
@@ -1,17 +1,18 @@
-import { AnnotationQueuesItem } from "@/src/ee/features/annotation-queues/components/AnnotationQueuesItem";
-import { useRouter } from "next/router";
+// import { AnnotationQueuesItem } from "@/src/ee/features/annotation-queues/components/AnnotationQueuesItem";
+// import { useRouter } from "next/router";
 
 export default function AnnotationQueues() {
-  const router = useRouter();
-  const annotationQueueId = router.query.queueId as string;
-  const projectId = router.query.projectId as string;
-  const itemId = router.query.itemId as string;
+  // const router = useRouter();
+  // const annotationQueueId = router.query.queueId as string;
+  // const projectId = router.query.projectId as string;
+  // const itemId = router.query.itemId as string;
 
   return (
-    <AnnotationQueuesItem
-      annotationQueueId={annotationQueueId}
-      projectId={projectId}
-      itemId={itemId}
-    />
+    // <AnnotationQueuesItem
+    //   annotationQueueId={annotationQueueId}
+    //   projectId={projectId}
+    //   itemId={itemId}
+    // />
+    <></>
   );
 }
diff --git a/web/src/pages/project/[projectId]/annotation-queues/[queueId]/items/index.tsx b/web/src/pages/project/[projectId]/annotation-queues/[queueId]/items/index.tsx
index aea9b56..e16ad6f 100644
--- a/web/src/pages/project/[projectId]/annotation-queues/[queueId]/items/index.tsx
+++ b/web/src/pages/project/[projectId]/annotation-queues/[queueId]/items/index.tsx
@@ -1,15 +1,16 @@
-import { AnnotationQueuesItem } from "@/src/ee/features/annotation-queues/components/AnnotationQueuesItem";
-import { useRouter } from "next/router";
+// import { AnnotationQueuesItem } from "@/src/ee/features/annotation-queues/components/AnnotationQueuesItem";
+// import { useRouter } from "next/router";
 
 export default function AnnotationQueues() {
-  const router = useRouter();
-  const annotationQueueId = router.query.queueId as string;
-  const projectId = router.query.projectId as string;
+  // const router = useRouter();
+  // const annotationQueueId = router.query.queueId as string;
+  // const projectId = router.query.projectId as string;
 
   return (
-    <AnnotationQueuesItem
-      annotationQueueId={annotationQueueId}
-      projectId={projectId}
-    />
+    // <AnnotationQueuesItem
+    //   annotationQueueId={annotationQueueId}
+    //   projectId={projectId}
+    // />
+    <></>
   );
 }
diff --git a/web/src/pages/project/[projectId]/datasets/[datasetId]/compare.tsx b/web/src/pages/project/[projectId]/datasets/[datasetId]/compare.tsx
index fb32769..9292fe2 100644
--- a/web/src/pages/project/[projectId]/datasets/[datasetId]/compare.tsx
+++ b/web/src/pages/project/[projectId]/datasets/[datasetId]/compare.tsx
@@ -12,7 +12,7 @@ import {
   DialogContent,
   DialogTrigger,
 } from "@/src/components/ui/dialog";
-import { CreateExperimentsForm } from "@/src/ee/features/experiments/components/CreateExperimentsForm";
+// import { CreateExperimentsForm } from "@/src/ee/features/experiments/components/CreateExperimentsForm";
 import { useHasProjectAccess } from "@/src/features/rbac/utils/checkProjectAccess";
 import { DatasetAnalytics } from "@/src/features/datasets/components/DatasetAnalytics";
 import { getScoreDataTypeIcon } from "@/src/features/scores/components/ScoreDetailColumnHelpers";
@@ -201,7 +201,7 @@ export default function DatasetCompare() {
                 </Button>
               </DialogTrigger>
               <DialogContent className="max-h-[90vh] overflow-y-auto">
-                <CreateExperimentsForm
+                {/* <CreateExperimentsForm
                   key={`create-experiment-form-${datasetId}`}
                   projectId={projectId as string}
                   setFormOpen={setIsCreateExperimentDialogOpen}
@@ -210,7 +210,7 @@ export default function DatasetCompare() {
                   }}
                   handleExperimentSettled={handleExperimentSettled}
                   showSDKRunInfoPage
-                />
+                /> */}
               </DialogContent>
             </Dialog>
             <MultiSelectKeyValues
diff --git a/web/src/pages/project/[projectId]/datasets/[datasetId]/index.tsx b/web/src/pages/project/[projectId]/datasets/[datasetId]/index.tsx
index 16c8046..0eddfcf 100644
--- a/web/src/pages/project/[projectId]/datasets/[datasetId]/index.tsx
+++ b/web/src/pages/project/[projectId]/datasets/[datasetId]/index.tsx
@@ -29,7 +29,7 @@ import {
   DialogTrigger,
 } from "@/src/components/ui/dialog";
 import { Button } from "@/src/components/ui/button";
-import { CreateExperimentsForm } from "@/src/ee/features/experiments/components/CreateExperimentsForm";
+// import { CreateExperimentsForm } from "@/src/ee/features/experiments/components/CreateExperimentsForm";
 import { showSuccessToast } from "@/src/features/notifications/showSuccessToast";
 import { DropdownMenuItem } from "@/src/components/ui/dropdown-menu";
 import { DatasetAnalytics } from "@/src/features/datasets/components/DatasetAnalytics";
@@ -164,7 +164,7 @@ export default function Dataset() {
                 </Button>
               </DialogTrigger>
               <DialogContent className="max-h-[90vh] overflow-y-auto">
-                <CreateExperimentsForm
+                {/* <CreateExperimentsForm
                   key={`create-experiment-form-${datasetId}`}
                   projectId={projectId as string}
                   setFormOpen={setIsCreateExperimentDialogOpen}
@@ -173,7 +173,7 @@ export default function Dataset() {
                   }}
                   handleExperimentSuccess={handleExperimentSuccess}
                   showSDKRunInfoPage
-                />
+                /> */}
               </DialogContent>
             </Dialog>
 
diff --git a/web/src/pages/project/[projectId]/evals/[evaluatorId].tsx b/web/src/pages/project/[projectId]/evals/[evaluatorId].tsx
index 49b9de7..c6b1b90 100644
--- a/web/src/pages/project/[projectId]/evals/[evaluatorId].tsx
+++ b/web/src/pages/project/[projectId]/evals/[evaluatorId].tsx
@@ -1,3 +1,4 @@
-import { EvaluatorDetail } from "@/src/ee/features/evals/components/evaluator-detail";
+// import { EvaluatorDetail } from "@/src/ee/features/evals/components/evaluator-detail";
+const EvaluatorDetail = () => (<></>);
 
 export default EvaluatorDetail;
diff --git a/web/src/pages/project/[projectId]/evals/index.tsx b/web/src/pages/project/[projectId]/evals/index.tsx
index ca88942..22357fe 100644
--- a/web/src/pages/project/[projectId]/evals/index.tsx
+++ b/web/src/pages/project/[projectId]/evals/index.tsx
@@ -1 +1,4 @@
-export { default as default } from "@/src/ee/features/evals/pages/evaluators";
+// export { default as default } from "@/src/ee/features/evals/pages/evaluators";
+const Evaluators = () => (<></>);
+
+export default Evaluators;
diff --git a/web/src/pages/project/[projectId]/evals/log.tsx b/web/src/pages/project/[projectId]/evals/log.tsx
index 55f75e7..29369b9 100644
--- a/web/src/pages/project/[projectId]/evals/log.tsx
+++ b/web/src/pages/project/[projectId]/evals/log.tsx
@@ -4,7 +4,7 @@
 // For more information see https://langfuse.com/docs/open-source
 
 import { useRouter } from "next/router";
-import EvalLogTable from "@/src/ee/features/evals/components/eval-log";
+// import EvalLogTable from "@/src/ee/features/evals/components/eval-log";
 import {
   TabsBar,
   TabsBarList,
@@ -52,7 +52,7 @@ export default function LogPage() {
         ),
       }}
     >
-      <EvalLogTable projectId={projectId} />
+      {/* <EvalLogTable projectId={projectId} /> */}
     </Page>
   );
 }
diff --git a/web/src/pages/project/[projectId]/evals/new.tsx b/web/src/pages/project/[projectId]/evals/new.tsx
index 55a1799..d94424c 100644
--- a/web/src/pages/project/[projectId]/evals/new.tsx
+++ b/web/src/pages/project/[projectId]/evals/new.tsx
@@ -1 +1,4 @@
-export { default as default } from "@/src/ee/features/evals/pages/new-evaluator";
+// export { default as default } from "@/src/ee/features/evals/pages/new-evaluator";
+const NewEvaluator = () => (<></>);
+
+export default NewEvaluator;
diff --git a/web/src/pages/project/[projectId]/index.tsx b/web/src/pages/project/[projectId]/index.tsx
index 2f37d28..d1861dd 100644
--- a/web/src/pages/project/[projectId]/index.tsx
+++ b/web/src/pages/project/[projectId]/index.tsx
@@ -23,7 +23,7 @@ import { useDashboardDateRange } from "@/src/hooks/useDashboardDateRange";
 import { useDebounce } from "@/src/hooks/useDebounce";
 import { ScoreAnalytics } from "@/src/features/dashboard/components/score-analytics/ScoreAnalytics";
 import SetupTracingButton from "@/src/features/setup/components/SetupTracingButton";
-import { useUiCustomization } from "@/src/ee/features/ui-customization/useUiCustomization";
+// import { useUiCustomization } from "@/src/ee/features/ui-customization/useUiCustomization";
 import { useEntitlementLimit } from "@/src/features/entitlements/hooks";
 import Page from "@/src/components/layouts/page";
 import { MultiSelect } from "@/src/features/filters/components/multi-select";
@@ -38,7 +38,7 @@ export default function Dashboard() {
   const { selectedOption, dateRange, setDateRangeAndOption } =
     useDashboardDateRange();
 
-  const uiCustomization = useUiCustomization();
+  // const uiCustomization = useUiCustomization();
 
   const lookbackLimit = useEntitlementLimit("data-access-days");
 
@@ -206,7 +206,7 @@ export default function Dashboard() {
             onChange={useDebounce(setUserFilterState)}
           />
         </div>
-        {uiCustomization?.feedbackHref === undefined && (
+        {/* {uiCustomization?.feedbackHref === undefined && (
           <FeedbackButtonWrapper
             title="Request Chart"
             description="Your feedback matters! Let the Langfuse team know what additional data or metrics you'd like to see in your dashboard."
@@ -226,7 +226,7 @@ export default function Dashboard() {
               Request Chart
             </Button>
           </FeedbackButtonWrapper>
-        )}
+        )} */}
       </div>
       <div className="grid w-full grid-cols-1 gap-3 overflow-hidden lg:grid-cols-2 xl:grid-cols-6">
         <TracesBarListChart
diff --git a/web/src/pages/project/[projectId]/playground.tsx b/web/src/pages/project/[projectId]/playground.tsx
index b379fad..4d8f93c 100644
--- a/web/src/pages/project/[projectId]/playground.tsx
+++ b/web/src/pages/project/[projectId]/playground.tsx
@@ -1 +1,4 @@
-export { default as default } from "@/src/ee/features/playground/page";
+// export { default as default } from "@/src/ee/features/playground/page";
+const PlaygroundPage = () => <></>;
+
+export default PlaygroundPage;
diff --git a/web/src/pages/project/[projectId]/settings/index.tsx b/web/src/pages/project/[projectId]/settings/index.tsx
index 217ca2e..7c17d16 100644
--- a/web/src/pages/project/[projectId]/settings/index.tsx
+++ b/web/src/pages/project/[projectId]/settings/index.tsx
@@ -24,7 +24,7 @@ import { useRouter } from "next/router";
 import { SettingsDangerZone } from "@/src/components/SettingsDangerZone";
 import { ActionButton } from "@/src/components/ActionButton";
 import { BatchExportsSettingsPage } from "@/src/features/batch-exports/components/BatchExportsSettingsPage";
-import { AuditLogsSettingsPage } from "@/src/ee/features/audit-log-viewer/AuditLogsSettingsPage";
+// import { AuditLogsSettingsPage } from "@/src/ee/features/audit-log-viewer/AuditLogsSettingsPage";
 import { ModelsSettings } from "@/src/features/models/components/ModelSettings";
 import ConfigureRetention from "@/src/features/projects/components/ConfigureRetention";
 import ContainerPage from "@/src/components/layouts/container-page";
@@ -205,7 +205,8 @@ export const getProjectSettingsPages = ({
     title: "Audit Logs",
     slug: "audit-logs",
     cmdKKeywords: ["trail"],
-    content: <AuditLogsSettingsPage projectId={project.id} />,
+    content: (<></>),
+    // content: <AuditLogsSettingsPage projectId={project.id} />,
   },
   {
     title: "Billing",
diff --git a/web/src/server/api/root.ts b/web/src/server/api/root.ts
index ffc7fe6..a7d9a8d 100644
--- a/web/src/server/api/root.ts
+++ b/web/src/server/api/root.ts
@@ -8,12 +8,12 @@ import { apiKeysRouter } from "@/src/features/public-api/server/apiKeyRouter";
 import { membersRouter } from "@/src/features/rbac/server/membersRouter";
 import { userRouter } from "@/src/server/api/routers/users";
 import { datasetRouter } from "@/src/features/datasets/server/dataset-router";
-import { cloudBillingRouter } from "@/src/ee/features/billing/server/cloudBillingRouter";
+// import { cloudBillingRouter } from "@/src/ee/features/billing/server/cloudBillingRouter";
 import { observationsRouter } from "@/src/server/api/routers/observations";
 import { sessionRouter } from "@/src/server/api/routers/sessions";
 import { promptRouter } from "@/src/features/prompts/server/routers/promptRouter";
 import { modelRouter } from "@/src/server/api/routers/models";
-import { evalRouter } from "@/src/ee/features/evals/server/router";
+// import { evalRouter } from "@/src/ee/features/evals/server/router";
 import { posthogIntegrationRouter } from "@/src/features/posthog-integration/posthog-integration-router";
 import { blobStorageIntegrationRouter } from "@/src/features/blobstorage-integration/blobstorage-integration-router";
 import { llmApiKeyRouter } from "@/src/features/llm-api-key/server/router";
@@ -25,11 +25,11 @@ import { publicRouter } from "@/src/server/api/routers/public";
 import { credentialsRouter } from "@/src/features/auth-credentials/server/credentialsRouter";
 import { batchExportRouter } from "@/src/features/batch-exports/server/batchExport";
 import { utilsRouter } from "@/src/server/api/routers/utilities";
-import { uiCustomizationRouter } from "@/src/ee/features/ui-customization/uiCustomizationRouter";
+// import { uiCustomizationRouter } from "@/src/ee/features/ui-customization/uiCustomizationRouter";
 import { commentsRouter } from "@/src/server/api/routers/comments";
-import { queueRouter } from "@/src/ee/features/annotation-queues/server/annotationQueues";
-import { queueItemRouter } from "@/src/ee/features/annotation-queues/server/annotationQueueItems";
-import { experimentsRouter } from "@/src/ee/features/experiments/server/router";
+// import { queueRouter } from "@/src/ee/features/annotation-queues/server/annotationQueues";
+// import { queueItemRouter } from "@/src/ee/features/annotation-queues/server/annotationQueueItems";
+// import { experimentsRouter } from "@/src/ee/features/experiments/server/router";
 import { mediaRouter } from "@/src/server/api/routers/media";
 import { backgroundMigrationsRouter } from "@/src/features/background-migrations/server/background-migrations-router";
 import { auditLogsRouter } from "./routers/auditLogs";
@@ -43,8 +43,8 @@ import { dashboardWidgetRouter } from "./routers/dashboardWidgets";
  * All routers added in /api/routers should be manually added here.
  */
 export const appRouter = createTRPCRouter({
-  annotationQueues: queueRouter,
-  annotationQueueItems: queueItemRouter,
+  // annotationQueues: queueRouter,
+  // annotationQueueItems: queueItemRouter,
   batchExport: batchExportRouter,
   traces: traceRouter,
   sessions: sessionRouter,
@@ -58,12 +58,12 @@ export const appRouter = createTRPCRouter({
   apiKeys: apiKeysRouter,
   members: membersRouter,
   datasets: datasetRouter,
-  cloudBilling: cloudBillingRouter,
+  // cloudBilling: cloudBillingRouter,
   observations: observationsRouter,
   prompts: promptRouter,
   models: modelRouter,
-  evals: evalRouter,
-  experiments: experimentsRouter,
+  // evals: evalRouter,
+  // experiments: experimentsRouter,
   posthogIntegration: posthogIntegrationRouter,
   blobStorageIntegration: blobStorageIntegrationRouter,
   llmApiKey: llmApiKeyRouter,
@@ -72,7 +72,7 @@ export const appRouter = createTRPCRouter({
   public: publicRouter,
   credentials: credentialsRouter,
   utilities: utilsRouter,
-  uiCustomization: uiCustomizationRouter,
+  // uiCustomization: uiCustomizationRouter,
   comments: commentsRouter,
   media: mediaRouter,
   backgroundMigrations: backgroundMigrationsRouter,
diff --git a/web/src/server/auth.ts b/web/src/server/auth.ts
index 8c8fc00..6a32bed 100644
--- a/web/src/server/auth.ts
+++ b/web/src/server/auth.ts
@@ -31,16 +31,16 @@ import KeycloakProvider from "next-auth/providers/keycloak";
 import WorkOSProvider from "next-auth/providers/workos";
 import { type Provider } from "next-auth/providers/index";
 import { getCookieName, getCookieOptions } from "./utils/cookies";
-import {
-  getSsoAuthProviderIdForDomain,
-  loadSsoProviders,
-} from "@/src/ee/features/multi-tenant-sso/utils";
+// import {
+//   getSsoAuthProviderIdForDomain,
+//   loadSsoProviders,
+// } from "@/src/ee/features/multi-tenant-sso/utils";
 import { z } from "zod";
 import { CloudConfigSchema } from "@langfuse/shared";
 import {
   CustomSSOProvider,
   GitHubEnterpriseProvider,
-  traceException,
+  // traceException,
   sendResetPasswordVerificationRequest,
   instrumentAsync,
   logger,
@@ -122,11 +122,11 @@ const staticProviders: Provider[] = [
       }
 
       // EE: Check custom SSO enforcement
-      const multiTenantSsoProvider =
-        await getSsoAuthProviderIdForDomain(domain);
-      if (multiTenantSsoProvider) {
-        throw new Error(`You must sign in via SSO for this domain.`);
-      }
+      // const multiTenantSsoProvider =
+      //   await getSsoAuthProviderIdForDomain(domain);
+      // if (multiTenantSsoProvider) {
+      //   throw new Error(`You must sign in via SSO for this domain.`);
+      // }
 
       const dbUser = await prisma.user.findUnique({
         where: {
@@ -441,12 +441,12 @@ const extendedPrismaAdapter: Adapter = {
  */
 export async function getAuthOptions(): Promise<NextAuthOptions> {
   let dynamicSsoProviders: Provider[] = [];
-  try {
-    dynamicSsoProviders = await loadSsoProviders();
-  } catch (e) {
-    logger.error("Error loading dynamic SSO providers", e);
-    traceException(e);
-  }
+  // try {
+  //   dynamicSsoProviders = await loadSsoProviders();
+  // } catch (e) {
+  //   logger.error("Error loading dynamic SSO providers", e);
+  //   traceException(e);
+  // }
   const providers = [...staticProviders, ...dynamicSsoProviders];
 
   const data: NextAuthOptions = {
@@ -570,18 +570,18 @@ export async function getAuthOptions(): Promise<NextAuthOptions> {
 
           // EE: Check custom SSO enforcement, enforce the specific SSO provider on email domain
           // This also blocks setting a password for an email that is enforced to use SSO via password reset flow
-          const domain = email.split("@")[1];
-          const multiTenantSsoProvider =
-            await getSsoAuthProviderIdForDomain(domain);
-          if (
-            multiTenantSsoProvider &&
-            account?.provider !== multiTenantSsoProvider
-          ) {
-            console.log(
-              "Custom SSO provider enforced for domain, user signed in with other provider",
-            );
-            throw new Error(`You must sign in via SSO for this domain.`);
-          }
+          // const domain = email.split("@")[1];
+          // const multiTenantSsoProvider =
+          //   await getSsoAuthProviderIdForDomain(domain);
+          // if (
+          //   multiTenantSsoProvider &&
+          //   account?.provider !== multiTenantSsoProvider
+          // ) {
+          //   console.log(
+          //     "Custom SSO provider enforced for domain, user signed in with other provider",
+          //   );
+          //   throw new Error(`You must sign in via SSO for this domain.`);
+          // }
 
           // Only allow sign in via email link if user is already in db as this is used for password reset
           if (account?.provider === "email") {
diff --git a/worker/src/__tests__/blobStorageIntegrationProcessing.test.ts b/worker/src/__tests__/blobStorageIntegrationProcessing.test.ts
index d7d7a1c..1754514 100644
--- a/worker/src/__tests__/blobStorageIntegrationProcessing.test.ts
+++ b/worker/src/__tests__/blobStorageIntegrationProcessing.test.ts
@@ -14,7 +14,7 @@ import {
 } from "@langfuse/shared/src/server";
 import { prisma } from "@langfuse/shared/src/db";
 import { Job } from "bullmq";
-import { handleBlobStorageIntegrationProjectJob } from "../ee/integrations/blobstorage/handleBlobStorageIntegrationProjectJob";
+// import { handleBlobStorageIntegrationProjectJob } from "../ee/integrations/blobstorage/handleBlobStorageIntegrationProjectJob";
 import {
   BlobStorageIntegrationType,
   BlobStorageIntegrationFileType,
@@ -40,38 +40,38 @@ describe("BlobStorageIntegrationProcessingJob", () => {
     });
   });
 
-  it("should not process when blob storage integration is disabled", async () => {
-    const { projectId } = await createOrgProjectAndApiKey();
-
-    // Setup an integration but disabled
-    await prisma.blobStorageIntegration.create({
-      data: {
-        projectId,
-        type: BlobStorageIntegrationType.S3,
-        bucketName,
-        prefix: "",
-        accessKeyId,
-        secretAccessKey: encrypt(secretAccessKey),
-        region: region ? region : "auto",
-        endpoint: endpoint ? endpoint : null,
-        forcePathStyle:
-          env.LANGFUSE_S3_EVENT_UPLOAD_FORCE_PATH_STYLE === "true",
-        enabled: false,
-        exportFrequency: "hourly",
-      },
-    });
-
-    // When
-    await handleBlobStorageIntegrationProjectJob({
-      data: { payload: { projectId } },
-    } as Job);
-
-    // Then
-    const files = await storageService.listFiles("");
-    expect(files.filter((f) => f.file.includes(projectId))).toHaveLength(0);
-  });
-
-  it("should export traces, generations, and scores to S3", async () => {
+  // it("should not process when blob storage integration is disabled", async () => {
+  //   const { projectId } = await createOrgProjectAndApiKey();
+
+  //   // Setup an integration but disabled
+  //   await prisma.blobStorageIntegration.create({
+  //     data: {
+  //       projectId,
+  //       type: BlobStorageIntegrationType.S3,
+  //       bucketName,
+  //       prefix: "",
+  //       accessKeyId,
+  //       secretAccessKey: encrypt(secretAccessKey),
+  //       region: region ? region : "auto",
+  //       endpoint: endpoint ? endpoint : null,
+  //       forcePathStyle:
+  //         env.LANGFUSE_S3_EVENT_UPLOAD_FORCE_PATH_STYLE === "true",
+  //       enabled: false,
+  //       exportFrequency: "hourly",
+  //     },
+  //   });
+
+  //   // When
+  //   await handleBlobStorageIntegrationProjectJob({
+  //     data: { payload: { projectId } },
+  //   } as Job);
+
+  //   // Then
+  //   const files = await storageService.listFiles("");
+  //   expect(files.filter((f) => f.file.includes(projectId))).toHaveLength(0);
+  // });
+
+  it.skip("should export traces, generations, and scores to S3", async () => {
     // Setup
     const { projectId } = await createOrgProjectAndApiKey();
     const now = new Date();
@@ -134,9 +134,9 @@ describe("BlobStorageIntegrationProcessingJob", () => {
     ]);
 
     // When
-    await handleBlobStorageIntegrationProjectJob({
-      data: { payload: { projectId } },
-    } as Job);
+    // await handleBlobStorageIntegrationProjectJob({
+    //   data: { payload: { projectId } },
+    // } as Job);
 
     // Then
     const files = await storageService.listFiles("");
diff --git a/worker/src/__tests__/dataRetentionProcessing.test.ts b/worker/src/__tests__/dataRetentionProcessing.test.ts
index 1d4141b..530d957 100644
--- a/worker/src/__tests__/dataRetentionProcessing.test.ts
+++ b/worker/src/__tests__/dataRetentionProcessing.test.ts
@@ -17,7 +17,7 @@ import {
   StorageServiceFactory,
 } from "@langfuse/shared/src/server";
 import { prisma } from "@langfuse/shared/src/db";
-import { handleDataRetentionProcessingJob } from "../ee/dataRetention/handleDataRetentionProcessingJob";
+// import { handleDataRetentionProcessingJob } from "../ee/dataRetention/handleDataRetentionProcessingJob";
 import { Job } from "bullmq";
 
 describe("DataRetentionProcessingJob", () => {
@@ -35,7 +35,7 @@ describe("DataRetentionProcessingJob", () => {
     });
   });
 
-  it("should NOT delete event files from cloud storage if after expiry cutoff", async () => {
+  it.skip("should NOT delete event files from cloud storage if after expiry cutoff", async () => {
     // Setup
     const baseId = randomUUID();
     const fileName = `${baseId}.json`;
@@ -68,9 +68,9 @@ describe("DataRetentionProcessingJob", () => {
     });
 
     // When
-    await handleDataRetentionProcessingJob({
-      data: { payload: { projectId, retention: 7 } }, // Delete after 7 days
-    } as Job);
+    // await handleDataRetentionProcessingJob({
+    //   data: { payload: { projectId, retention: 7 } }, // Delete after 7 days
+    // } as Job);
 
     // Then
     const files = await storageService.listFiles("");
diff --git a/worker/src/__tests__/evalService.filtering.test.ts b/worker/src/__tests__/evalService.filtering.test.ts
index 9250a3d..fa5c785 100644
--- a/worker/src/__tests__/evalService.filtering.test.ts
+++ b/worker/src/__tests__/evalService.filtering.test.ts
@@ -15,7 +15,7 @@ import { randomUUID } from "crypto";
 import Decimal from "decimal.js";
 import { afterAll, test as baseTest, beforeAll, describe } from "vitest";
 import { z } from "zod";
-import { createEvalJobs } from "../ee/evaluation/evalService";
+// import { createEvalJobs } from "../ee/evaluation/evalService";
 import { OpenAIServer } from "./network";
 import { pruneDatabase } from "./utils";
 
@@ -36,10 +36,11 @@ beforeAll(async () => {
 });
 afterAll(openAIServer.teardown);
 
-type EvalJobEventPartial = Omit<
-  Parameters<typeof createEvalJobs>[0]["event"],
-  "projectId" | "traceId"
->;
+type EvalJobEventPartial = any;
+// type EvalJobEventPartial = Omit<
+//   Parameters<typeof createEvalJobs>[0]["event"],
+//   "projectId" | "traceId"
+// >;
 
 type TraceRecordOmitProjectId = Partial<Omit<TraceRecordReadType, "projectId">>;
 type TraceRecordOmitProjectIdAndId = Partial<
diff --git a/worker/src/__tests__/evalService.test.ts b/worker/src/__tests__/evalService.test.ts
index ca0b316..0baadbf 100644
--- a/worker/src/__tests__/evalService.test.ts
+++ b/worker/src/__tests__/evalService.test.ts
@@ -27,11 +27,11 @@ import {
   expect,
   test,
 } from "vitest";
-import {
-  createEvalJobs,
-  evaluate,
-  extractVariablesFromTracingData,
-} from "../ee/evaluation/evalService";
+// import {
+//   createEvalJobs,
+//   evaluate,
+//   extractVariablesFromTracingData,
+// } from "../ee/evaluation/evalService";
 import { compileHandlebarString } from "../features/utilities";
 import { OpenAIServer } from "./network";
 import { pruneDatabase } from "./utils";
diff --git a/worker/src/__tests__/experimentsService.test.ts b/worker/src/__tests__/experimentsService.test.ts
index bb96845..d91c76f 100644
--- a/worker/src/__tests__/experimentsService.test.ts
+++ b/worker/src/__tests__/experimentsService.test.ts
@@ -1,5 +1,5 @@
 import { expect, test, describe, vi, beforeEach } from "vitest";
-import { createExperimentJob } from "../ee/experiments/experimentService";
+// import { createExperimentJob } from "../ee/experiments/experimentService";
 import { kyselyPrisma, prisma } from "@langfuse/shared/src/db";
 import { randomUUID } from "crypto";
 import { pruneDatabase } from "./utils";
@@ -16,7 +16,7 @@ vi.mock("../features/utilities", () => ({
 }));
 
 describe("create experiment jobs", () => {
-  test("creates new experiment job", async () => {
+  test.skip("creates new experiment job", async () => {
     await pruneDatabase();
     const projectId = "7a88fb47-b4e2-43b8-a06c-a5ce950dc53a";
     const datasetId = randomUUID();
@@ -90,7 +90,7 @@ describe("create experiment jobs", () => {
       runId,
     };
 
-    await createExperimentJob({ event: payload });
+    // await createExperimentJob({ event: payload });
 
     const runItems = await kyselyPrisma.$kysely
       .selectFrom("dataset_run_items")
diff --git a/worker/src/app.ts b/worker/src/app.ts
index 79e74af..68dcf0d 100644
--- a/worker/src/app.ts
+++ b/worker/src/app.ts
@@ -23,7 +23,7 @@ import { WorkerManager } from "./queues/workerManager";
 import {
   CoreDataS3ExportQueue,
   DataRetentionQueue,
-  MeteringDataPostgresExportQueue,
+  // MeteringDataPostgresExportQueue,
   PostHogIntegrationQueue,
   QueueName,
   logger,
@@ -44,7 +44,7 @@ import {
   blobStorageIntegrationProcessor,
 } from "./queues/blobStorageIntegrationQueue";
 import { coreDataS3ExportProcessor } from "./queues/coreDataS3ExportQueue";
-import { meteringDataPostgresExportProcessor } from "./ee/meteringDataPostgresExport/handleMeteringDataPostgresExportJob";
+// import { meteringDataPostgresExportProcessor } from "./ee/meteringDataPostgresExport/handleMeteringDataPostgresExportJob";
 import {
   dataRetentionProcessingProcessor,
   dataRetentionProcessor,
@@ -106,18 +106,18 @@ if (env.LANGFUSE_S3_CORE_DATA_EXPORT_IS_ENABLED === "true") {
 
 if (env.LANGFUSE_POSTGRES_METERING_DATA_EXPORT_IS_ENABLED === "true") {
   // Instantiate the queue to trigger scheduled jobs
-  MeteringDataPostgresExportQueue.getInstance();
-  WorkerManager.register(
-    QueueName.MeteringDataPostgresExportQueue,
-    meteringDataPostgresExportProcessor,
-    {
-      limiter: {
-        // Process at most `max` jobs per 30 seconds
-        max: 1,
-        duration: 30_000,
-      },
-    },
-  );
+  // MeteringDataPostgresExportQueue.getInstance();
+  // WorkerManager.register(
+  //   QueueName.MeteringDataPostgresExportQueue,
+  //   meteringDataPostgresExportProcessor,
+  //   {
+  //     limiter: {
+  //       // Process at most `max` jobs per 30 seconds
+  //       max: 1,
+  //       duration: 30_000,
+  //     },
+  //   },
+  // );
 }
 
 if (env.QUEUE_CONSUMER_TRACE_DELETE_QUEUE_IS_ENABLED === "true") {
diff --git a/worker/src/ee/cloudUsageMetering/constants.ts b/worker/src/ee/cloudUsageMetering/constants.ts
deleted file mode 100644
index c8171d9..0000000
--- a/worker/src/ee/cloudUsageMetering/constants.ts
+++ /dev/null
@@ -1,6 +0,0 @@
-export const cloudUsageMeteringDbCronJobName = "cloud_usage_metering";
-
-export enum CloudUsageMeteringDbCronJobStates {
-  Queued = "queued",
-  Processing = "processing",
-}
diff --git a/worker/src/ee/cloudUsageMetering/handleCloudUsageMeteringJob.ts b/worker/src/ee/cloudUsageMetering/handleCloudUsageMeteringJob.ts
deleted file mode 100644
index 7a5afaf..0000000
--- a/worker/src/ee/cloudUsageMetering/handleCloudUsageMeteringJob.ts
+++ /dev/null
@@ -1,268 +0,0 @@
-import { parseDbOrg, Prisma } from "@langfuse/shared";
-import { prisma } from "@langfuse/shared/src/db";
-import Stripe from "stripe";
-import { env } from "../../env";
-import {
-  CloudUsageMeteringQueue,
-  getObservationCountsByProjectInCreationInterval,
-  getScoreCountsByProjectInCreationInterval,
-  getTraceCountsByProjectInCreationInterval,
-  logger,
-} from "@langfuse/shared/src/server";
-import {
-  cloudUsageMeteringDbCronJobName,
-  CloudUsageMeteringDbCronJobStates,
-} from "./constants";
-import {
-  QueueJobs,
-  recordGauge,
-  traceException,
-} from "@langfuse/shared/src/server";
-import { Job } from "bullmq";
-import { backOff } from "exponential-backoff";
-
-const delayFromStartOfInterval = 3600000 + 5 * 60 * 1000; // 5 minutes after the end of the interval
-
-export const handleCloudUsageMeteringJob = async (job: Job) => {
-  if (!env.STRIPE_SECRET_KEY) {
-    logger.warn("[CLOUD USAGE METERING] Stripe secret key not found");
-    throw new Error("Stripe secret key not found");
-  }
-
-  // Get cron job, create if it does not exist
-  const cron = await prisma.cronJobs.upsert({
-    where: { name: cloudUsageMeteringDbCronJobName },
-    create: {
-      name: cloudUsageMeteringDbCronJobName,
-      state: CloudUsageMeteringDbCronJobStates.Queued,
-      lastRun: new Date(Date.now() - ((Date.now() % 3600000) + 3600000)), // beginning of the last full hour
-    },
-    update: {},
-  });
-  if (!cron.lastRun) {
-    logger.warn("[CLOUD USAGE METERING] Cron job last run not found");
-    throw new Error("Cloud Usage Metering Cron Job last run not found");
-  }
-  if (cron.lastRun.getTime() % 3600000 !== 0) {
-    logger.warn(
-      "[CLOUD USAGE METERING] Cron job last run is not on the full hour",
-    );
-    throw new Error(
-      "Cloud Usage Metering Cron Job last run is not on the full hour",
-    );
-  }
-  if (cron.lastRun.getTime() + delayFromStartOfInterval > Date.now()) {
-    logger.info(`[CLOUD USAGE METERING] Next Job is not due yet`);
-    return;
-  }
-
-  if (cron.state === CloudUsageMeteringDbCronJobStates.Processing) {
-    if (
-      cron.jobStartedAt &&
-      cron.jobStartedAt < new Date(Date.now() - 1200000)
-    ) {
-      logger.warn(
-        "[CLOUD USAGE METERING] Last job started at is older than 20 minutes, retrying job",
-      );
-    } else {
-      logger.warn("[CLOUD USAGE METERING] Job already in progress");
-      return;
-    }
-  }
-
-  try {
-    await prisma.cronJobs.update({
-      where: {
-        name: cloudUsageMeteringDbCronJobName,
-        state: cron.state,
-        jobStartedAt: cron.jobStartedAt,
-      },
-      data: {
-        state: CloudUsageMeteringDbCronJobStates.Processing,
-        jobStartedAt: new Date(),
-      },
-    });
-  } catch (e) {
-    logger.warn(
-      "[CLOUD USAGE METERING] Failed to update cron job state, potential race condition, exiting",
-      {
-        e,
-      },
-    );
-    return;
-  }
-
-  // timing
-  const meterIntervalStart = cron.lastRun;
-  const meterIntervalEnd = new Date(cron.lastRun.getTime() + 3600000);
-  logger.info(
-    `[CLOUD USAGE METERING] Job running for interval ${meterIntervalStart.toISOString()} - ${meterIntervalEnd.toISOString()}`,
-  );
-
-  // find all organizations which have a stripe org id set up
-  const organizations = (
-    await prisma.organization.findMany({
-      where: {
-        cloudConfig: {
-          path: ["stripe", "customerId"],
-          not: Prisma.DbNull,
-        },
-      },
-      include: {
-        projects: {
-          select: {
-            id: true,
-          },
-        },
-      },
-    })
-  ).map(({ projects, ...org }) => ({
-    ...parseDbOrg(org),
-    projectIds: projects.map((p) => p.id),
-  }));
-  logger.info(
-    `[CLOUD USAGE METERING] Job for ${organizations.length} organizations`,
-  );
-
-  const observationCountsByProject =
-    await getObservationCountsByProjectInCreationInterval({
-      start: meterIntervalStart,
-      end: meterIntervalEnd,
-    });
-  const traceCountsByProject = await getTraceCountsByProjectInCreationInterval({
-    start: meterIntervalStart,
-    end: meterIntervalEnd,
-  });
-  const scoreCountsByProject = await getScoreCountsByProjectInCreationInterval({
-    start: meterIntervalStart,
-    end: meterIntervalEnd,
-  });
-
-  // setup stripe client
-  const stripe = new Stripe(env.STRIPE_SECRET_KEY);
-
-  // for each org, calculate the meter and push to stripe
-  let countProcessedOrgs = 0;
-  let countProcessedObservations = 0;
-  let countProcessedEvents = 0;
-  for (const org of organizations) {
-    // update progress to prevent job from being stalled
-    job.updateProgress(countProcessedOrgs / organizations.length);
-
-    const stripeCustomerId = org.cloudConfig?.stripe?.customerId;
-    if (!stripeCustomerId) {
-      // should not happen
-      traceException(
-        `[CLOUD USAGE METERING] Stripe customer id not found for org ${org.id}`,
-      );
-      logger.error(
-        `[CLOUD USAGE METERING] Stripe customer id not found for org ${org.id}`,
-      );
-      continue;
-    }
-
-    // Observations (legacy)
-    const countObservations = observationCountsByProject
-      .filter((p) => org.projectIds.includes(p.projectId))
-      .reduce((sum, p) => sum + p.count, 0);
-
-    logger.info(
-      `[CLOUD USAGE METERING] Job for org ${org.id} - ${stripeCustomerId} stripe customer id - ${countObservations} observations`,
-    );
-    if (countObservations > 0) {
-      await backOff(
-        async () =>
-          await stripe.billing.meterEvents.create({
-            event_name: "tracing_observations",
-            timestamp: meterIntervalEnd.getTime() / 1000,
-            payload: {
-              stripe_customer_id: stripeCustomerId,
-              value: countObservations.toString(), // value is a string in stripe
-            },
-          }),
-        {
-          numOfAttempts: 3,
-        },
-      );
-    }
-
-    // Events
-    const countScores = scoreCountsByProject
-      .filter((p) => org.projectIds.includes(p.projectId))
-      .reduce((sum, p) => sum + p.count, 0);
-    const countTraces = traceCountsByProject
-      .filter((p) => org.projectIds.includes(p.projectId))
-      .reduce((sum, p) => sum + p.count, 0);
-    const countEvents = countScores + countTraces + countObservations;
-    logger.info(
-      `[CLOUD USAGE METERING] Job for org ${org.id} - ${stripeCustomerId} stripe customer id - ${countEvents} events`,
-    );
-    if (countEvents > 0) {
-      // retrying the stripe call in case of an HTTP error
-      await backOff(
-        async () =>
-          await stripe.billing.meterEvents.create({
-            event_name: "tracing_events",
-            timestamp: meterIntervalEnd.getTime() / 1000,
-            payload: {
-              stripe_customer_id: stripeCustomerId,
-              value: countEvents.toString(), // value is a string in stripe
-            },
-          }),
-        {
-          numOfAttempts: 3,
-        },
-      );
-    }
-
-    countProcessedOrgs++;
-    countProcessedObservations += countObservations;
-    countProcessedEvents += countEvents;
-  }
-
-  recordGauge("cloud_usage_metering_processed_orgs", countProcessedOrgs, {
-    unit: "organizations",
-  });
-  recordGauge(
-    "cloud_usage_metering_processed_observations",
-    countProcessedObservations,
-    {
-      unit: "observations",
-    },
-  );
-  recordGauge("cloud_usage_metering_processed_events", countProcessedEvents, {
-    unit: "events",
-  });
-
-  // update cron job
-  await prisma.cronJobs.update({
-    where: { name: cloudUsageMeteringDbCronJobName },
-    data: {
-      lastRun: meterIntervalEnd,
-      state: CloudUsageMeteringDbCronJobStates.Queued,
-      jobStartedAt: null,
-    },
-  });
-
-  logger.info(
-    `[CLOUD USAGE METERING] Job for interval ${meterIntervalStart.toISOString()} - ${meterIntervalEnd.toISOString()} completed`,
-    {
-      countProcessedOrgs,
-      countProcessedObservations,
-      countProcessedEvents,
-    },
-  );
-
-  if (meterIntervalEnd.getTime() + delayFromStartOfInterval < Date.now()) {
-    logger.info(
-      `[CLOUD USAGE METERING] Enqueueing next Cloud Usage Metering Job to catch up `,
-    );
-    recordGauge("cloud_usage_metering_scheduled_catchup_jobs", 1, {
-      unit: "jobs",
-    });
-    await CloudUsageMeteringQueue.getInstance()?.add(
-      QueueJobs.CloudUsageMeteringJob,
-      {},
-    );
-  }
-};
diff --git a/worker/src/ee/dataRetention/handleDataRetentionProcessingJob.ts b/worker/src/ee/dataRetention/handleDataRetentionProcessingJob.ts
deleted file mode 100644
index 28dd84d..0000000
--- a/worker/src/ee/dataRetention/handleDataRetentionProcessingJob.ts
+++ /dev/null
@@ -1,128 +0,0 @@
-import {
-  deleteEventLogByProjectIdBeforeDate,
-  deleteObservationsOlderThanDays,
-  deleteScoresOlderThanDays,
-  deleteTracesOlderThanDays,
-  getEventLogByProjectIdBeforeDate,
-  logger,
-  StorageService,
-  StorageServiceFactory,
-} from "@langfuse/shared/src/server";
-import { Job } from "bullmq";
-import { prisma } from "@langfuse/shared/src/db";
-import { env } from "../../env";
-
-let s3MediaStorageClient: StorageService;
-
-const getS3MediaStorageClient = (bucketName: string): StorageService => {
-  if (!s3MediaStorageClient) {
-    s3MediaStorageClient = StorageServiceFactory.getInstance({
-      bucketName,
-      accessKeyId: env.LANGFUSE_S3_MEDIA_UPLOAD_ACCESS_KEY_ID,
-      secretAccessKey: env.LANGFUSE_S3_MEDIA_UPLOAD_SECRET_ACCESS_KEY,
-      endpoint: env.LANGFUSE_S3_MEDIA_UPLOAD_ENDPOINT,
-      region: env.LANGFUSE_S3_MEDIA_UPLOAD_REGION,
-      forcePathStyle: env.LANGFUSE_S3_MEDIA_UPLOAD_FORCE_PATH_STYLE === "true",
-    });
-  }
-  return s3MediaStorageClient;
-};
-
-let s3EventStorageClient: StorageService;
-
-const getS3EventStorageClient = (bucketName: string): StorageService => {
-  if (!s3EventStorageClient) {
-    s3EventStorageClient = StorageServiceFactory.getInstance({
-      bucketName,
-      accessKeyId: env.LANGFUSE_S3_EVENT_UPLOAD_ACCESS_KEY_ID,
-      secretAccessKey: env.LANGFUSE_S3_EVENT_UPLOAD_SECRET_ACCESS_KEY,
-      endpoint: env.LANGFUSE_S3_EVENT_UPLOAD_ENDPOINT,
-      region: env.LANGFUSE_S3_EVENT_UPLOAD_REGION,
-      forcePathStyle: env.LANGFUSE_S3_EVENT_UPLOAD_FORCE_PATH_STYLE === "true",
-    });
-  }
-  return s3EventStorageClient;
-};
-
-export const handleDataRetentionProcessingJob = async (job: Job) => {
-  const { projectId, retention } = job.data.payload;
-
-  const cutoffDate = new Date(Date.now() - retention * 24 * 60 * 60 * 1000);
-
-  // Delete media files if bucket is configured
-  if (env.LANGFUSE_S3_MEDIA_UPLOAD_BUCKET) {
-    logger.info(
-      `[Data Retention] Deleting media files older than ${retention} days for project ${projectId}`,
-    );
-    const mediaFilesToDelete = await prisma.media.findMany({
-      select: {
-        id: true,
-        projectId: true,
-        createdAt: true,
-        bucketPath: true,
-        bucketName: true,
-      },
-      where: {
-        projectId,
-        createdAt: {
-          lte: cutoffDate,
-        },
-      },
-    });
-    const mediaStorageClient = getS3MediaStorageClient(
-      env.LANGFUSE_S3_MEDIA_UPLOAD_BUCKET,
-    );
-    // Delete from Cloud Storage
-    await mediaStorageClient.deleteFiles(
-      mediaFilesToDelete.map((f) => f.bucketPath),
-    );
-    // Delete from postgres. We should automatically remove the corresponding traceMedia and observationMedia
-    await prisma.media.deleteMany({
-      where: {
-        id: {
-          in: mediaFilesToDelete.map((f) => f.id),
-        },
-        projectId,
-      },
-    });
-    logger.info(
-      `[Data Retention] Deleted ${mediaFilesToDelete.length} media files for project ${projectId}`,
-    );
-  }
-
-  // Remove event files from S3
-  const eventLogStream = getEventLogByProjectIdBeforeDate(
-    projectId,
-    cutoffDate,
-  );
-  let eventLogPaths: string[] = [];
-  const eventStorageClient = getS3EventStorageClient(
-    env.LANGFUSE_S3_EVENT_UPLOAD_BUCKET,
-  );
-  for await (const eventLog of eventLogStream) {
-    eventLogPaths.push(eventLog.bucket_path);
-    if (eventLogPaths.length > 500) {
-      // Delete the current batch and reset the list
-      await eventStorageClient.deleteFiles(eventLogPaths);
-      eventLogPaths = [];
-    }
-  }
-  // Delete any remaining files
-  await eventStorageClient.deleteFiles(eventLogPaths);
-
-  // Delete ClickHouse (TTL / Delete Queries)
-  logger.info(
-    `[Data Retention] Deleting ClickHouse data older than ${retention} days for project ${projectId}`,
-  );
-  await Promise.all([
-    deleteTracesOlderThanDays(projectId, retention),
-    deleteObservationsOlderThanDays(projectId, retention),
-    deleteScoresOlderThanDays(projectId, retention),
-    deleteEventLogByProjectIdBeforeDate(projectId, cutoffDate),
-  ]);
-  logger.info(
-    `[Data Retention] Deleted ClickHouse data older than ${retention} days for project ${projectId}`,
-  );
-
-  // Set S3 Lifecycle for deletion (Future)
-};
diff --git a/worker/src/ee/dataRetention/handleDataRetentionSchedule.ts b/worker/src/ee/dataRetention/handleDataRetentionSchedule.ts
deleted file mode 100644
index 078f52b..0000000
--- a/worker/src/ee/dataRetention/handleDataRetentionSchedule.ts
+++ /dev/null
@@ -1,42 +0,0 @@
-import { Job } from "bullmq";
-import { prisma } from "@langfuse/shared/src/db";
-import {
-  DataRetentionProcessingQueue,
-  QueueJobs,
-} from "@langfuse/shared/src/server";
-import { randomUUID } from "crypto";
-
-export const handleDataRetentionSchedule = async (job: Job) => {
-  const projectsWithRetention = await prisma.project.findMany({
-    select: {
-      id: true,
-      retentionDays: true,
-    },
-    where: {
-      retentionDays: {
-        gt: 0, // Select all projects with a non-zero/non-null retention
-      },
-    },
-  });
-
-  const dataRetentionProcessingQueue =
-    DataRetentionProcessingQueue.getInstance();
-  if (!dataRetentionProcessingQueue) {
-    throw new Error("DataRetentionProcessingQueue not initialized");
-  }
-
-  await dataRetentionProcessingQueue.addBulk(
-    projectsWithRetention.map((project) => ({
-      name: QueueJobs.DataRetentionProcessingJob,
-      data: {
-        id: randomUUID(),
-        name: QueueJobs.DataRetentionProcessingJob,
-        timestamp: new Date(),
-        payload: {
-          projectId: project.id,
-          retention: project.retentionDays,
-        },
-      },
-    })),
-  );
-};
diff --git a/worker/src/ee/evaluation/evalService.ts b/worker/src/ee/evaluation/evalService.ts
deleted file mode 100644
index 1d259c1..0000000
--- a/worker/src/ee/evaluation/evalService.ts
+++ /dev/null
@@ -1,758 +0,0 @@
-import { randomUUID } from "crypto";
-import { sql } from "kysely";
-import { z } from "zod";
-import { JobConfigState } from "@prisma/client";
-import {
-  QueueJobs,
-  QueueName,
-  EvalExecutionEvent,
-  tableColumnsToSqlFilterAndPrefix,
-  traceException,
-  eventTypes,
-  redis,
-  IngestionQueue,
-  logger,
-  EvalExecutionQueue,
-  checkTraceExists,
-  checkObservationExists,
-  getTraceById,
-  getObservationForTraceIdByName,
-  DatasetRunItemUpsertEventType,
-  TraceQueueEventType,
-  StorageService,
-  StorageServiceFactory,
-  CreateEvalQueueEventType,
-  ChatMessageType,
-} from "@langfuse/shared/src/server";
-import {
-  availableTraceEvalVariables,
-  ChatMessageRole,
-  ForbiddenError,
-  LangfuseNotFoundError,
-  LLMApiKeySchema,
-  Prisma,
-  singleFilter,
-  InvalidRequestError,
-  variableMappingList,
-  ZodModelConfig,
-  evalDatasetFormFilterCols,
-  availableDatasetEvalVariables,
-  variableMapping,
-  JobTimeScope,
-  ScoreSource,
-} from "@langfuse/shared";
-import { kyselyPrisma, prisma } from "@langfuse/shared/src/db";
-import { backOff } from "exponential-backoff";
-import {
-  callStructuredLLM,
-  compileHandlebarString,
-} from "../../features/utilities";
-import { JSONPath } from "jsonpath-plus";
-import { env } from "../../env";
-
-let s3StorageServiceClient: StorageService;
-
-const getS3StorageServiceClient = (bucketName: string): StorageService => {
-  if (!s3StorageServiceClient) {
-    s3StorageServiceClient = StorageServiceFactory.getInstance({
-      bucketName,
-      accessKeyId: env.LANGFUSE_S3_EVENT_UPLOAD_ACCESS_KEY_ID,
-      secretAccessKey: env.LANGFUSE_S3_EVENT_UPLOAD_SECRET_ACCESS_KEY,
-      endpoint: env.LANGFUSE_S3_EVENT_UPLOAD_ENDPOINT,
-      region: env.LANGFUSE_S3_EVENT_UPLOAD_REGION,
-      forcePathStyle: env.LANGFUSE_S3_EVENT_UPLOAD_FORCE_PATH_STYLE === "true",
-    });
-  }
-  return s3StorageServiceClient;
-};
-
-// this function is used to determine which eval jobs to create for a given trace
-// there might be multiple eval jobs to create for a single trace
-export const createEvalJobs = async ({
-  event,
-  enforcedJobTimeScope,
-}: {
-  event:
-    | TraceQueueEventType
-    | DatasetRunItemUpsertEventType
-    | CreateEvalQueueEventType;
-  enforcedJobTimeScope?: JobTimeScope;
-}) => {
-  // Fetch all configs for a given project. Those may be dataset or trace configs.
-  let configsQuery = kyselyPrisma.$kysely
-    .selectFrom("job_configurations")
-    .selectAll()
-    .where(sql.raw("job_type::text"), "=", "EVAL")
-    .where("project_id", "=", event.projectId);
-
-  if ("configId" in event) {
-    // if configid is set in the event, we only want to fetch the one config
-    configsQuery = configsQuery.where("id", "=", event.configId);
-  }
-
-  // for dataset_run_item_upsert queue + trace queue, we do not want to execute evals on configs,
-  // which were only allowed to run on historic data. Hence, we need to filter all configs which have "NEW" in the time_scope column.
-  if (enforcedJobTimeScope) {
-    configsQuery = configsQuery.where(
-      "time_scope",
-      "@>",
-      sql<string[]>`ARRAY[${enforcedJobTimeScope}]`,
-    );
-  }
-
-  const configs = await configsQuery.execute();
-
-  if (configs.length === 0) {
-    logger.debug("No evaluation jobs found for project", event.projectId);
-    return;
-  }
-
-  logger.debug(
-    `Creating eval jobs for trace ${event.traceId} on project ${event.projectId}`,
-  );
-
-  for (const config of configs) {
-    if (config.status === JobConfigState.INACTIVE) {
-      logger.debug(`Skipping inactive config ${config.id}`);
-      continue;
-    }
-
-    logger.debug("Creating eval job for config", config.id);
-    const validatedFilter = z.array(singleFilter).parse(config.filter);
-
-    // Check whether the trace already exists in the database.
-    const traceExists = await checkTraceExists(
-      event.projectId,
-      event.traceId,
-      "timestamp" in event ? new Date(event.timestamp) : new Date(),
-      config.target_object === "trace" ? validatedFilter : [],
-    );
-
-    const isDatasetConfig = config.target_object === "dataset";
-    let datasetItem: { id: string } | undefined;
-    if (isDatasetConfig) {
-      const condition = tableColumnsToSqlFilterAndPrefix(
-        config.target_object === "dataset" ? validatedFilter : [],
-        evalDatasetFormFilterCols,
-        "dataset_items",
-      );
-
-      // If the target object is a dataset and the event type has a datasetItemId, we try to fetch it based on our filter
-      if ("datasetItemId" in event && event.datasetItemId) {
-        const datasetItems = await prisma.$queryRaw<
-          Array<{ id: string }>
-        >(Prisma.sql`
-          SELECT id
-          FROM dataset_items as di
-          WHERE project_id = ${event.projectId}
-            AND id = ${event.datasetItemId}
-            ${condition}
-        `);
-        datasetItem = datasetItems.shift();
-      } else {
-        // Otherwise, try to find the dataset item id from datasetRunItems.
-        // Here, we can search for the traceId and projectId and should only get one result.
-        const datasetItems = await prisma.$queryRaw<
-          Array<{ id: string }>
-        >(Prisma.sql`
-          SELECT dataset_item_id as id
-          FROM dataset_run_items as dri
-          JOIN dataset_items as di ON di.id = dri.dataset_item_id AND di.project_id = ${event.projectId}
-          WHERE dri.project_id = ${event.projectId}
-            AND dri.trace_id = ${event.traceId}
-            ${condition}
-        `);
-        datasetItem = datasetItems.shift();
-      }
-    }
-
-    // We also need to validate that the observation exists in case an observationId is set
-    // If it's not set, we go into the retry loop. For the other events, we expect that the rerun
-    // is unnecessary, as we're triggering this flow if either event comes in.
-    const observationId =
-      "observationId" in event && event.observationId
-        ? event.observationId
-        : undefined;
-    if (observationId) {
-      const observationExists = await checkObservationExists(
-        event.projectId,
-        observationId,
-        "timestamp" in event ? new Date(event.timestamp) : new Date(),
-      );
-      if (!observationExists) {
-        logger.warn(
-          `Observation ${observationId} not found, retrying dataset eval later`,
-        );
-        throw new Error(
-          "Observation not found. Rejecting job to use retry-attempts.",
-        );
-      }
-    }
-
-    // Fetch the existing job for the given configuration.
-    // We either use it for deduplication or we cancel it in case it became "deselected".
-    const existingJob = await kyselyPrisma.$kysely
-      .selectFrom("job_executions")
-      .select("id")
-      .where("project_id", "=", event.projectId)
-      .where("job_configuration_id", "=", config.id)
-      .where("job_input_trace_id", "=", event.traceId)
-      .where(
-        "job_input_dataset_item_id",
-        datasetItem ? "=" : "is",
-        datasetItem ? datasetItem.id : null,
-      )
-      .where(
-        "job_input_observation_id",
-        observationId ? "=" : "is",
-        observationId || null,
-      )
-      .execute();
-
-    // If we matched a trace for a trace event, we create a job or
-    // if we have both trace and datasetItem.
-    if (traceExists && (!isDatasetConfig || Boolean(datasetItem))) {
-      const jobExecutionId = randomUUID();
-
-      // deduplication: if a job exists already for a trace event, we do not create a new one.
-      if (existingJob.length > 0) {
-        logger.debug(
-          `Eval job for config ${config.id} and trace ${event.traceId} already exists`,
-        );
-        continue;
-      }
-
-      // apply sampling. Only if the job is sampled, we create a job
-      // user supplies a number between 0 and 1, which is the probability of sampling
-      if (parseFloat(config.sampling) !== 1) {
-        const random = Math.random();
-        if (random > parseFloat(config.sampling)) {
-          logger.debug(
-            `Eval job for config ${config.id} and trace ${event.traceId} was sampled out`,
-          );
-          continue;
-        }
-      }
-
-      logger.debug(
-        `Creating eval job for config ${config.id} and trace ${event.traceId}`,
-      );
-
-      await prisma.jobExecution.create({
-        data: {
-          id: jobExecutionId,
-          projectId: event.projectId,
-          jobConfigurationId: config.id,
-          jobInputTraceId: event.traceId,
-          status: "PENDING",
-          startTime: new Date(),
-          ...(datasetItem
-            ? {
-                jobInputDatasetItemId: datasetItem.id,
-                jobInputObservationId: observationId || null,
-              }
-            : {}),
-        },
-      });
-
-      // add the job to the next queue so that eval can be executed
-      await EvalExecutionQueue.getInstance()?.add(
-        QueueName.EvaluationExecution,
-        {
-          name: QueueJobs.EvaluationExecution,
-          id: randomUUID(),
-          timestamp: new Date(),
-          payload: {
-            projectId: event.projectId,
-            jobExecutionId: jobExecutionId,
-            delay: config.delay,
-          },
-        },
-        {
-          delay: config.delay, // milliseconds
-        },
-      );
-    } else {
-      // if we do not have a match, and execution exists, we mark the job as cancelled
-      // we do this, because a second trace event might 'deselect' a trace
-      logger.debug(`Eval job for config ${config.id} did not match trace`);
-      if (existingJob.length > 0) {
-        logger.debug(
-          `Cancelling eval job for config ${config.id} and trace ${event.traceId}`,
-        );
-        await kyselyPrisma.$kysely
-          .updateTable("job_executions")
-          .set("status", sql`'CANCELLED'::"JobExecutionStatus"`)
-          .set("end_time", new Date())
-          .where("id", "=", existingJob[0].id)
-          .execute();
-      }
-    }
-  }
-};
-
-// for a single eval job, this function is used to evaluate the job
-export const evaluate = async ({
-  event,
-}: {
-  event: z.infer<typeof EvalExecutionEvent>;
-}) => {
-  logger.debug(
-    `Evaluating job ${event.jobExecutionId} for project ${event.projectId}`,
-  );
-  // first, fetch all the context required for the evaluation
-  const job = await kyselyPrisma.$kysely
-    .selectFrom("job_executions")
-    .selectAll()
-    .where("id", "=", event.jobExecutionId)
-    .where("project_id", "=", event.projectId)
-    .executeTakeFirst();
-
-  if (!job) {
-    logger.info(
-      `Job execution with id ${event.jobExecutionId} for project ${event.projectId} not found. This was likely deleted by the user.`,
-    );
-    return;
-  }
-
-  if (!job?.job_input_trace_id) {
-    throw new ForbiddenError(
-      "Jobs can only be executed on traces and dataset runs for now.",
-    );
-  }
-
-  if (job.status === "CANCELLED") {
-    logger.debug(`Job ${job.id} for project ${event.projectId} was cancelled.`);
-
-    await kyselyPrisma.$kysely
-      .deleteFrom("job_executions")
-      .where("id", "=", job.id)
-      .where("project_id", "=", event.projectId)
-      .execute();
-
-    return;
-  }
-
-  const config = await kyselyPrisma.$kysely
-    .selectFrom("job_configurations")
-    .selectAll()
-    .where("id", "=", job.job_configuration_id)
-    .where("project_id", "=", event.projectId)
-    .executeTakeFirstOrThrow();
-
-  if (!config || !config.eval_template_id) {
-    logger.error(
-      `Eval template not found for config ${config.eval_template_id}`,
-    );
-    throw new InvalidRequestError(
-      `Eval template not found for config ${config.eval_template_id}`,
-    );
-  }
-
-  const template = await prisma.evalTemplate.findFirstOrThrow({
-    where: {
-      id: config.eval_template_id,
-      projectId: event.projectId,
-    },
-  });
-
-  logger.debug(
-    `Evaluating job ${job.id} for project ${event.projectId} with template ${template.id}. Searching for context...`,
-  );
-
-  // selectedcolumnid is not safe to use, needs validation in extractVariablesFromTrace()
-  const parsedVariableMapping = variableMappingList.parse(
-    config.variable_mapping,
-  );
-
-  // extract the variables which need to be inserted into the prompt
-  const mappingResult = await extractVariablesFromTracingData({
-    projectId: event.projectId,
-    variables: template.vars,
-    traceId: job.job_input_trace_id,
-    datasetItemId: job.job_input_dataset_item_id ?? undefined,
-    variableMapping: parsedVariableMapping,
-  });
-
-  logger.debug(
-    `Evaluating job ${event.jobExecutionId} extracted variables ${JSON.stringify(mappingResult)} `,
-  );
-
-  // Get environment from trace or observation variables
-  const environment = mappingResult.find((r) => r.environment)?.environment;
-
-  // compile the prompt and send out the LLM request
-  let prompt;
-  try {
-    prompt = compileHandlebarString(template.prompt, {
-      ...Object.fromEntries(
-        mappingResult.map(({ var: key, value }) => [key, value]),
-      ),
-    });
-  } catch (e) {
-    // in case of a compilation error, we use the original prompt without adding variables.
-    logger.error(
-      `Evaluating job ${event.jobExecutionId} failed to compile prompt. Eval will fail. ${e}`,
-    );
-    prompt = template.prompt;
-  }
-
-  logger.debug(
-    `Evaluating job ${event.jobExecutionId} compiled prompt ${prompt}`,
-  );
-
-  const parsedOutputSchema = z
-    .object({
-      score: z.string(),
-      reasoning: z.string(),
-    })
-    .parse(template.outputSchema);
-
-  if (!parsedOutputSchema) {
-    throw new InvalidRequestError("Output schema not found");
-  }
-
-  const evalScoreSchema = z.object({
-    reasoning: z.string().describe(parsedOutputSchema.reasoning),
-    score: z.number().describe(parsedOutputSchema.score),
-  });
-
-  const modelParams = ZodModelConfig.parse(template.modelParams);
-
-  // the apiKey.secret_key must never be printed to the console or returned to the client.
-  const apiKey = await prisma.llmApiKeys.findFirst({
-    where: {
-      projectId: event.projectId,
-      provider: template.provider,
-    },
-  });
-  const parsedKey = LLMApiKeySchema.safeParse(apiKey);
-
-  if (!parsedKey.success) {
-    // this will fail the eval execution if a user deletes the API key.
-    logger.error(
-      `Evaluating job ${event.jobExecutionId} did not find API key for provider ${template.provider} and project ${event.projectId}. Eval will fail. ${parsedKey.error}`,
-    );
-    throw new LangfuseNotFoundError(
-      `API key for provider ${template.provider} and project ${event.projectId} not found.`,
-    );
-  }
-
-  const messages = [
-    {
-      type: ChatMessageType.User,
-      role: ChatMessageRole.User,
-      content: prompt,
-    } as const,
-  ];
-
-  const parsedLLMOutput = await backOff(
-    async () =>
-      await callStructuredLLM(
-        event.jobExecutionId,
-        parsedKey.data,
-        messages,
-        modelParams,
-        template.provider,
-        template.model,
-        evalScoreSchema,
-      ),
-    {
-      numOfAttempts: 1, // turn off retries as Langchain is doing that for us already.
-    },
-  );
-
-  logger.debug(
-    `Evaluating job ${event.jobExecutionId} Parsed LLM output ${JSON.stringify(parsedLLMOutput)}`,
-  );
-
-  // persist the score and update the job status
-  const scoreId = randomUUID();
-
-  const baseScore = {
-    id: scoreId,
-    traceId: job.job_input_trace_id,
-    observationId: job.job_input_observation_id,
-    name: config.score_name,
-    value: parsedLLMOutput.score,
-    comment: parsedLLMOutput.reasoning,
-    source: ScoreSource.EVAL,
-    environment: environment ?? "default",
-  };
-
-  // Write score to S3 and ingest into queue for Clickhouse processing
-  try {
-    const eventId = randomUUID();
-    const bucketPath = `${env.LANGFUSE_S3_EVENT_UPLOAD_PREFIX}${event.projectId}/score/${scoreId}/${eventId}.json`;
-    await getS3StorageServiceClient(
-      env.LANGFUSE_S3_EVENT_UPLOAD_BUCKET,
-    ).uploadJson(bucketPath, [
-      {
-        id: eventId,
-        timestamp: new Date().toISOString(),
-        type: eventTypes.SCORE_CREATE,
-        body: {
-          ...baseScore,
-          dataType: "NUMERIC",
-        },
-      },
-    ]);
-
-    if (redis) {
-      const queue = IngestionQueue.getInstance();
-      if (!queue) {
-        throw new Error("Ingestion queue not available");
-      }
-      await queue.add(QueueJobs.IngestionJob, {
-        id: randomUUID(),
-        timestamp: new Date(),
-        name: QueueJobs.IngestionJob as const,
-        payload: {
-          data: {
-            type: eventTypes.SCORE_CREATE,
-            eventBodyId: scoreId,
-            fileKey: eventId,
-          },
-          authCheck: {
-            validKey: true,
-            scope: {
-              projectId: event.projectId,
-              accessLevel: "scores",
-            },
-          },
-        },
-      });
-    }
-  } catch (e) {
-    logger.error(`Failed to add score into IngestionQueue: ${e}`, e);
-    traceException(e);
-    throw new Error(`Failed to write score ${scoreId} into IngestionQueue`);
-  }
-
-  logger.debug(
-    `Evaluating job ${event.jobExecutionId} persisted score ${scoreId} for trace ${job.job_input_trace_id}`,
-  );
-
-  await kyselyPrisma.$kysely
-    .updateTable("job_executions")
-    .set("status", sql`'COMPLETED'::"JobExecutionStatus"`)
-    .set("end_time", new Date())
-    .set("job_output_score_id", scoreId)
-    .where("id", "=", event.jobExecutionId)
-    .execute();
-
-  logger.debug(
-    `Eval job ${job.id} for project ${event.projectId} completed with score ${parsedLLMOutput.score}`,
-  );
-};
-
-export async function extractVariablesFromTracingData({
-  projectId,
-  variables,
-  traceId,
-  variableMapping,
-  datasetItemId,
-}: {
-  projectId: string;
-  variables: string[];
-  traceId: string;
-  // this here are variables which were inserted by users. Need to validate before DB query.
-  variableMapping: z.infer<typeof variableMappingList>;
-  datasetItemId?: string;
-}): Promise<{ var: string; value: string; environment?: string }[]> {
-  return Promise.all(
-    variables.map(async (variable) => {
-      const mapping = variableMapping.find(
-        (m) => m.templateVariable === variable,
-      );
-
-      if (!mapping) {
-        logger.debug(`No mapping found for variable ${variable}`);
-        return { var: variable, value: "" };
-      }
-
-      if (mapping.langfuseObject === "dataset_item") {
-        if (!datasetItemId) {
-          logger.error(
-            `No dataset item id found for variable ${variable}. Eval will succeed without dataset item input.`,
-          );
-          return { var: variable, value: "" };
-        }
-
-        // find the internal definitions of the column
-        const safeInternalColumn = availableDatasetEvalVariables
-          .find((o) => o.id === "dataset_item")
-          ?.availableColumns.find((col) => col.id === mapping.selectedColumnId);
-
-        // if no column was found, we still process with an empty variable
-        if (!safeInternalColumn?.id) {
-          logger.error(
-            `No column found for variable ${variable} and column ${mapping.selectedColumnId}`,
-          );
-          return { var: variable, value: "" };
-        }
-
-        const datasetItem = await kyselyPrisma.$kysely
-          .selectFrom("dataset_items as d")
-          .select(
-            sql`${sql.raw(safeInternalColumn.internal)}`.as(
-              safeInternalColumn.id,
-            ),
-          ) // query the internal column name raw
-          .where("id", "=", datasetItemId)
-          .where("project_id", "=", projectId)
-          .executeTakeFirst();
-
-        // user facing errors
-        if (!datasetItem) {
-          logger.error(
-            `Dataset item ${datasetItemId} for project ${projectId} not found. Eval will succeed without dataset item input. Please ensure the mapped data on the dataset item exists and consider extending the job delay.`,
-          );
-          throw new LangfuseNotFoundError(
-            `Dataset item ${datasetItemId} for project ${projectId} not found. Eval will succeed without dataset item input. Please ensure the mapped data on the dataset item exists and consider extending the job delay.`,
-          );
-        }
-
-        return {
-          var: variable,
-          value: parseDatabaseRowToString(datasetItem, mapping),
-        };
-      }
-
-      if (mapping.langfuseObject === "trace") {
-        // find the internal definitions of the column
-        const safeInternalColumn = availableTraceEvalVariables
-          .find((o) => o.id === "trace")
-          ?.availableColumns.find((col) => col.id === mapping.selectedColumnId);
-
-        // if no column was found, we still process with an empty variable
-        if (!safeInternalColumn?.id) {
-          logger.error(
-            `No column found for variable ${variable} and column ${mapping.selectedColumnId}`,
-          );
-          return { var: variable, value: "" };
-        }
-
-        const trace = await getTraceById(traceId, projectId);
-
-        // user facing errors
-        if (!trace) {
-          logger.error(
-            `Trace ${traceId} for project ${projectId} not found. Eval will succeed without trace input. Please ensure the mapped data on the trace exists and consider extending the job delay.`,
-          );
-          throw new LangfuseNotFoundError(
-            `Trace ${traceId} for project ${projectId} not found. Eval will succeed without trace input. Please ensure the mapped data on the trace exists and consider extending the job delay.`,
-          );
-        }
-
-        return {
-          var: variable,
-          value: parseDatabaseRowToString(trace, mapping),
-          environment: trace.environment,
-        };
-      }
-
-      if (["generation", "span", "event"].includes(mapping.langfuseObject)) {
-        const safeInternalColumn = availableTraceEvalVariables
-          .find((o) => o.id === mapping.langfuseObject)
-          ?.availableColumns.find((col) => col.id === mapping.selectedColumnId);
-
-        if (!mapping.objectName) {
-          logger.info(
-            `No object name found for variable ${variable} and object ${mapping.langfuseObject}`,
-          );
-          return { var: variable, value: "" };
-        }
-
-        if (!safeInternalColumn?.id) {
-          logger.warn(
-            `No column found for variable ${variable} and column ${mapping.selectedColumnId}`,
-          );
-          return { var: variable, value: "" };
-        }
-
-        const observation = (
-          await getObservationForTraceIdByName(
-            traceId,
-            projectId,
-            mapping.objectName,
-            undefined,
-            true,
-          )
-        ).shift(); // We only take the first match and ignore duplicate generation-names in a trace.
-
-        // user facing errors
-        if (!observation) {
-          logger.error(
-            `Observation ${mapping.objectName} for trace ${traceId} not found. Please ensure the mapped data exists and consider extending the job delay.`,
-          );
-          throw new LangfuseNotFoundError(
-            `Observation ${mapping.objectName} for trace ${traceId} not found. Please ensure the mapped data exists and consider extending the job delay.`,
-          );
-        }
-
-        return {
-          var: variable,
-          value: parseDatabaseRowToString(observation, mapping),
-          environment: observation.environment,
-        };
-      }
-
-      throw new Error(`Unknown object type ${mapping.langfuseObject}`);
-    }),
-  );
-}
-
-export const parseDatabaseRowToString = (
-  dbRow: Record<string, unknown>,
-  mapping: z.infer<typeof variableMapping>,
-): string => {
-  const selectedColumn = dbRow[mapping.selectedColumnId];
-
-  let jsonSelectedColumn;
-  if (mapping.jsonSelector) {
-    logger.debug(
-      `Parsing JSON for json selector ${mapping.jsonSelector} from ${JSON.stringify(selectedColumn)}`,
-    );
-    try {
-      jsonSelectedColumn = JSONPath({
-        path: mapping.jsonSelector,
-        json:
-          typeof selectedColumn === "string"
-            ? JSON.parse(selectedColumn)
-            : selectedColumn,
-      });
-    } catch (error) {
-      logger.error(
-        `Error parsing JSON for json selector ${mapping.jsonSelector}. Falling back to original value.`,
-        error,
-      );
-      jsonSelectedColumn = selectedColumn;
-    }
-  } else {
-    jsonSelectedColumn = selectedColumn;
-  }
-
-  return parseUnknownToString(jsonSelectedColumn);
-};
-
-export const parseUnknownToString = (value: unknown): string => {
-  if (value === null || value === undefined) {
-    return "";
-  }
-  if (
-    typeof value === "string" ||
-    typeof value === "number" ||
-    typeof value === "boolean"
-  ) {
-    return value.toString();
-  }
-  if (typeof value === "object") {
-    return JSON.stringify(value);
-  }
-  if (typeof value === "symbol") {
-    return value.toString();
-  }
-
-  return String(value);
-};
diff --git a/worker/src/ee/experiments/experimentService.ts b/worker/src/ee/experiments/experimentService.ts
deleted file mode 100644
index cc3302a..0000000
--- a/worker/src/ee/experiments/experimentService.ts
+++ /dev/null
@@ -1,326 +0,0 @@
-import { z } from "zod";
-import {
-  ChatMessageRole,
-  LLMApiKeySchema,
-  logger,
-  PromptContent,
-  ExperimentMetadataSchema,
-  PromptContentSchema,
-  DatasetRunItemUpsertQueue,
-  ChatMessageType,
-  ChatMessage,
-} from "@langfuse/shared/src/server";
-import { kyselyPrisma, prisma } from "@langfuse/shared/src/db";
-import { ExperimentCreateEventSchema } from "@langfuse/shared/src/server";
-import {
-  InvalidRequestError,
-  LangfuseNotFoundError,
-  Prisma,
-  extractVariables,
-  datasetItemMatchesVariable,
-  stringifyValue,
-} from "@langfuse/shared";
-import { backOff } from "exponential-backoff";
-import { callLLM } from "../../features/utilities";
-import { QueueJobs, redis } from "@langfuse/shared/src/server";
-import { randomUUID } from "crypto";
-import { v4 } from "uuid";
-import { compileHandlebarString } from "../../features/utilities";
-import { DatasetStatus } from "../../../../packages/shared/dist/prisma/generated/types";
-
-const isValidPrismaJsonObject = (
-  input: Prisma.JsonValue,
-): input is Prisma.JsonObject =>
-  typeof input === "object" &&
-  input !== null &&
-  input !== undefined &&
-  !Array.isArray(input);
-
-const replaceVariablesInPrompt = (
-  prompt: PromptContent,
-  itemInput: Record<string, any>,
-  variables: string[],
-): ChatMessage[] => {
-  const processContent = (content: string) => {
-    // Extract only relevant variables from itemInput
-    const filteredContext = Object.fromEntries(
-      Object.entries(itemInput).filter(([key]) => variables.includes(key)),
-    );
-
-    // Apply Handlebars ONLY if the content contains `{{variable}}` pattern
-    if (content.includes("{{")) {
-      return compileHandlebarString(content, filteredContext);
-    }
-
-    return content; // Return original content if no placeholders are found
-  };
-
-  if (typeof prompt === "string") {
-    return [
-      {
-        role: ChatMessageRole.System,
-        content: processContent(prompt),
-        type: ChatMessageType.System as const,
-      },
-    ];
-  } else {
-    return prompt.map((message) => ({
-      ...message,
-      content: processContent(message.content),
-      type: ChatMessageType.PublicAPICreated as const,
-    }));
-  }
-};
-
-const validateDatasetItem = (
-  itemInput: Prisma.JsonValue,
-  variables: string[],
-): itemInput is Prisma.JsonObject => {
-  if (!isValidPrismaJsonObject(itemInput)) {
-    return false;
-  }
-  return variables.some((variable) =>
-    datasetItemMatchesVariable(itemInput, variable),
-  );
-};
-
-const parseDatasetItemInput = (
-  itemInput: Prisma.JsonObject,
-  variables: string[],
-): Prisma.JsonObject => {
-  try {
-    const filteredInput = Object.fromEntries(
-      Object.entries(itemInput)
-        .filter(([key]) => variables.includes(key))
-        .map(([key, value]) => [
-          key,
-          value === null ? null : stringifyValue(value),
-        ]),
-    );
-    return filteredInput;
-  } catch (error) {
-    logger.info("Error parsing dataset item input:", error);
-    return itemInput;
-  }
-};
-
-const fetchDatasetRun = async (datasetRunId: string, projectId: string) => {
-  return await kyselyPrisma.$kysely
-    .selectFrom("dataset_runs")
-    .selectAll()
-    .where("id", "=", datasetRunId)
-    .where("project_id", "=", projectId)
-    .executeTakeFirst();
-};
-
-const fetchPrompt = async (promptId: string, projectId: string) => {
-  return await kyselyPrisma.$kysely
-    .selectFrom("prompts")
-    .selectAll()
-    .where("id", "=", promptId)
-    .where("project_id", "=", projectId)
-    .executeTakeFirst();
-};
-
-export const createExperimentJob = async ({
-  event,
-}: {
-  event: z.infer<typeof ExperimentCreateEventSchema>;
-}) => {
-  logger.info("Processing experiment create job", event);
-  const { datasetId, projectId, runId } = event;
-
-  /********************
-   * INPUT VALIDATION *
-   ********************/
-
-  const datasetRun = await fetchDatasetRun(runId, projectId);
-  if (!datasetRun) {
-    throw new LangfuseNotFoundError(`Dataset run ${runId} not found`);
-  }
-
-  const validatedRunMetadata = ExperimentMetadataSchema.safeParse(
-    datasetRun.metadata,
-  );
-  if (!validatedRunMetadata.success) {
-    throw new InvalidRequestError(
-      "Langfuse in-app experiments can only be run with prompt and model configurations in metadata.",
-    );
-  }
-
-  const { prompt_id, provider, model, model_params } =
-    validatedRunMetadata.data;
-  const prompt = await fetchPrompt(prompt_id, projectId);
-
-  if (!prompt) {
-    throw new LangfuseNotFoundError(`Prompt ${prompt_id} not found`);
-  }
-
-  const validatedPrompt = PromptContentSchema.safeParse(prompt.prompt);
-  if (!validatedPrompt.success) {
-    throw new InvalidRequestError(
-      `Prompt ${prompt_id} not found in expected format`,
-    );
-  }
-
-  // fetch and validate API key
-  const apiKey = await prisma.llmApiKeys.findFirst({
-    where: {
-      projectId: event.projectId,
-      provider,
-    },
-  });
-  if (!apiKey) {
-    throw new LangfuseNotFoundError(
-      `API key for provider ${provider} not found`,
-    );
-  }
-  const validatedApiKey = LLMApiKeySchema.safeParse(apiKey);
-  if (!validatedApiKey.success) {
-    throw new InvalidRequestError(
-      `API key for provider ${provider} not found.`,
-    );
-  }
-
-  // fetch dataset items
-  const datasetItems = await prisma.datasetItem.findMany({
-    where: {
-      datasetId,
-      projectId,
-      status: DatasetStatus.ACTIVE,
-    },
-    orderBy: {
-      createdAt: "desc",
-    },
-  });
-
-  // extract variables from prompt
-  const extractedVariables = extractVariables(
-    prompt?.type === "text"
-      ? (prompt.prompt?.toString() ?? "")
-      : JSON.stringify(prompt.prompt),
-  );
-
-  // validate dataset items against prompt configuration
-  const validatedDatasetItems = datasetItems
-    .filter(({ input }) => validateDatasetItem(input, extractedVariables))
-    .map((datasetItem) => ({
-      ...datasetItem,
-      input: parseDatasetItemInput(
-        datasetItem.input as Prisma.JsonObject, // this is safe because we already filtered for valid input
-        extractedVariables,
-      ),
-    }));
-
-  if (!validatedDatasetItems.length) {
-    throw new InvalidRequestError(
-      `No Dataset ${datasetId} item input matches expected prompt variable format`,
-    );
-  }
-
-  for (const datasetItem of validatedDatasetItems) {
-    // dedupe and skip if dataset run item already exists
-    const existingRunItem = await kyselyPrisma.$kysely
-      .selectFrom("dataset_run_items")
-      .selectAll()
-      .where("project_id", "=", projectId)
-      .where("dataset_item_id", "=", datasetItem.id)
-      .where("dataset_run_id", "=", runId)
-      .executeTakeFirst();
-
-    if (existingRunItem) {
-      logger.info(
-        `Dataset run item ${existingRunItem.id} already exists, skipping`,
-      );
-      continue;
-    }
-
-    /********************
-     * VARIABLE EXTRACTION *
-     ********************/
-
-    let messages: ChatMessage[] = [];
-    try {
-      messages = replaceVariablesInPrompt(
-        validatedPrompt.data,
-        datasetItem.input, // validated format
-        extractedVariables,
-      );
-    } catch (error) {
-      // skip this dataset item if there is an error replacing variables
-      logger.error(
-        `Error replacing variables in prompt for dataset item ${datasetItem.id}`,
-        error,
-      );
-      continue;
-    }
-
-    /********************
-     * RUN ITEM CREATION *
-     ********************/
-
-    const newTraceId = v4();
-
-    const runItem = await prisma.datasetRunItems.create({
-      data: {
-        datasetItemId: datasetItem.id,
-        traceId: newTraceId,
-        datasetRunId: runId,
-        projectId,
-      },
-    });
-
-    /********************
-     * LLM MODEL CALL *
-     ********************/
-
-    const traceParams = {
-      tags: ["langfuse-prompt-experiment"], // LFE-2917: filter out any trace in trace upsert queue that has this tag set
-      traceName: `dataset-run-item-${runItem.id.slice(0, 5)}`,
-      traceId: newTraceId,
-      projectId: event.projectId,
-      authCheck: {
-        validKey: true as const,
-        scope: {
-          projectId: event.projectId,
-          accessLevel: "all",
-        } as any,
-      },
-    };
-
-    await backOff(
-      async () =>
-        await callLLM(
-          validatedApiKey.data,
-          messages,
-          model_params,
-          provider,
-          model,
-          traceParams,
-        ),
-      {
-        numOfAttempts: 1, // turn off retries as Langchain is doing that for us already.
-      },
-    );
-
-    /********************
-     * ASYNC RUN ITEM EVAL *
-     ********************/
-
-    if (redis) {
-      const queue = DatasetRunItemUpsertQueue.getInstance();
-      if (queue) {
-        await queue.add(QueueJobs.DatasetRunItemUpsert, {
-          payload: {
-            projectId,
-            datasetItemId: datasetItem.id,
-            traceId: newTraceId,
-          },
-          id: randomUUID(),
-          timestamp: new Date(),
-          name: QueueJobs.DatasetRunItemUpsert as const,
-        });
-      }
-    }
-  }
-};
diff --git a/worker/src/ee/integrations/blobstorage/handleBlobStorageIntegrationProjectJob.ts b/worker/src/ee/integrations/blobstorage/handleBlobStorageIntegrationProjectJob.ts
deleted file mode 100644
index 01d91eb..0000000
--- a/worker/src/ee/integrations/blobstorage/handleBlobStorageIntegrationProjectJob.ts
+++ /dev/null
@@ -1,238 +0,0 @@
-import { pipeline } from "stream";
-import { Job } from "bullmq";
-import { prisma } from "@langfuse/shared/src/db";
-import {
-  QueueName,
-  TQueueJobTypes,
-  logger,
-  StorageService,
-  StorageServiceFactory,
-  streamTransformations,
-  getObservationsForBlobStorageExport,
-  getTracesForBlobStorageExport,
-  getScoresForBlobStorageExport,
-} from "@langfuse/shared/src/server";
-import {
-  BlobStorageIntegrationType,
-  BlobStorageIntegrationFileType,
-} from "@langfuse/shared";
-import { decrypt } from "@langfuse/shared/encryption";
-
-const getFileTypeProperties = (fileType: BlobStorageIntegrationFileType) => {
-  switch (fileType) {
-    case BlobStorageIntegrationFileType.JSON:
-      return {
-        contentType: "application/json",
-        extension: "json",
-      };
-    case BlobStorageIntegrationFileType.CSV:
-      return {
-        contentType: "text/csv",
-        extension: "csv",
-      };
-    case BlobStorageIntegrationFileType.JSONL:
-      return {
-        contentType: "application/x-ndjson",
-        extension: "jsonl",
-      };
-    default:
-      // eslint-disable-next-line no-case-declarations, no-unused-vars
-      const exhaustiveCheck: never = fileType;
-      throw new Error(`Unsupported file type: ${fileType}`);
-  }
-};
-
-const processBlobStorageExport = async (config: {
-  projectId: string;
-  minTimestamp: Date;
-  maxTimestamp: Date;
-  bucketName: string;
-  endpoint: string | null;
-  region?: string;
-  accessKeyId: string;
-  secretAccessKey: string;
-  prefix?: string;
-  forcePathStyle?: boolean;
-  type: BlobStorageIntegrationType;
-  table: "traces" | "observations" | "scores";
-  fileType: BlobStorageIntegrationFileType;
-}) => {
-  logger.info(
-    `Processing ${config.table} export for project ${config.projectId}`,
-  );
-
-  // Initialize the storage service
-  const storageService: StorageService = StorageServiceFactory.getInstance({
-    accessKeyId: config.accessKeyId,
-    secretAccessKey: config.secretAccessKey,
-    bucketName: config.bucketName,
-    endpoint: config.endpoint ?? undefined,
-    region: config.region,
-    forcePathStyle: config.forcePathStyle ?? false,
-    useAzureBlob: config.type === BlobStorageIntegrationType.AZURE_BLOB_STORAGE,
-  });
-
-  try {
-    const blobStorageProps = getFileTypeProperties(config.fileType);
-
-    // Create the file path with prefix if available
-    const timestamp = config.maxTimestamp
-      .toISOString()
-      .replace(/:/g, "-")
-      .substring(0, 19);
-    const filePath = `${config.prefix ?? ""}${config.projectId}/${config.table}/${timestamp}.${blobStorageProps.extension}`;
-
-    // Fetch data based on table type
-    let dataStream: AsyncGenerator<Record<string, unknown>>;
-
-    switch (config.table) {
-      case "traces":
-        dataStream = getTracesForBlobStorageExport(
-          config.projectId,
-          config.minTimestamp,
-          config.maxTimestamp,
-        );
-        break;
-      case "observations":
-        dataStream = getObservationsForBlobStorageExport(
-          config.projectId,
-          config.minTimestamp,
-          config.maxTimestamp,
-        );
-        break;
-      case "scores":
-        dataStream = getScoresForBlobStorageExport(
-          config.projectId,
-          config.minTimestamp,
-          config.maxTimestamp,
-        );
-        break;
-      default:
-        throw new Error(`Unsupported table type: ${config.table}`);
-    }
-
-    const fileStream = pipeline(
-      dataStream,
-      streamTransformations[config.fileType](),
-      (err) => {
-        if (err) {
-          logger.error(
-            "Getting data from DB for blob storage integration failed: ",
-            err,
-          );
-        }
-      },
-    );
-
-    // Upload the file to cloud storage
-    await storageService.uploadFile({
-      fileName: filePath,
-      fileType: blobStorageProps.contentType,
-      data: fileStream,
-      expiresInSeconds: 3600, // 1 hour expiry for the signed URL - is ignored
-    });
-
-    logger.info(
-      `Successfully exported ${config.table} records for project ${config.projectId}`,
-    );
-  } catch (error) {
-    logger.error(
-      `Error exporting ${config.table} for project ${config.projectId}`,
-      error,
-    );
-    throw error;
-  }
-};
-
-export const handleBlobStorageIntegrationProjectJob = async (
-  job: Job<TQueueJobTypes[QueueName.BlobStorageIntegrationProcessingQueue]>,
-) => {
-  const { projectId } = job.data.payload;
-
-  logger.info(`Processing blob storage integration for project ${projectId}`);
-
-  const blobStorageIntegration = await prisma.blobStorageIntegration.findUnique(
-    {
-      where: {
-        projectId,
-      },
-    },
-  );
-
-  if (!blobStorageIntegration) {
-    logger.warn(`Blob storage integration not found for project ${projectId}`);
-    return;
-  }
-  if (!blobStorageIntegration.enabled) {
-    logger.info(
-      `Blob storage integration is disabled for project ${projectId}`,
-    );
-    return;
-  }
-
-  // Sync between lastSyncAt and now - 30 minutes
-  const minTimestamp = blobStorageIntegration.lastSyncAt || new Date(0);
-  const maxTimestamp = new Date(new Date().getTime() - 30 * 60 * 1000);
-
-  try {
-    // Process the export based on the integration configuration
-    const executionConfig = {
-      projectId,
-      minTimestamp,
-      maxTimestamp,
-      bucketName: blobStorageIntegration.bucketName,
-      endpoint: blobStorageIntegration.endpoint,
-      region: blobStorageIntegration.region || undefined,
-      accessKeyId: blobStorageIntegration.accessKeyId,
-      secretAccessKey: decrypt(blobStorageIntegration.secretAccessKey),
-      prefix: blobStorageIntegration.prefix || undefined,
-      forcePathStyle: blobStorageIntegration.forcePathStyle || undefined,
-      type: blobStorageIntegration.type,
-      fileType: blobStorageIntegration.fileType,
-    };
-
-    await Promise.all([
-      processBlobStorageExport({ ...executionConfig, table: "traces" }),
-      processBlobStorageExport({ ...executionConfig, table: "observations" }),
-      processBlobStorageExport({ ...executionConfig, table: "scores" }),
-    ]);
-
-    let nextSyncAt: Date;
-    switch (blobStorageIntegration.exportFrequency) {
-      case "hourly":
-        nextSyncAt = new Date(maxTimestamp.getTime() + 60 * 60 * 1000);
-        break;
-      case "daily":
-        nextSyncAt = new Date(maxTimestamp.getTime() + 24 * 60 * 60 * 1000);
-        break;
-      case "weekly":
-        nextSyncAt = new Date(maxTimestamp.getTime() + 7 * 24 * 60 * 60 * 1000);
-        break;
-      default:
-        throw new Error(
-          `Unsupported export frequency ${blobStorageIntegration.exportFrequency}`,
-        );
-    }
-
-    // Update integration after successful processing
-    await prisma.blobStorageIntegration.update({
-      where: {
-        projectId,
-      },
-      data: {
-        lastSyncAt: maxTimestamp,
-        nextSyncAt,
-      },
-    });
-
-    logger.info(
-      `Successfully processed blob storage integration for project ${projectId}`,
-    );
-  } catch (error) {
-    logger.error(
-      `Error processing blob storage integration for project ${projectId}`,
-      error,
-    );
-    throw error; // Rethrow to trigger retries
-  }
-};
diff --git a/worker/src/ee/integrations/blobstorage/handleBlobStorageIntegrationSchedule.ts b/worker/src/ee/integrations/blobstorage/handleBlobStorageIntegrationSchedule.ts
deleted file mode 100644
index ac796ed..0000000
--- a/worker/src/ee/integrations/blobstorage/handleBlobStorageIntegrationSchedule.ts
+++ /dev/null
@@ -1,62 +0,0 @@
-import { Job } from "bullmq";
-import { prisma } from "@langfuse/shared/src/db";
-import {
-  BlobStorageIntegrationProcessingQueue,
-  QueueJobs,
-  logger,
-} from "@langfuse/shared/src/server";
-import { randomUUID } from "crypto";
-
-export const handleBlobStorageIntegrationSchedule = async (job: Job) => {
-  const now = new Date();
-
-  const blobStorageIntegrationProjects =
-    await prisma.blobStorageIntegration.findMany({
-      select: {
-        lastSyncAt: true,
-        projectId: true,
-      },
-      where: {
-        enabled: true,
-        OR: [
-          // Never synced before
-          { lastSyncAt: null },
-          // Next sync is due
-          { nextSyncAt: { lte: now } },
-        ],
-      },
-    });
-
-  if (blobStorageIntegrationProjects.length === 0) {
-    logger.info("No blob storage integrations ready for sync");
-    return;
-  }
-
-  const blobStorageIntegrationProcessingQueue =
-    BlobStorageIntegrationProcessingQueue.getInstance();
-  if (!blobStorageIntegrationProcessingQueue) {
-    throw new Error("BlobStorageIntegrationProcessingQueue not initialized");
-  }
-
-  logger.info(
-    `Scheduling ${blobStorageIntegrationProjects.length} blob storage integrations for sync`,
-  );
-
-  await blobStorageIntegrationProcessingQueue.addBulk(
-    blobStorageIntegrationProjects.map((integration) => ({
-      name: QueueJobs.BlobStorageIntegrationProcessingJob,
-      data: {
-        id: randomUUID(),
-        name: QueueJobs.BlobStorageIntegrationProcessingJob,
-        timestamp: new Date(),
-        payload: {
-          projectId: integration.projectId,
-        },
-      },
-      opts: {
-        // Use projectId and last sync as jobId to prevent duplicate jobs.
-        jobId: `${integration.projectId}-${integration.lastSyncAt?.toISOString() ?? ""}`,
-      },
-    })),
-  );
-};
diff --git a/worker/src/ee/integrations/posthog/handlePostHogIntegrationProjectJob.ts b/worker/src/ee/integrations/posthog/handlePostHogIntegrationProjectJob.ts
deleted file mode 100644
index a429790..0000000
--- a/worker/src/ee/integrations/posthog/handlePostHogIntegrationProjectJob.ts
+++ /dev/null
@@ -1,194 +0,0 @@
-import { Job } from "bullmq";
-import { prisma } from "@langfuse/shared/src/db";
-import {
-  QueueName,
-  TQueueJobTypes,
-  logger,
-  getTracesForPostHog,
-  getGenerationsForPostHog,
-  getScoresForPostHog,
-} from "@langfuse/shared/src/server";
-import { v5 } from "uuid";
-import { decrypt } from "@langfuse/shared/encryption";
-import { PostHog } from "posthog-node";
-
-type PostHogExecutionConfig = {
-  projectId: string;
-  minTimestamp: Date;
-  maxTimestamp: Date;
-  decryptedPostHogApiKey: string;
-  postHogHost: string;
-};
-
-const POSTHOG_UUID_NAMESPACE = "0f6c91df-d035-4813-b838-9741ba38ef0b";
-
-const processPostHogTraces = async (config: PostHogExecutionConfig) => {
-  const postHogTraces = getTracesForPostHog(
-    config.projectId,
-    config.minTimestamp,
-    config.maxTimestamp,
-  );
-
-  logger.info(`Sending traces for project ${config.projectId} to PostHog`);
-
-  // Send each via PostHog SDK
-  const posthog = new PostHog(config.decryptedPostHogApiKey, {
-    host: config.postHogHost,
-  });
-
-  let count = 0;
-  for await (const trace of postHogTraces) {
-    count++;
-    posthog.capture({
-      distinctId: trace.langfuse_user_id as string,
-      event: "langfuse trace",
-      properties: trace,
-      timestamp: trace.timestamp as Date,
-      uuid: v5(
-        `${config.projectId}-${trace.langfuse_id}`,
-        POSTHOG_UUID_NAMESPACE,
-      ),
-    });
-    if (count % 10000 === 0) {
-      await posthog.flush();
-      logger.info(
-        `Sent ${count} traces to PostHog for project ${config.projectId}`,
-      );
-    }
-  }
-  await posthog.flush();
-  logger.info(
-    `Sent ${count} traces to PostHog for project ${config.projectId}`,
-  );
-};
-
-const processPostHogGenerations = async (config: PostHogExecutionConfig) => {
-  const postHogGenerations = getGenerationsForPostHog(
-    config.projectId,
-    config.minTimestamp,
-    config.maxTimestamp,
-  );
-
-  logger.info(`Sending generations for project ${config.projectId} to PostHog`);
-
-  // Send each via PostHog SDK
-  const posthog = new PostHog(config.decryptedPostHogApiKey, {
-    host: config.postHogHost,
-  });
-
-  let count = 0;
-  for await (const generation of postHogGenerations) {
-    count++;
-    posthog.capture({
-      distinctId: generation.langfuse_user_id as string,
-      event: "langfuse generation",
-      properties: generation,
-      timestamp: generation.timestamp as Date,
-      uuid: v5(
-        `${config.projectId}-${generation.langfuse_id}`,
-        POSTHOG_UUID_NAMESPACE,
-      ),
-    });
-    if (count % 10000 === 0) {
-      await posthog.flush();
-      logger.info(
-        `Sent ${count} generations to PostHog for project ${config.projectId}`,
-      );
-    }
-  }
-  await posthog.flush();
-  logger.info(
-    `Sent ${count} generations to PostHog for project ${config.projectId}`,
-  );
-};
-
-const processPostHogScores = async (config: PostHogExecutionConfig) => {
-  const postHogScores = getScoresForPostHog(
-    config.projectId,
-    config.minTimestamp,
-    config.maxTimestamp,
-  );
-
-  logger.info(`Sending scores for project ${config.projectId} to PostHog`);
-
-  // Send each via PostHog SDK
-  const posthog = new PostHog(config.decryptedPostHogApiKey, {
-    host: config.postHogHost,
-  });
-
-  let count = 0;
-  for await (const score of postHogScores) {
-    count++;
-    posthog.capture({
-      distinctId: score.langfuse_user_id as string,
-      event: "langfuse score",
-      properties: score,
-      timestamp: score.timestamp as Date,
-      uuid: v5(
-        `${config.projectId}-${score.langfuse_id}`,
-        POSTHOG_UUID_NAMESPACE,
-      ),
-    });
-    if (count % 10000 === 0) {
-      await posthog.flush();
-      logger.info(
-        `Sent ${count} scores to PostHog for project ${config.projectId}`,
-      );
-    }
-  }
-  await posthog.flush();
-  logger.info(
-    `Sent ${count} scores to PostHog for project ${config.projectId}`,
-  );
-};
-
-export const handlePostHogIntegrationProjectJob = async (
-  job: Job<TQueueJobTypes[QueueName.PostHogIntegrationProcessingQueue]>,
-) => {
-  const projectId = job.data.payload.projectId;
-  logger.info(`Processing PostHog integration for project ${projectId}`);
-
-  // Fetch PostHog integration information for project
-  const postHogIntegration = await prisma.posthogIntegration.findFirst({
-    where: {
-      projectId,
-      enabled: true,
-    },
-  });
-
-  if (!postHogIntegration) {
-    logger.warn(
-      `Enabled PostHog integration not found for project ${projectId}`,
-    );
-    return;
-  }
-
-  // Fetch relevant data and send it to PostHog
-  const executionConfig: PostHogExecutionConfig = {
-    projectId,
-    // Start from 2000-01-01 if no lastSyncAt. Workaround because 1970-01-01 leads to subtle bugs in ClickHouse
-    minTimestamp: postHogIntegration.lastSyncAt || new Date("2000-01-01"),
-    maxTimestamp: new Date(new Date().getTime() - 30 * 60 * 1000), // 30 minutes ago
-    decryptedPostHogApiKey: decrypt(postHogIntegration.encryptedPosthogApiKey),
-    postHogHost: postHogIntegration.posthogHostName,
-  };
-
-  await Promise.all([
-    processPostHogTraces(executionConfig),
-    processPostHogGenerations(executionConfig),
-    processPostHogScores(executionConfig),
-  ]);
-
-  // Update the last run information for the postHogIntegration record
-  await prisma.posthogIntegration.update({
-    where: {
-      projectId,
-    },
-    data: {
-      lastSyncAt: executionConfig.maxTimestamp,
-    },
-  });
-  logger.info(
-    `PostHog integration processing complete for project ${projectId}`,
-  );
-};
diff --git a/worker/src/ee/integrations/posthog/handlePostHogIntegrationSchedule.ts b/worker/src/ee/integrations/posthog/handlePostHogIntegrationSchedule.ts
deleted file mode 100644
index 7d25d54..0000000
--- a/worker/src/ee/integrations/posthog/handlePostHogIntegrationSchedule.ts
+++ /dev/null
@@ -1,43 +0,0 @@
-import { Job } from "bullmq";
-import { prisma } from "@langfuse/shared/src/db";
-import {
-  PostHogIntegrationProcessingQueue,
-  QueueJobs,
-} from "@langfuse/shared/src/server";
-import { randomUUID } from "crypto";
-
-export const handlePostHogIntegrationSchedule = async (job: Job) => {
-  const postHogIntegrationProjects = await prisma.posthogIntegration.findMany({
-    select: {
-      lastSyncAt: true,
-      projectId: true,
-    },
-    where: {
-      enabled: true,
-    },
-  });
-
-  const postHogIntegrationProcessingQueue =
-    PostHogIntegrationProcessingQueue.getInstance();
-  if (!postHogIntegrationProcessingQueue) {
-    throw new Error("PostHogIntegrationProcessingQueue not initialized");
-  }
-
-  await postHogIntegrationProcessingQueue.addBulk(
-    postHogIntegrationProjects.map((integration) => ({
-      name: QueueJobs.PostHogIntegrationProcessingJob,
-      data: {
-        id: randomUUID(),
-        name: QueueJobs.PostHogIntegrationProcessingJob,
-        timestamp: new Date(),
-        payload: {
-          projectId: integration.projectId,
-        },
-      },
-      opts: {
-        // Use projectId and last sync as jobId to prevent duplicate jobs.
-        jobId: `${integration.projectId}-${integration.lastSyncAt?.toISOString() ?? ""}`,
-      },
-    })),
-  );
-};
diff --git a/worker/src/ee/meteringDataPostgresExport/handleMeteringDataPostgresExportJob.ts b/worker/src/ee/meteringDataPostgresExport/handleMeteringDataPostgresExportJob.ts
deleted file mode 100644
index 30019c6..0000000
--- a/worker/src/ee/meteringDataPostgresExport/handleMeteringDataPostgresExportJob.ts
+++ /dev/null
@@ -1,88 +0,0 @@
-import { Job, Processor } from "bullmq";
-import { logger } from "@langfuse/shared/src/server";
-import { Prisma, prisma } from "@langfuse/shared/src/db";
-import { env } from "../../env";
-import Stripe from "stripe";
-import { parseDbOrg } from "@langfuse/shared";
-
-export const meteringDataPostgresExportProcessor: Processor = async (
-  job: Job,
-): Promise<void> => {
-  logger.info(
-    "[METERING POSTGRES EXPORT] Starting metering data Postgres export",
-  );
-
-  if (!env.STRIPE_SECRET_KEY) {
-    logger.warn("[METERING POSTGRES EXPORT] Stripe secret key not found");
-    throw new Error("Stripe secret key not found");
-  }
-
-  // setup stripe client
-  const stripe = new Stripe(env.STRIPE_SECRET_KEY);
-
-  const endTime = Math.floor(new Date().setUTCHours(0, 0, 0, 0) / 1000);
-  const startTime = endTime - 100 * 24 * 60 * 60; // 100 days ago, stripe exports 100 days at a time
-
-  const activeMeters = (await stripe.billing.meters.list()).data.filter(
-    (meter) => meter.status === "active",
-  );
-
-  const billingOrganizations = (
-    await prisma.organization.findMany({
-      where: {
-        cloudConfig: { not: Prisma.DbNull },
-      },
-    })
-  )
-    .map(parseDbOrg)
-    .filter((org) => org.cloudConfig?.stripe?.customerId);
-
-  logger.info(
-    `[METERING POSTGRES EXPORT] Found ${activeMeters.length} meters and ${billingOrganizations.length} organizations`,
-  );
-
-  // purge all existing backups
-  await prisma.billingMeterBackup.deleteMany();
-  logger.debug("[METERING POSTGRES EXPORT] Deleted existing rows in table");
-
-  for (const meter of activeMeters) {
-    for (const org of billingOrganizations) {
-      // type check
-      const stripeCustomerId = org.cloudConfig?.stripe?.customerId;
-      if (!stripeCustomerId) continue;
-
-      try {
-        const eventSummaries = await stripe.billing.meters.listEventSummaries(
-          meter.id,
-          {
-            customer: stripeCustomerId,
-            start_time: startTime,
-            end_time: endTime,
-            limit: 100,
-            value_grouping_window: "day",
-          },
-        );
-
-        await prisma.billingMeterBackup.createMany({
-          data: eventSummaries.data.map((event) => ({
-            orgId: org.id,
-            meterId: meter.id,
-            eventName: meter.event_name,
-            stripeCustomerId,
-            startTime: new Date(event.start_time * 1000),
-            endTime: new Date(event.end_time * 1000),
-            aggregatedValue: event.aggregated_value,
-          })),
-        });
-      } catch (error) {
-        logger.error(
-          `[METERING POSTGRES EXPORT] Error exporting meter ${meter.id} for org ${org.id}: ${error}`,
-        );
-      }
-    }
-  }
-
-  logger.info(
-    "[METERING POSTGRES EXPORT] Finished metering data Postgres export",
-  );
-};
diff --git a/worker/src/queues/blobStorageIntegrationQueue.ts b/worker/src/queues/blobStorageIntegrationQueue.ts
index cc37d3f..6013dfc 100644
--- a/worker/src/queues/blobStorageIntegrationQueue.ts
+++ b/worker/src/queues/blobStorageIntegrationQueue.ts
@@ -1,17 +1,18 @@
 import { Processor } from "bullmq";
 import { QueueJobs, logger } from "@langfuse/shared/src/server";
-import { handleBlobStorageIntegrationSchedule } from "../ee/integrations/blobstorage/handleBlobStorageIntegrationSchedule";
-import { handleBlobStorageIntegrationProjectJob } from "../ee/integrations/blobstorage/handleBlobStorageIntegrationProjectJob";
+// import { handleBlobStorageIntegrationSchedule } from "../ee/integrations/blobstorage/handleBlobStorageIntegrationSchedule";
+// import { handleBlobStorageIntegrationProjectJob } from "../ee/integrations/blobstorage/handleBlobStorageIntegrationProjectJob";
 
 export const blobStorageIntegrationProcessor: Processor = async (job) => {
   if (job.name === QueueJobs.BlobStorageIntegrationJob) {
-    logger.info("Executing Blob Storage Integration Job");
-    try {
-      return await handleBlobStorageIntegrationSchedule(job);
-    } catch (error) {
-      logger.error("Error executing BlobStorageIntegrationJob", error);
-      throw error;
-    }
+    throw new Error(`Blob Storage Integration Job is disabled`);
+    // logger.info("Executing Blob Storage Integration Job");
+    // try {
+    //   return await handleBlobStorageIntegrationSchedule(job);
+    // } catch (error) {
+    //   logger.error("Error executing BlobStorageIntegrationJob", error);
+    //   throw error;
+    // }
   }
 };
 
@@ -19,14 +20,15 @@ export const blobStorageIntegrationProcessingProcessor: Processor = async (
   job,
 ) => {
   if (job.name === QueueJobs.BlobStorageIntegrationProcessingJob) {
-    try {
-      return await handleBlobStorageIntegrationProjectJob(job);
-    } catch (error) {
-      logger.error(
-        "Error executing BlobStorageIntegrationProcessingJob",
-        error,
-      );
-      throw error;
-    }
+    throw new Error(`Blob Storage Integration Processing Job is disabled`);
+    // try {`
+    //   return await handleBlobStorageIntegrationProjectJob(job);
+    // } catch (error) {
+    //   logger.error(
+    //     "Error executing BlobStorageIntegrationProcessingJob",
+    //     error,
+    //   );
+    //   throw error;
+    // }
   }
 };
diff --git a/worker/src/queues/cloudUsageMeteringQueue.ts b/worker/src/queues/cloudUsageMeteringQueue.ts
index f391eb1..35bd3a4 100644
--- a/worker/src/queues/cloudUsageMeteringQueue.ts
+++ b/worker/src/queues/cloudUsageMeteringQueue.ts
@@ -1,36 +1,37 @@
 import { Processor } from "bullmq";
 import {
-  CloudUsageMeteringQueue,
+  // CloudUsageMeteringQueue,
   logger,
   QueueJobs,
 } from "@langfuse/shared/src/server";
-import { handleCloudUsageMeteringJob } from "../ee/cloudUsageMetering/handleCloudUsageMeteringJob";
-import { cloudUsageMeteringDbCronJobName } from "../ee/cloudUsageMetering/constants";
-import { CloudUsageMeteringDbCronJobStates } from "../ee/cloudUsageMetering/constants";
-import { prisma } from "@langfuse/shared/src/db";
+// import { handleCloudUsageMeteringJob } from "../ee/cloudUsageMetering/handleCloudUsageMeteringJob";
+// import { cloudUsageMeteringDbCronJobName } from "../ee/cloudUsageMetering/constants";
+// import { CloudUsageMeteringDbCronJobStates } from "../ee/cloudUsageMetering/constants";
+// import { prisma } from "@langfuse/shared/src/db";
 
 export const cloudUsageMeteringQueueProcessor: Processor = async (job) => {
   if (job.name === QueueJobs.CloudUsageMeteringJob) {
     logger.info("Executing Cloud Usage Metering Job", job.data);
-    try {
-      return await handleCloudUsageMeteringJob(job);
-    } catch (error) {
-      logger.error("Error executing Cloud Usage Metering Job", error);
-      // adding another job to the queue to process again.
-      await prisma.cronJobs.update({
-        where: {
-          name: cloudUsageMeteringDbCronJobName,
-        },
-        data: {
-          state: CloudUsageMeteringDbCronJobStates.Queued,
-          jobStartedAt: null,
-        },
-      });
-      await CloudUsageMeteringQueue.getInstance()?.add(
-        QueueJobs.CloudUsageMeteringJob,
-        {},
-      );
-      throw error;
-    }
+    throw new Error(`Cloud Usage Metering Job is disabled`);
+    // try {
+    //   return await handleCloudUsageMeteringJob(job);
+    // } catch (error) {
+    //   logger.error("Error executing Cloud Usage Metering Job", error);
+    //   // adding another job to the queue to process again.
+    //   await prisma.cronJobs.update({
+    //     where: {
+    //       name: cloudUsageMeteringDbCronJobName,
+    //     },
+    //     data: {
+    //       state: CloudUsageMeteringDbCronJobStates.Queued,
+    //       jobStartedAt: null,
+    //     },
+    //   });
+    //   await CloudUsageMeteringQueue.getInstance()?.add(
+    //     QueueJobs.CloudUsageMeteringJob,
+    //     {},
+    //   );
+    //   throw error;
+    // }
   }
 };
diff --git a/worker/src/queues/dataRetentionQueue.ts b/worker/src/queues/dataRetentionQueue.ts
index 8bee18e..fb9f3ff 100644
--- a/worker/src/queues/dataRetentionQueue.ts
+++ b/worker/src/queues/dataRetentionQueue.ts
@@ -1,27 +1,29 @@
 import { Processor } from "bullmq";
 import { logger, QueueJobs } from "@langfuse/shared/src/server";
-import { handleDataRetentionSchedule } from "../ee/dataRetention/handleDataRetentionSchedule";
-import { handleDataRetentionProcessingJob } from "../ee/dataRetention/handleDataRetentionProcessingJob";
+// import { handleDataRetentionSchedule } from "../ee/dataRetention/handleDataRetentionSchedule";
+// import { handleDataRetentionProcessingJob } from "../ee/dataRetention/handleDataRetentionProcessingJob";
 
 export const dataRetentionProcessor: Processor = async (job) => {
   if (job.name === QueueJobs.DataRetentionJob) {
-    logger.info("Executing Data Retention Job");
-    try {
-      return await handleDataRetentionSchedule(job);
-    } catch (error) {
-      logger.error("Error executing DataRetentionJob", error);
-      throw error;
-    }
+    throw new Error(`Data Retention Job is disabled`);
+    // logger.info("Executing Data Retention Job");
+    // try {
+    //   return await handleDataRetentionSchedule(job);
+    // } catch (error) {
+    //   logger.error("Error executing DataRetentionJob", error);
+    //   throw error;
+    // }
   }
 };
 
 export const dataRetentionProcessingProcessor: Processor = async (job) => {
   if (job.name === QueueJobs.DataRetentionProcessingJob) {
-    try {
-      return await handleDataRetentionProcessingJob(job);
-    } catch (error) {
-      logger.error("Error executing DataRetentionProcessingJob", error);
-      throw error;
-    }
+    throw new Error(`Data Retention Processing Job is disabled`);
+    // try {
+    //   return await handleDataRetentionProcessingJob(job);
+    // } catch (error) {
+    //   logger.error("Error executing DataRetentionProcessingJob", error);
+    //   throw error;
+    // }
   }
 };
diff --git a/worker/src/queues/evalQueue.ts b/worker/src/queues/evalQueue.ts
index 77f926e..aa51163 100644
--- a/worker/src/queues/evalQueue.ts
+++ b/worker/src/queues/evalQueue.ts
@@ -1,159 +1,176 @@
 import { Job } from "bullmq";
-import { ApiError, BaseError } from "@langfuse/shared";
-import { kyselyPrisma } from "@langfuse/shared/src/db";
-import { sql } from "kysely";
+// import { ApiError, BaseError } from "@langfuse/shared";
+// import { kyselyPrisma } from "@langfuse/shared/src/db";
+// import { sql } from "kysely";
 import {
   QueueName,
   TQueueJobTypes,
   logger,
-  traceException,
-  EvalExecutionQueue,
-  QueueJobs,
+  // traceException,
+  // EvalExecutionQueue,
+  // QueueJobs,
 } from "@langfuse/shared/src/server";
-import { createEvalJobs, evaluate } from "../ee/evaluation/evalService";
-import { randomUUID } from "crypto";
+// import { createEvalJobs, evaluate } from "../ee/evaluation/evalService";
+// import { randomUUID } from "crypto";
 
 export const evalJobTraceCreatorQueueProcessor = async (
   job: Job<TQueueJobTypes[QueueName.TraceUpsert]>,
 ) => {
-  try {
-    await createEvalJobs({
-      event: job.data.payload,
-      enforcedJobTimeScope: "NEW", // we must not execute evals which are intended for existing data only.
-    });
-    return true;
-  } catch (e) {
-    logger.error(
-      `Failed job Evaluation for traceId ${job.data.payload.traceId}`,
-      e,
-    );
-    traceException(e);
-    throw e;
-  }
+  logger.error(
+    `Failed job Evaluation for traceId ${job.data.payload.traceId}`,
+    'disabled',
+  );
+
+  // try {
+  //   await createEvalJobs({
+  //     event: job.data.payload,
+  //     enforcedJobTimeScope: "NEW", // we must not execute evals which are intended for existing data only.
+  //   });
+  //   return true;
+  // } catch (e) {
+  //   logger.error(
+  //     `Failed job Evaluation for traceId ${job.data.payload.traceId}`,
+  //     e,
+  //   );
+  //   traceException(e);
+  //   throw e;
+  // }
 };
 
 export const evalJobDatasetCreatorQueueProcessor = async (
   job: Job<TQueueJobTypes[QueueName.DatasetRunItemUpsert]>,
 ) => {
-  try {
-    await createEvalJobs({
-      event: job.data.payload,
-      enforcedJobTimeScope: "NEW", // we must not execute evals which are intended for existing data only.
-    });
-    return true;
-  } catch (e) {
-    logger.error(
-      `Failed job Evaluation for dataset item: ${job.data.payload.datasetItemId}`,
-      e,
-    );
-    traceException(e);
-    throw e;
-  }
+  logger.error(
+    `Failed job Evaluation for dataset item: ${job.data.payload.datasetItemId}`,
+    'disabled',
+  );
+  // try {
+  //   await createEvalJobs({
+  //     event: job.data.payload,
+  //     enforcedJobTimeScope: "NEW", // we must not execute evals which are intended for existing data only.
+  //   });
+  //   return true;
+  // } catch (e) {
+  //   logger.error(
+  //     `Failed job Evaluation for dataset item: ${job.data.payload.datasetItemId}`,
+  //     e,
+  //   );
+  //   traceException(e);
+  //   throw e;
+  // }
 };
 
 export const evalJobCreatorQueueProcessor = async (
   job: Job<TQueueJobTypes[QueueName.CreateEvalQueue]>,
 ) => {
-  try {
-    await createEvalJobs({
-      event: job.data.payload,
-    });
-    return true;
-  } catch (e) {
-    logger.error(
-      `Failed to create evaluation jobs: ${JSON.stringify(job.data.payload)}`,
-      e,
-    );
-    traceException(e);
-    throw e;
-  }
+  logger.error(
+    `Failed to create evaluation jobs: ${JSON.stringify(job.data.payload)}`,
+    'disabled',
+  );
+  // try {
+  //   await createEvalJobs({
+  //     event: job.data.payload,
+  //   });
+  //   return true;
+  // } catch (e) {
+  //   logger.error(
+  //     `Failed to create evaluation jobs: ${JSON.stringify(job.data.payload)}`,
+  //     e,
+  //   );
+  //   traceException(e);
+  //   throw e;
+  // }
 };
 
 export const evalJobExecutorQueueProcessor = async (
   job: Job<TQueueJobTypes[QueueName.EvaluationExecution]>,
 ) => {
-  try {
-    logger.info("Executing Evaluation Execution Job", job.data);
-    await evaluate({ event: job.data.payload });
-    return true;
-  } catch (e) {
-    // If the job fails with a 429, we want to retry it unless it's older than 24h.
-    if (e instanceof ApiError && e.httpCode === 429) {
-      try {
-        // Check if the job execution is older than 24h
-        const jobExecution = await kyselyPrisma.$kysely
-          .selectFrom("job_executions")
-          .select("created_at")
-          .where("id", "=", job.data.payload.jobExecutionId)
-          .where("project_id", "=", job.data.payload.projectId)
-          .executeTakeFirstOrThrow();
-        if (
-          // Do nothing if job execution is older than 24h
-          jobExecution.created_at < new Date(Date.now() - 24 * 60 * 60 * 1000)
-        ) {
-          logger.info(
-            `Job ${job.data.payload.jobExecutionId} is rate limited for more than 24h. Stop retrying.`,
-          );
-        } else {
-          // Add the job into the queue with a random delay between 1 and 10min and return
-          const delay = Math.floor(Math.random() * 9 + 1) * 60 * 1000;
-          logger.info(
-            `Job ${job.data.payload.jobExecutionId} is rate limited. Retrying in ${delay}ms.`,
-          );
-          await EvalExecutionQueue.getInstance()?.add(
-            QueueName.EvaluationExecution,
-            {
-              name: QueueJobs.EvaluationExecution,
-              id: randomUUID(),
-              timestamp: new Date(),
-              payload: job.data.payload,
-            },
-            {
-              delay,
-            },
-          );
-          return;
-        }
-      } catch (innerErr) {
-        logger.error(
-          `Failed to handle 429 retry for ${job.data.payload.jobExecutionId}. Continuing regular processing.`,
-          innerErr,
-        );
-      }
-    }
+  logger.error(
+    `Failed job Evaluation_Execution for id ${job.data.payload.jobExecutionId}`,
+    'disabled',
+  );
+  // try {
+  //   logger.info("Executing Evaluation Execution Job", job.data);
+  //   await evaluate({ event: job.data.payload });
+  //   return true;
+  // } catch (e) {
+  //   // If the job fails with a 429, we want to retry it unless it's older than 24h.
+  //   if (e instanceof ApiError && e.httpCode === 429) {
+  //     try {
+  //       // Check if the job execution is older than 24h
+  //       const jobExecution = await kyselyPrisma.$kysely
+  //         .selectFrom("job_executions")
+  //         .select("created_at")
+  //         .where("id", "=", job.data.payload.jobExecutionId)
+  //         .where("project_id", "=", job.data.payload.projectId)
+  //         .executeTakeFirstOrThrow();
+  //       if (
+  //         // Do nothing if job execution is older than 24h
+  //         jobExecution.created_at < new Date(Date.now() - 24 * 60 * 60 * 1000)
+  //       ) {
+  //         logger.info(
+  //           `Job ${job.data.payload.jobExecutionId} is rate limited for more than 24h. Stop retrying.`,
+  //         );
+  //       } else {
+  //         // Add the job into the queue with a random delay between 1 and 10min and return
+  //         const delay = Math.floor(Math.random() * 9 + 1) * 60 * 1000;
+  //         logger.info(
+  //           `Job ${job.data.payload.jobExecutionId} is rate limited. Retrying in ${delay}ms.`,
+  //         );
+  //         await EvalExecutionQueue.getInstance()?.add(
+  //           QueueName.EvaluationExecution,
+  //           {
+  //             name: QueueJobs.EvaluationExecution,
+  //             id: randomUUID(),
+  //             timestamp: new Date(),
+  //             payload: job.data.payload,
+  //           },
+  //           {
+  //             delay,
+  //           },
+  //         );
+  //         return;
+  //       }
+  //     } catch (innerErr) {
+  //       logger.error(
+  //         `Failed to handle 429 retry for ${job.data.payload.jobExecutionId}. Continuing regular processing.`,
+  //         innerErr,
+  //       );
+  //     }
+  //   }
 
-    const displayError =
-      e instanceof BaseError ? e.message : "An internal error occurred";
+  //   const displayError =
+  //     e instanceof BaseError ? e.message : "An internal error occurred";
 
-    await kyselyPrisma.$kysely
-      .updateTable("job_executions")
-      .set("status", sql`'ERROR'::"JobExecutionStatus"`)
-      .set("end_time", new Date())
-      .set("error", displayError)
-      .where("id", "=", job.data.payload.jobExecutionId)
-      .where("project_id", "=", job.data.payload.projectId)
-      .execute();
+  //   await kyselyPrisma.$kysely
+  //     .updateTable("job_executions")
+  //     .set("status", sql`'ERROR'::"JobExecutionStatus"`)
+  //     .set("end_time", new Date())
+  //     .set("error", displayError)
+  //     .where("id", "=", job.data.payload.jobExecutionId)
+  //     .where("project_id", "=", job.data.payload.projectId)
+  //     .execute();
 
-    // do not log expected errors (api failures + missing api keys not provided by the user)
-    if (
-      (e instanceof BaseError && e.message.includes("API key for provider")) || // api key not provided
-      (e instanceof ApiError && e.httpCode >= 400 && e.httpCode < 500) || // do not error and retry on 4xx errors. They are visible to the user in the UI but do not alert us.
-      (e instanceof ApiError && e.message.includes("TypeError")) || // Zod parsing the response failed. User should update prompt to consistently return expected output structure.
-      (e instanceof ApiError &&
-        e.message.includes("Error: Unterminated string in JSON at position")) || // When evaluator model is configured with too low max_tokens, the structured output response is invalid JSON
-      (e instanceof BaseError &&
-        e.message.includes(
-          "Please ensure the mapped data exists and consider extending the job delay.",
-        )) // Trace not found.
-    ) {
-      return;
-    }
+  //   // do not log expected errors (api failures + missing api keys not provided by the user)
+  //   if (
+  //     (e instanceof BaseError && e.message.includes("API key for provider")) || // api key not provided
+  //     (e instanceof ApiError && e.httpCode >= 400 && e.httpCode < 500) || // do not error and retry on 4xx errors. They are visible to the user in the UI but do not alert us.
+  //     (e instanceof ApiError && e.message.includes("TypeError")) || // Zod parsing the response failed. User should update prompt to consistently return expected output structure.
+  //     (e instanceof ApiError &&
+  //       e.message.includes("Error: Unterminated string in JSON at position")) || // When evaluator model is configured with too low max_tokens, the structured output response is invalid JSON
+  //     (e instanceof BaseError &&
+  //       e.message.includes(
+  //         "Please ensure the mapped data exists and consider extending the job delay.",
+  //       )) // Trace not found.
+  //   ) {
+  //     return;
+  //   }
 
-    traceException(e);
-    logger.error(
-      `Failed Evaluation_Execution job for id ${job.data.payload.jobExecutionId}`,
-      e,
-    );
-    throw e;
-  }
+  //   traceException(e);
+  //   logger.error(
+  //     `Failed Evaluation_Execution job for id ${job.data.payload.jobExecutionId}`,
+  //     e,
+  //   );
+  //   throw e;
+  // }
 };
diff --git a/worker/src/queues/experimentQueue.ts b/worker/src/queues/experimentQueue.ts
index b4f28a4..784bd4c 100644
--- a/worker/src/queues/experimentQueue.ts
+++ b/worker/src/queues/experimentQueue.ts
@@ -1,80 +1,84 @@
 import { Job } from "bullmq";
 import {
-  ExperimentMetadataSchema,
+  // ExperimentMetadataSchema,
   QueueName,
   TQueueJobTypes,
   logger,
-  traceException,
+  // traceException,
 } from "@langfuse/shared/src/server";
-import { createExperimentJob } from "../ee/experiments/experimentService";
-import { InvalidRequestError, LangfuseNotFoundError } from "@langfuse/shared";
-import { kyselyPrisma } from "@langfuse/shared/src/db";
+// import { createExperimentJob } from "../ee/experiments/experimentService";
+// import { InvalidRequestError, LangfuseNotFoundError } from "@langfuse/shared";
+// import { kyselyPrisma } from "@langfuse/shared/src/db";
 
 export const experimentCreateQueueProcessor = async (
   job: Job<TQueueJobTypes[QueueName.ExperimentCreate]>,
 ) => {
-  try {
-    logger.info("Starting to process experiment create job", {
-      jobId: job.id,
-      attempt: job.attemptsMade,
-      data: job.data,
-    });
-    await createExperimentJob({
-      event: job.data.payload,
-    });
-    return true;
-  } catch (e) {
-    if (
-      e instanceof InvalidRequestError ||
-      e instanceof LangfuseNotFoundError
-    ) {
-      logger.info(
-        `Failed to process experiment create job for project: ${job.data.payload.projectId}`,
-        e,
-      );
+  logger.error(
+    `Failed job Experiment Create for projectId ${job.data.payload.projectId}`,
+    "disabled",
+  );
+  // try {
+  //   logger.info("Starting to process experiment create job", {
+  //     jobId: job.id,
+  //     attempt: job.attemptsMade,
+  //     data: job.data,
+  //   });
+  //   await createExperimentJob({
+  //     event: job.data.payload,
+  //   });
+  //   return true;
+  // } catch (e) {
+  //   if (
+  //     e instanceof InvalidRequestError ||
+  //     e instanceof LangfuseNotFoundError
+  //   ) {
+  //     logger.info(
+  //       `Failed to process experiment create job for project: ${job.data.payload.projectId}`,
+  //       e,
+  //     );
 
-      try {
-        const currentRun = await kyselyPrisma.$kysely
-          .selectFrom("dataset_runs")
-          .selectAll()
-          .where("id", "=", job.data.payload.runId)
-          .where("project_id", "=", job.data.payload.projectId)
-          .executeTakeFirst();
+  //     try {
+  //       const currentRun = await kyselyPrisma.$kysely
+  //         .selectFrom("dataset_runs")
+  //         .selectAll()
+  //         .where("id", "=", job.data.payload.runId)
+  //         .where("project_id", "=", job.data.payload.projectId)
+  //         .executeTakeFirst();
 
-        if (
-          !currentRun ||
-          !currentRun.metadata ||
-          !ExperimentMetadataSchema.safeParse(currentRun.metadata).success
-        ) {
-          throw new LangfuseNotFoundError(
-            `Dataset run ${job.data.payload.runId} not found`,
-          );
-        }
+  //       if (
+  //         !currentRun ||
+  //         !currentRun.metadata ||
+  //         !ExperimentMetadataSchema.safeParse(currentRun.metadata).success
+  //       ) {
+  //         throw new LangfuseNotFoundError(
+  //           `Dataset run ${job.data.payload.runId} not found`,
+  //         );
+  //       }
 
-        // update experiment run metadata field with error
-        await kyselyPrisma.$kysely
-          .updateTable("dataset_runs")
-          .set({
-            metadata: {
-              ...currentRun.metadata,
-              error: e.message,
-            },
-          })
-          .where("id", "=", job.data.payload.runId)
-          .where("project_id", "=", job.data.payload.projectId)
-          .execute();
+  //       // update experiment run metadata field with error
+  //       await kyselyPrisma.$kysely
+  //         .updateTable("dataset_runs")
+  //         .set({
+  //           metadata: {
+  //             ...currentRun.metadata,
+  //             error: e.message,
+  //           },
+  //         })
+  //         .where("id", "=", job.data.payload.runId)
+  //         .where("project_id", "=", job.data.payload.projectId)
+  //         .execute();
 
-        // return true to indicate job was processed successfully and avoid retrying
-        return true;
-      } catch (e) {
-        logger.error("Failed to process experiment create job", e);
-        traceException(e);
-        throw e;
-      }
-    }
+  //       // return true to indicate job was processed successfully and avoid retrying
+  //       return true;
+  //     } catch (e) {
+  //       logger.error("Failed to process experiment create job", e);
+  //       traceException(e);
+  //       throw e;
+  //     }
+  //   }
 
-    logger.error("Failed to process experiment create job", e);
-    traceException(e);
-    throw e;
-  }
+  //   logger.error("Failed to process experiment create job", e);
+  //   traceException(e);
+  //   throw e;
+  // }
 };
diff --git a/worker/src/queues/postHogIntegrationQueue.ts b/worker/src/queues/postHogIntegrationQueue.ts
index 31b7838..9f0c748 100644
--- a/worker/src/queues/postHogIntegrationQueue.ts
+++ b/worker/src/queues/postHogIntegrationQueue.ts
@@ -1,27 +1,29 @@
 import { Processor } from "bullmq";
 import { logger, QueueJobs } from "@langfuse/shared/src/server";
-import { handlePostHogIntegrationSchedule } from "../ee/integrations/posthog/handlePostHogIntegrationSchedule";
-import { handlePostHogIntegrationProjectJob } from "../ee/integrations/posthog/handlePostHogIntegrationProjectJob";
+// import { handlePostHogIntegrationSchedule } from "../ee/integrations/posthog/handlePostHogIntegrationSchedule";
+// import { handlePostHogIntegrationProjectJob } from "../ee/integrations/posthog/handlePostHogIntegrationProjectJob";
 
 export const postHogIntegrationProcessor: Processor = async (job) => {
   if (job.name === QueueJobs.PostHogIntegrationJob) {
-    logger.info("Executing PostHog Integration Job");
-    try {
-      return await handlePostHogIntegrationSchedule(job);
-    } catch (error) {
-      logger.error("Error executing PostHogIntegrationJob", error);
-      throw error;
-    }
+    throw new Error(`PostHog Integration Job is disabled`);
+    // logger.info("Executing PostHog Integration Job");
+    // try {
+    //   return await handlePostHogIntegrationSchedule(job);
+    // } catch (error) {
+    //   logger.error("Error executing PostHogIntegrationJob", error);
+    //   throw error;
+    // }
   }
 };
 
 export const postHogIntegrationProcessingProcessor: Processor = async (job) => {
   if (job.name === QueueJobs.PostHogIntegrationProcessingJob) {
-    try {
-      return await handlePostHogIntegrationProjectJob(job);
-    } catch (error) {
-      logger.error("Error executing PostHogIntegrationProcessingJob", error);
-      throw error;
-    }
+    throw new Error(`PostHog Integration Processing Job is disabled`);
+    // try {
+    //   return await handlePostHogIntegrationProjectJob(job);
+    // } catch (error) {
+    //   logger.error("Error executing PostHogIntegrationProcessingJob", error);
+    //   throw error;
+    // }
   }
 };
